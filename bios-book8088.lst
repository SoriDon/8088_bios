     1                                  ;=========================================================================
     2                                  ; main.asm - BIOS main file
     3                                  ;	Skeleton for the BIOS
     4                                  ;	Power On Self Test (POST)
     5                                  ;	Interrupt table setup
     6                                  ;       INT 11h - Get equipment list
     7                                  ;       INT 12h - Get memory size
     8                                  ;-------------------------------------------------------------------------
     9                                  ;
    10                                  ; Compiles with NASM 2.13.02, might work with other versions
    11                                  ;
    12                                  ; Copyright (C) 2010 - 2023 Sergey Kiselev.
    13                                  ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
    14                                  ;
    15                                  ; This program is free software: you can redistribute it and/or modify
    16                                  ; it under the terms of the GNU General Public License as published by
    17                                  ; the Free Software Foundation, either version 3 of the License, or
    18                                  ; (at your option) any later version.
    19                                  ;
    20                                  ; This program is distributed in the hope that it will be useful,
    21                                  ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    22                                  ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    23                                  ; GNU General Public License for more details.
    24                                  ;
    25                                  ; You should have received a copy of the GNU General Public License
    26                                  ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    27                                  ;
    28                                  ;=========================================================================
    29                                  
    30                                  ;-------------------------------------------------------------------------
    31                                  ; Fixed BIOS Entry Points
    32                                  ; Source:
    33                                  ;	Intel(R) Platform Innovation Framework for EFI
    34                                  ;	Compatibility Support Module Specification
    35                                  ;	Section 5.2
    36                                  ;
    37                                  ;	Location	Description
    38                                  ;	--------	-----------
    39                                  ;	F000:E05B	POST Entry Point
    40                                  ;	F000:E2C3	NMI Entry Point
    41                                  ;	F000:E401	HDD Parameter Table
    42                                  ;	F000:E6F2	INT 19 Entry Point
    43                                  ;	F000:E6F5	Configuration Data Table
    44                                  ;	F000:E729	Baut Rate Generator Table
    45                                  ;	F000:E739	INT 14 Entry Point
    46                                  ;	F000:E82E	INT 16 Entry Point
    47                                  ;	F000:E987	INT 09 Entry Point
    48                                  ;	F000:EC59	INT 13 (Floppy) Entry Point
    49                                  ;	F000:EF57	INT 0E Entry Point
    50                                  ;	F000:EFC7	Floppy Disk Controller Parameter Table
    51                                  ;	F000:EFD2	INT 17
    52                                  ;	F000:F065	INT 10 (Video) Entry Point
    53                                  ;	F000:F0A4	INT 1D MDA and CGA Video Parameter Table
    54                                  ;	F000:F841	INT 12 Entry Point
    55                                  ;	F000:F84D	INT 11 Entry Point
    56                                  ;	F000:F859	INT 15 Entry Point
    57                                  ;	F000:FA6E	Low 128 Characters of Graphic Video Font
    58                                  ;	F000:FE6E	INT 1A Entry Point
    59                                  ;	F000:FEA5	INT 08 Entry Point
    60                                  ;	F000:FF53	Dummy Interrupt Handler (IRET)
    61                                  ;	F000:FF54	INT 05 (Print Screen) Entry Point
    62                                  ;	F000:FFF0	Power-On Entry Point
    63                                  ;	F000:FFF5	ROM Date in ASCII "MM/DD/YY" Format (8 Characters)
    64                                  ;	F000:FFFE	System Model (0xFC - AT, 0xFE - XT)
    65                                  
    66                                  	cpu	8086
    67                                  
    68                                  %include "macro.inc"
    69                              <1> ;=========================================================================
    70                              <1> ; macro.inc - Defines macros
    71                              <1> ;       setloc
    72                              <1> ;-------------------------------------------------------------------------
    73                              <1> ;
    74                              <1> ; Compiles with NASM 2.13.02, might work with other versions
    75                              <1> ;
    76                              <1> ; Copyright (C) 2010 - 2023 Sergey Kiselev.
    77                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
    78                              <1> ;
    79                              <1> ; This program is free software: you can redistribute it and/or modify
    80                              <1> ; it under the terms of the GNU General Public License as published by
    81                              <1> ; the Free Software Foundation, either version 3 of the License, or
    82                              <1> ; (at your option) any later version.
    83                              <1> ;
    84                              <1> ; This program is distributed in the hope that it will be useful,
    85                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    86                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    87                              <1> ; GNU General Public License for more details.
    88                              <1> ;
    89                              <1> ; You should have received a copy of the GNU General Public License
    90                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    91                              <1> ;
    92                              <1> ;=========================================================================
    93                              <1> 
    94                              <1> ;=========================================================================
    95                              <1> ; setloc - Set location. Insert 0FFh bytes until specifed location is reached.
    96                              <1> ;-------------------------------------------------------------------------
    97                              <1> %imacro setloc  1.nolist
    98                              <1> %assign pad_bytes (%1-($-$$)-START)
    99                              <1> %if pad_bytes < 0
   100                              <1> %assign over_bytes -pad_bytes
   101                              <1> %error Preceding code extends beyond setloc location by over_bytes bytes
   102                              <1> %endif
   103                              <1> %if pad_bytes > 0
   104                              <1> %warning Inserting pad_bytes bytes
   105                              <1>  times  pad_bytes db 0FFh
   106                              <1> %endif
   107                              <1> %endm
    69                                  %include "config.inc"
    70                              <1> ;=========================================================================
    71                              <1> ; config.inc - Compilation time settings and settings
    72                              <1> ;-------------------------------------------------------------------------
    73                              <1> ;
    74                              <1> ; Compiles with NASM 2.13.02, might work with other versions
    75                              <1> ;
    76                              <1> ; Copyright (C) 2010 - 2023 Sergey Kiselev.
    77                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
    78                              <1> ;
    79                              <1> ; This program is free software: you can redistribute it and/or modify
    80                              <1> ; it under the terms of the GNU General Public License as published by
    81                              <1> ; the Free Software Foundation, either version 3 of the License, or
    82                              <1> ; (at your option) any later version.
    83                              <1> ;
    84                              <1> ; This program is distributed in the hope that it will be useful,
    85                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    86                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    87                              <1> ; GNU General Public License for more details.
    88                              <1> ;
    89                              <1> ; You should have received a copy of the GNU General Public License
    90                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    91                              <1> ;
    92                              <1> ;=========================================================================
    93                              <1> 
    94                              <1> %define DATE		'06/21/23'	; BIOS release date MM/DD/YY
    95                              <1> %define VERSION		'1.0.0'		; BIOS version
    96                              <1> 
    97                              <1> ; Machine type is defined in the Makefile
    98                              <1> ;%define MACHINE_XI8088			; Xi 8088
    99                              <1> ;%define MACHINE_FE2010A 		; Faraday FE2010A
   100                              <1> ;%define MACHINE_BOOK8088		; Book8088
   101                              <1> ;%define MACHINE_XT			; IBM PC/XT or highly compatible board
   102                              <1> 					; FIXME: not implemented yet
   103                              <1> 
   104                              <1> ; Settings for Xi 8088
   105                              <1> %ifdef MACHINE_XI8088
   106                              <1> %define	START		8000h		; BIOS starts at offset 8000h
   107                              <1> %define MODEL_BYTE	0FCh		; Pretend it is an IBM PC/AT
   108                              <1> %define AT_RTC				; Has AT-compatible RTC
   109                              <1> %define AT_RTC_NVRAM			; Use AT RTC for BIOS configuration
   110                              <1> %define AT_NMI				; Use port 70h for NMI enable/disable
   111                              <1> %define AT_DELAY			; Use refresh bit of port 61h for delays
   112                              <1> %define SECOND_PIC			; Has two PICs (AT-style)
   113                              <1> %define AT_KEYBOARD			; Has AT-compatible keyboard controller
   114                              <1> %define PS2_MOUSE			; Enable PS/2 auxiliary device support
   115                              <1> %define DISABLE_KBD_DURING_INTERRUPTS	; Don't disable keyboard in INT1
   116                              <1> %define MIN_RAM_SIZE	32		; At least 32 KiB to boot the system
   117                              <1> %define MAX_RAM_SIZE	640		; Scan this much memory during POST
   118                              <1> %define RAM_TEST_BLOCK	16384		; block size for RAM test
   119                              <1> %define EBDA_SIZE	1		; 1KB reserved for EBDA
   120                              <1> 					; EBDA is required for PS/2 aux support
   121                              <1> %endif ; MACHINE_XI8088
   122                              <1> 
   123                              <1> ; Settings for FE2010A
   124                              <1> %ifdef MACHINE_FE2010A
   125                              <1> %define	START		0A000h		; BIOS starts at offset 0A000h
   126                              <1> %define MODEL_BYTE	0FEh		; IBM PC/XT
   127                              <1> %define AT_RTC				; Has AT-compatible RTC
   128                              <1> %define AT_RTC_AUTODETECT		; Autodetect RTC presence
   129                              <1> %define FLASH_NVRAM			; Use Flash ROM for BIOS configuration
   130                              <1> %define MIN_RAM_SIZE	32		; At least 32 KiB to boot the system
   131                              <1> %define MAX_RAM_SIZE	640		; Scan this much memory during POST
   132                              <1> %define RAM_TEST_BLOCK	16384		; block size for RAM test
   133                              <1> %endif ; MACHINE_FE2010A
   134                              <1> 
   135                              <1> ; Settings for Book8088
   136                              <1> %ifdef MACHINE_BOOK8088
   137                              <1> %define	START		0C000h		; BIOS starts at 0C000h - 16 KiB total
   138                              <1> %define MODEL_BYTE	0FEh		; IBM PC/XT
   139                              <1> %define MIN_RAM_SIZE	32		; At least 32 KiB to boot the system
   140                              <1> %define MAX_RAM_SIZE	640		; Scan this much memory during POST
   141                              <1> %define RAM_TEST_BLOCK	16384		; block size for RAM test
   142                              <1> %endif ; MACHINE_BOOK8088
   143                              <1> 
   144                              <1> ; Settings for IBM PC/XT
   145                              <1> %ifdef MACHINE_XT
   146                              <1> ;%define	START		0E000h		; BIOS starts at offset 0E000h
   147                              <1> %define	START		0C000h		; FIXME: more ROM for development
   148                              <1> %define MODEL_BYTE	0FEh		; IBM PC/XT
   149                              <1> %define MIN_RAM_SIZE	32		; At least 32 KiB to boot the system
   150                              <1> %define MAX_RAM_SIZE	640		; Scan this much memory during POST
   151                              <1> %define RAM_TEST_BLOCK	16384		; block size for RAM test
   152                              <1> %endif ; MACHINE_XT
   153                              <1> 
   154                              <1> ; Automatic settings based on the machine settings above
   155                              <1> %ifdef AT_RTC or AT_RTC_NVRAM or FLASH_NVRAM
   156                              <1> %define BIOS_SETUP			; Include BIOS setup utility
   157                              <1> %endif ; AT_RTC or AT_RTC_NVRAM or FLASH_NVRAM
   158                              <1> 
   159                              <1> %ifdef MACHINE_XI8088 or MACHINE_FE2010A or MACHINE_BOOK8088
   160                              <1> %define TURBO_MODE			; Has turbo mode
   161                              <1> %endif ; MACHINE_XI8088 or MACHINE_FE2010A or MACHINE_BOOK8088
   162                              <1> 
    70                                  %include "errno.inc"
    71                              <1> ;=========================================================================
    72                              <1> ; errno.inc - POST checkpoint codes (sent to port 80h during POST)
    73                              <1> ;-------------------------------------------------------------------------
    74                              <1> ;
    75                              <1> ; Compiles with NASM 2.13.02, might work with other versions
    76                              <1> ;
    77                              <1> ; Copyright (C) 2010 - 2023 Sergey Kiselev.
    78                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
    79                              <1> ;
    80                              <1> ; This program is free software: you can redistribute it and/or modify
    81                              <1> ; it under the terms of the GNU General Public License as published by
    82                              <1> ; the Free Software Foundation, either version 3 of the License, or
    83                              <1> ; (at your option) any later version.
    84                              <1> ;
    85                              <1> ; This program is distributed in the hope that it will be useful,
    86                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    87                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    88                              <1> ; GNU General Public License for more details.
    89                              <1> ;
    90                              <1> ; You should have received a copy of the GNU General Public License
    91                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    92                              <1> ;
    93                              <1> ;=========================================================================
    94                              <1> 
    95                              <1> e_boot		equ	00h		; Boot the OS
    96                              <1> e_cpu_test	equ	01h		; Start of BIOS POST, CPU test
    97                              <1> e_init_cfg	equ	02h		; Initial chipset configuration:
    98                              <1> 					; initialize PPI, disable NMI
    99                              <1> 					; disable turbo mode, disable display
   100                              <1> e_init_dmac	equ	03h		; Initialize DMAC initialized
   101                              <1> e_low_ram_test	equ	04h		; Test low 32 KiB of RAM
   102                              <1> e_int_table	equ	05h		; Initialize interrupt table
   103                              <1> e_pit_init	equ	06h		; Initialize PIT (timer)
   104                              <1> 					; play power on melody
   105                              <1> e_pic_init	equ	07h		; Initialize PIC
   106                              <1> e_kbd_init	equ	08h		; Initialize KBC and keyboard
   107                              <1> e_int_ena	equ	09h		; Enable interrupts
   108                              <1> e_vid_bios_scan	equ	10h		; Locate video BIOS
   109                              <1> e_vid_bios_init	equ	11h		; Initialize video BIOS
   110                              <1> e_vid_no_bios	equ	12h		; No video BIOS, using MDA/CGA
   111                              <1> e_rtc_init	equ	20h		; Initialize RTC
   112                              <1> e_cpu_detect	equ	21h		; Detect CPU type
   113                              <1> e_fpu_detect	equ	22h		; Detect FPU
   114                              <1> e_serial_scan	equ	24h		; Detect serial ports
   115                              <1> e_parallel_scan	equ	25h		; Detect parallel ports
   116                              <1> e_ram_start	equ	30h		; Start RAM test
   117                              <1> e_ram_complete	equ	31h		; RAM test completed
   118                              <1> e_ram_esc	equ	32h		; RAM test canceled
   119                              <1> e_ext_start	equ	40h		; Start BIOS extension ROM scan
   120                              <1> e_ext_detect	equ	41h		; BIOS extension ROM found, initizalize
   121                              <1> e_ext_init_ok	equ	42h		; BIOS extension ROM initialized
   122                              <1> e_ext_complete	equ	43h		; BIOS extension scan complete
   123                              <1> e_cpu_fail	equ	52h		; CPU test failed
   124                              <1> e_low_ram_fail	equ	54h		; Low 32 KiB RAM test failed
   125                              <1> e_ram_fail	equ	55h		; RAM test failed
   126                              <1> e_kbc_flsh_fail	equ	60h		; Unable to flush KBC output buffer
   127                              <1> e_kbc_cmd_fail	equ	61h		; Unable to send command to KBC
   128                              <1> e_kbc_test_fail	equ	62h		; Keyboard controller self test failed
   129                              <1> e_kbc_int_fail	equ	63h		; Keyboard interface test failed
   130                              <1> e_kbd_bat_fail	equ	70h		; Keyboard BAT test failed
   131                              <1> e_kbd_dis_fail	equ	71h		; Keyboard disable command failed
   132                              <1> e_kbd_ena_fail	equ	72h		; Keyboard enable command failed
   133                              <1> ;-------------------------------------------------------------------------
   134                              <1> ; Minor numbers for keyboard errors
   135                              <1> e_kbd_tout_fail	equ	01h		; Keyboard timeout sending command
   136                              <1> e_kbd_resp_fail	equ	02h		; Keyboard no response
   137                              <1> e_kbd_nack_fail	equ	03h		; Acknowledge response was expected
   138                              <1> 					; but keyboard have sent something else
   139                              <1> e_kbd_rsp2_fail	equ	04h		; Keyboard no response byte 2 for BAT
   140                              <1> e_kbd_nbat_fail	equ	05h		; BAT OK response was expected
   141                              <1> 					; but keyboard have sent something else
   142                              <1> e_kbd_test_fail	equ	06h		; Keyboard controller test failed
   143                              <1> e_kbd_int_fail	equ	07h		; Keyboard interface test failed
    71                                  
    72                                  bioscseg	equ	0F000h
    73                                  biosdseg	equ	0040h
    74                                  
    75                                  pic1_reg0	equ	20h
    76                                  pic1_reg1	equ	21h
    77                                  pit_ch0_reg	equ	40h
    78                                  pit_ch1_reg	equ	41h
    79                                  pit_ch2_reg	equ	42h
    80                                  pit_ctl_reg	equ	43h
    81                                  
    82                                  ; 8255 PPI port A I/O register - Read - keyboard data
    83                                  ppi_pa_reg	equ	60h	; 8255 PPI port A I/O register
    84                                  
    85                                  ; Port 61h - 8255 PPI Port B - Write only
    86                                  ppi_pb_reg	equ	61h	; 8255 PPI port B I/O register
    87                                  iochk_disable	equ	08h	; clear and disable ~IOCHK NMI
    88                                  refresh_flag	equ	10h	; refresh flag, toggles every 15us
    89                                  iochk_enable	equ	0F7h	; enable ~IOCHK NMI
    90                                  iochk_status	equ	40h	; ~IOCHK status - 1 = ~IOCHK NMI signalled
    91                                  
    92                                  %ifdef MACHINE_XT or MACHINE_FE2010A
    93                                  ; Port 62h - 8255 PPI Port C - Read only
    94                                  ppi_pc_reg	equ	62h	; 8255 PPI port C I/O registerA
    95                                  ; XT DIP switches 1-4 (read when bit 3 of PPI Port B is 1)
    96                                  sw_post_loop	equ	01h	; XT DIP switch 1 - 1 = Loop on POST
    97                                  sw_fpu_present	equ	02h	; XT DIP switch 2 - 1 = FPU present
    98                                  sw_ram_256k	equ	00h	; XT DIP switches 3-4 - 256 KiB
    99                                  sw_ram_512k	equ	04h	; XT DIP switches 3-4 - 512 KiB
   100                                  sw_ram_576k	equ	08h	; XT DIP switches 3-4 - 576 KiB
   101                                  sw_ram_640k	equ	0Ch	; XT DIP switches 3-4 - 640 KiB
   102                                  ; XT DIP switches 5-8 (read when bit 3 of PPI Port B is 0)
   103                                  sw_vid_none	equ	00h	; XT DIP switches 5-6 - No video, EGA, or VGA
   104                                  sw_vid_color_40	equ	01h	; XT DIP switches 5-6 - CGA, 80x25
   105                                  sw_vid_color_80	equ	02h	; XT DIP switches 5-6 - CGA, 40x25
   106                                  sw_vid_mono	equ	03h	; XT DIP switches 5-6 - Monochome, 80x25
   107                                  sw_one_floppy	equ	00h	; XT DIP switches 7-8 - One floppy
   108                                  sw_two_floppies	equ	01h	; XT DIP switches 7-8 - Two floppies
   109                                  sw_three_floppies equ	02h	; XT DIP switches 7-8 - Three floppies
   110                                  sw_four_floppies  equ	03h	; XT DIP switches 7-8 - Four floppies
   111                                  %endif ; MACHINE_XT or MACHINE_FE2010A
   112                                  
   113                                  ; FE2010/FE2010 - Ports 62h-63h
   114                                  %ifdef MACHINE_FE2010A
   115                                  ; Port 62h - Chipset Control Register - Write
   116                                  fe_control_reg	equ	62h
   117                                  fe_fpu_present	equ	02h	; FPU present
   118                                  fe_ram_256k	equ	00h	; XT DIP switches 3-4 - 256 KiB
   119                                  fe_ram_512k	equ	04h	; XT DIP switches 3-4 - 512 KiB
   120                                  fe_ram_576k	equ	08h	; XT DIP switches 3-4 - 576 KiB
   121                                  fe_ram_640k	equ	0Ch	; XT DIP switches 3-4 - 640 KiB
   122                                  fe_one_floppy	equ	00h	; XT DIP switches 7-8 - One floppy
   123                                  fe_two_floppies	equ	40h	; XT DIP switches 7-8 - Two floppies
   124                                  
   125                                  ; Port 63h - Chipset Configuration Register - Write only
   126                                  fe_config_reg	equ	63h	; Chipset configuration register
   127                                  fe_par_disable	equ	01h	; Disable memory parity checking
   128                                  fe_fpu_nma_ena 	equ	02h	; Enable FPU NMI
   129                                  fe_config_lock	equ	08h	; Write lock of control register and
   130                                  				; bits 0-4 of configuration register
   131                                  fe_clk_7_norm	equ	40h	; FE2010A 7.15 MHz CPU clock frequency, normal WS
   132                                  fe_clk_7_fast	equ	60h	; FE2010A 7.15 MHz CPU clock frequency, fast WS
   133                                  fe_clk_9_norm	equ	80h	; FE2010A 9.54 MHz CPU clock frequency, normal WS
   134                                  fe_clk_9_fast	equ	0C0h	; FE2010A 9.54 MHz CPU clock frequency, fast WS
   135                                  %endif ; MACHINE_FE2010A
   136                                  
   137                                  ; IBM PC/XT - Port 63h - 8255 PPI Control Word
   138                                  %ifdef MACHINE_XT
   139                                  ppi_cwd_reg	equ	63h	; 8255 PPI control word register
   140                                  ppi_cwd_value	equ	99h	; 8255 PPI control word value for IBM XT:
   141                                  				; Port A - mode 0 (simple I/O), input
   142                                  				; Port B - mode 0 (simple I/O), output
   143                                  				; Port C - output
   144                                  %endif ; MACHINE_XT
   145                                  
   146                                  post_reg	equ	80h	; POST status output port
   147                                  nmi_mask_reg	equ	0A0h
   148                                  %ifdef SECOND_PIC
   149                                  pic2_reg0	equ	0A0h
   150                                  pic2_reg1	equ	0A1h
   151                                  %endif ; SECOND_PIC
   152                                  unused_reg	equ	0C0h	; used for hardware detection and I/O delays
   153                                  cga_mode_reg	equ	3D8h
   154                                  mda_mode_reg	equ	3B8h
   155                                  
   156                                  ; NMI mask (written to 0A0h)
   157                                  nmi_disable	equ	00h	; disable NMI
   158                                  nmi_disa_mask	equ	7Fh	; disable NMI AND mask (bit 7 = 0)
   159                                  nmi_enable	equ	80h	; enable NMI OR mask (bit 7 = 1)
   160                                  
   161                                  pic_freq	equ	1193182	; PIC input frequency - 14318180 MHz / 12
   162                                  
   163                                  ;========================================================================
   164                                  ; BIOS data area variables
   165                                  ;------------------------------------------------------------------------
   166                                  equip_serial	equ	00h	; word[4] - addresses of serial ports
   167                                  				; or 0 if port doesn't exist
   168                                  equip_parallel	equ	08h	; word[3] - addresses of parallel ports
   169                                  				; or 0 if port doesn't exist
   170                                  ebda_segment	equ	0Eh	; word - address of EBDA segment
   171                                  equipment_list	equ	10h	; word - equpment list
   172                                  equip_floppies	equ	0000000000000001b	; floppy drivers installed
   173                                  equip_fpu	equ	0000000000000010b	; FPU installed
   174                                  equip_mouse	equ	0000000000000100b
   175                                  equip_video	equ	0000000000110000b	; video type bit mask
   176                                  equip_color_40	equ	0000000000010000b	; color 40x24 (mode 1)
   177                                  equip_color_80	equ	0000000000100000b	; color 80x25 (mode 3)
   178                                  equip_mono	equ	0000000000110000b	; mono 80x25 (mode 7)
   179                                  equip_floppy2	equ	0000000001000000b	; 2nd floppy drive installed
   180                                  ;			|||||||||||||||`-- floppy drives installed
   181                                  ;			||||||||||||||`-- FPU installed
   182                                  ;			|||||||||||||`-- PS/2 mouse installed
   183                                  ;			||||||||||||`-- reserved
   184                                  ;			||||||||||`--- initial video mode
   185                                  ;			||||||||`---- number of floppy drives - 1
   186                                  ;			|||||||`---- O = DMA installed
   187                                  ;			||||`------ number of serial ports
   188                                  ;			|||`------ game adapter installed
   189                                  ;			||`------ internal modem?!
   190                                  ;			`------- number of parallel ports
   191                                  
   192                                  post_flags	equ	12h	; byte - post flags
   193                                  post_setup	equ	01h	; run NVRAM setup
   194                                  memory_size	equ	13h	; word - memory size in KiB
   195                                  kbd_flags_1	equ	17h	; byte - keyboard shift flags 1
   196                                  kbd_flags_2	equ	18h	; byte - keyboard shift flags 2
   197                                  kbd_alt_keypad	equ	19h	; byte - work area for Alt+Numpad
   198                                  kbd_buffer_head	equ	1Ah	; word - keyboard buffer head offset
   199                                  kbd_buffer_tail	equ	1Ch	; word - keyboard buffer tail offset
   200                                  kbd_buffer	equ	1Eh	; byte[32] - keyboard buffer
   201                                  fdc_calib_state	equ	3Eh	; byte - floppy drive recalibration status
   202                                  fdc_motor_state	equ	3Fh	; byte - floppy drive motor status
   203                                  fdc_motor_tout	equ	40h	; byte - floppy drive motor off timeout (ticks)
   204                                  fdc_last_error	equ	41h	; byte - status of last diskette operation
   205                                  fdc_ctrl_status	equ	42h	; byte[7] - FDC status bytes
   206                                  video_mode	equ	49h	; byte - active video mode number
   207                                  video_columns	equ	4Ah	; word - number of text columns for active mode
   208                                  video_page_size	equ	4Ch	; word - size of video page in bytes
   209                                  video_page_offt	equ	4Eh	; word - offset of the active video page
   210                                  video_cur_pos	equ	50h	; byte[16] - cursor position for each page
   211                                  video_cur_shape	equ	60h	; word - cursor shape
   212                                  video_page	equ	62h	; byte - active video page
   213                                  video_port	equ	63h	; word - I/O port for the display adapter
   214                                  video_mode_reg	equ	65h	; byte - video adapter mode register
   215                                  video_palet_reg	equ	66h	; byte - color palette
   216                                  last_irq	equ	6Bh	; byte - Last spurious IRQ number
   217                                  ticks_lo	equ	6Ch	; word - timer ticks - low word
   218                                  ticks_hi	equ	6Eh	; word - timer ticks - high word
   219                                  new_day		equ	70h	; byte - 1 = new day flag
   220                                  break_flag	equ	71h	; byte - bit 7 = 1 if Ctrl-Break was pressed
   221                                  warm_boot	equ	72h	; word - Warm boot if equals 1234h
   222                                  printer_timeout	equ	78h	; byte[3] - parallel port timeout values
   223                                  serial_timeout	equ	7Ch	; byte[4] - serial port timeout values
   224                                  kbd_buffer_start equ	80h	; word - keyboard buffer start offset
   225                                  kbd_buffer_end	equ	82h	; word - keyboard buffer end offset
   226                                  video_rows	equ	84h	; byte - number of text rows (EGA+)
   227                                  fdc_last_rate	equ	8Bh	; byte - last data rate / step rate
   228                                  fdc_info	equ	8Fh	; byte - floppy dist drive information
   229                                  fdc_media_state	equ	90h	; byte[4] - drive media state (drives 0 - 3)
   230                                  fdc_cylinder	equ	94h	; byte[2] - current cylinder (drives 0 - 1)
   231                                  kbd_flags_3	equ	96h	; byte - keyboard status flags 3
   232                                  kbd_flags_4	equ	97h	; byte - keyboard status flags 4
   233                                  vga_table_ptr	equ	0A8h	; dword - BIOS Video Save/Override Pointer
   234                                  				;       Table address
   235                                  prt_scrn_flags	equ	100h	; byte - print screen flags
   236                                  prt_scrn_ready	equ	00h	;	print screen is not in progress
   237                                  prt_scrn_run	equ	01h	; 	print screen is in progress
   238                                  prt_scrn_fail	equ	0FFh	;	last print screen attempt has failed
   239                                  
   240                                  ;=========================================================================
   241                                  ; Extended BIOS data area variables
   242                                  ;-------------------------------------------------------------------------
   243                                  ebda_size	equ	0h
   244                                  mouse_driver	equ	22h	; 4 bytes - pointer to mouse driver
   245                                  mouse_flags_1	equ	26h
   246                                  mouse_flags_2	equ	27h
   247                                  mouse_data	equ	28h	; 8 bytes - mouse data buffer
   248                                  
   249                                  	org	START		; Use only upper 32 KiB of ROM
   250                                  
   251                                  ;=========================================================================
   252                                  ; Includes
   253                                  ;-------------------------------------------------------------------------
   254                                  %include	"messages.inc"		; POST messages
   255                              <1> ;=========================================================================
   256                              <1> ; messages.inc - Messages printed by BIOS POST (Power On Self Test)
   257                              <1> ;-------------------------------------------------------------------------
   258                              <1> ;
   259                              <1> ; Compiles with NASM 2.13.02, might work with other versions
   260                              <1> ;
   261                              <1> ; Copyright (C) 2010 - 2023 Sergey Kiselev.
   262                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
   263                              <1> ;
   264                              <1> ; This program is free software: you can redistribute it and/or modify
   265                              <1> ; it under the terms of the GNU General Public License as published by
   266                              <1> ; the Free Software Foundation, either version 3 of the License, or
   267                              <1> ; (at your option) any later version.
   268                              <1> ;
   269                              <1> ; This program is distributed in the hope that it will be useful,
   270                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   271                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   272                              <1> ; GNU General Public License for more details.
   273                              <1> ;
   274                              <1> ; You should have received a copy of the GNU General Public License
   275                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   276                              <1> ;
   277                              <1> ;=========================================================================
   278                              <1> 
   279 00000000 0D0A                <1> msg_copyright	db	0Dh, 0Ah
   280                              <1> %ifdef MACHINE_XI8088
   281                              <1> 		db	"Xi 8088"
   282                              <1> %endif ; MACHINE_XI8088
   283                              <1> %ifdef MACHINE_FE2010A
   284                              <1> 		db	"Micro 8088"
   285                              <1> %endif ; MACHINE_FE2010A
   286                              <1> %ifdef MACHINE_BOOK8088
   287 00000002 426F6F6B38303838    <1> 		db	"Book8088"
   288                              <1> %endif ; MACHINE_BOOK8088
   289                              <1> %ifdef MACHINE_XT
   290                              <1> 		db	"XT 8088"
   291                              <1> %endif ; MACHINE_XT
   292 0000000A 2042494F532C205665- <1> 		db	" BIOS, Version "
   292 00000013 7273696F6E20        <1>
   293 00000019 312E302E30          <1> 		db	VERSION
   294 0000001E 2E20                <1> 		db	". "
   295 00000020 436F70797269676874- <1> 		db	"Copyright (C) 2010 - 2023 Sergey Kiselev", 0Dh, 0Ah
   295 00000029 202843292032303130- <1>
   295 00000032 202D20323032332053- <1>
   295 0000003B 6572676579204B6973- <1>
   295 00000044 656C65760D0A        <1>
   296 0000004A 446973747269627574- <1> 		db	"Distributed under the terms of "
   296 00000053 656420756E64657220- <1>
   296 0000005C 746865207465726D73- <1>
   296 00000065 206F6620            <1>
   297 00000069 74686520474E552047- <1> 		db	"the GNU General Public License", 0Dh, 0Ah
   297 00000072 656E6572616C205075- <1>
   297 0000007B 626C6963204C696365- <1>
   297 00000084 6E73650D0A          <1>
   298 00000089 0D0A00              <1> msg_crlf	db      0Dh, 0Ah, 00h
   299 0000008C 6E6F6E6500          <1> msg_none	db	'none', 00h
   300 00000091 3A2000              <1> msg_colon	db	': ', 00h
   301 00000094 3B2000              <1> msg_semicolon	db	'; ', 00h
   302                              <1> %ifdef TURBO_MODE
   303 00000097 43505520636C6F636B- <1> msg_cpu_clk	db	'CPU clock frequency:        ', 00h
   303 000000A0 206672657175656E63- <1>
   303 000000A9 793A20202020202020- <1>
   303 000000B2 2000                <1>
   304 000000B4 20402000            <1> msg_at		db	' @ ', 00h
   305 000000B8 342E3737204D487A20- <1> msg_clk_4_77mhz	db	'4.77 MHz ', 00h
   305 000000C1 00                  <1>
   306                              <1> %ifdef MACHINE_FE2010A
   307                              <1> msg_clk_7_16mhz	db	'7.16 MHz ', 00h
   308                              <1> msg_clk_9_55mhz	db	'9.55 MHz ', 00h
   309                              <1> %else ; MACHINE_FE2010A
   310 000000C2 547572626F2000      <1> msg_clk_turbo	db	'Turbo ', 00h
   311                              <1> %endif ; MACHINE_FE2010A
   312                              <1> %endif ; TURBO_MODE
   313 000000C9 4D61696E2050726F63- <1> msg_cpu		db      'Main Processor:             ', 00h
   313 000000D2 6573736F723A202020- <1>
   313 000000DB 202020202020202020- <1>
   313 000000E4 2000                <1>
   314 000000E6 4D617468656D617469- <1> msg_fpu		db      'Mathematics Co-processor:   ', 00h
   314 000000EF 637320436F2D70726F- <1>
   314 000000F8 636573736F723A2020- <1>
   314 00000101 2000                <1>
   315 00000103 496E74656C20383038- <1> msg_cpu_8088_78	db      "Intel 8088 '78", 00h
   315 0000010C 382027373800        <1>
   316 00000112 5741524E494E473A20- <1> msg_cpu_bug	db      'WARNING: This CPU does not disable interrupts '
   316 0000011B 546869732043505520- <1>
   316 00000124 646F6573206E6F7420- <1>
   316 0000012D 64697361626C652069- <1>
   316 00000136 6E7465727275707473- <1>
   316 0000013F 20                  <1>
   317 00000140 6166746572206C6F61- <1> 		db      'after loading segment registers!', 0Dh, 0Ah, 00h
   317 00000149 64696E67207365676D- <1>
   317 00000152 656E74207265676973- <1>
   317 0000015B 74657273210D0A00    <1>
   318 00000163 496E74656C20383038- <1> msg_cpu_8088_81	db      "Intel 8088 '81 or later, "
   318 0000016C 3820273831206F7220- <1>
   318 00000175 6C617465722C20      <1>
   319 0000017C 6F72204F4B492D6465- <1> 		db      'or OKI-designed 80C88', 00h
   319 00000185 7369676E6564203830- <1>
   319 0000018E 43383800            <1>
   320 00000192 4861727269732D6465- <1> msg_cpu_harris  db      'Harris-designed 80C88', 00h
   320 0000019B 7369676E6564203830- <1>
   320 000001A4 43383800            <1>
   321 000001A8 4E45432056323000    <1> msg_cpu_nec_v20 db      'NEC V20', 00h
   322 000001B0 496E74656C20383038- <1> msg_fpu_present db      'Intel 8087', 0Dh, 0Ah, 00h
   322 000001B9 370D0A00            <1>
   323                              <1> %ifdef MACHINE_FE2010A
   324                              <1> msg_chipset	db	'Chipset:                    ', 00h
   325                              <1> msg_fe2010a	db	'Faraday FE2010A', 0Dh, 0Ah, 00h
   326                              <1> msg_pt8010af	db	'Proton PT8010AF', 0Dh, 0Ah, 00h
   327                              <1> %endif ; MACHINE_FE2010A
   328 000001BD 446973706C61792041- <1> msg_disp	db      'Display Adapter Type:       ', 00h
   328 000001C6 646170746572205479- <1>
   328 000001CF 70653A202020202020- <1>
   328 000001D8 2000                <1>
   329 000001DA 4547412F5647412028- <1> msg_disp_ega	db      'EGA/VGA (Video BIOS Present)', 0Dh, 0Ah, 00h
   329 000001E3 566964656F2042494F- <1>
   329 000001EC 532050726573656E74- <1>
   329 000001F5 290D0A00            <1>
   330 000001F9 434741202838307832- <1> msg_disp_cga_80	db      'CGA (80x25)', 0Dh, 0Ah, 00h
   330 00000202 35290D0A00          <1>
   331 00000207 434741202834307832- <1> msg_disp_cga_40	db      'CGA (40x25)', 0Dh, 0Ah, 00h
   331 00000210 35290D0A00          <1>
   332 00000215 4D4441206F72204865- <1> msg_disp_mda	db      'MDA or Hercules', 0Dh, 0Ah, 00h
   332 0000021E 7263756C65730D0A00  <1>
   333 00000227 52544320285265616C- <1> msg_rtc		db	'RTC (Real Time Clock):      ', 00h
   333 00000230 2054696D6520436C6F- <1>
   333 00000239 636B293A2020202020- <1>
   333 00000242 2000                <1>
   334 00000244 466C6F707079206469- <1> msg_floppy	db	'Floppy disk drives:         Drive 0: ', 00h
   334 0000024D 736B20647269766573- <1>
   334 00000256 3A2020202020202020- <1>
   334 0000025F 20447269766520303A- <1>
   334 00000268 2000                <1>
   335 0000026A 3B2044726976652031- <1> msg_floppy_2	db	'; Drive 1: ', 00h
   335 00000273 3A2000              <1>
   336 00000276 333630204B422C2035- <1> msg_floppy_360	db	'360 KB, 5.25"', 00h
   336 0000027F 2E32352200          <1>
   337 00000284 312E32204D422C2035- <1> msg_floppy_1200	db	'1.2 MB, 5.25"', 00h
   337 0000028D 2E32352200          <1>
   338 00000292 373230204B422C2033- <1> msg_floppy_720	db	'720 KB, 3.5"', 00h
   338 0000029B 2E352200            <1>
   339 0000029F 312E3434204D422C20- <1> msg_floppy_1440	db	'1.44 MB, 3.5"', 00h
   339 000002A8 332E352200          <1>
   340 000002AD 322E3838204D422C20- <1> msg_floppy_2880	db	'2.88 MB, 3.5"', 00h
   340 000002B6 332E352200          <1>
   341                              <1> %ifdef PS2_MOUSE
   342                              <1> msg_mouse	db      'PS/2 Aux Device (Mouse):    ', 00h
   343                              <1> %endif ; PS2_MOUSE
   344 000002BB 50726573656E740D0A- <1> msg_present	db      'Present', 0Dh, 0Ah, 00h
   344 000002C4 00                  <1>
   345 000002C5 416273656E740D0A00  <1> msg_absent	db      'Absent', 0Dh, 0Ah, 00h
   346 000002CE 53657269616C20506F- <1> msg_serial	db	'Serial Ports:               ', 00h
   346 000002D7 7274733A2020202020- <1>
   346 000002E0 202020202020202020- <1>
   346 000002E9 2000                <1>
   347 000002EB 434F4D00            <1> msg_serial_com	db	'COM', 00h
   348 000002EF 506172616C6C656C20- <1> msg_parallel	db	'Parallel Ports:             ', 00h
   348 000002F8 506F7274733A202020- <1>
   348 00000301 202020202020202020- <1>
   348 0000030A 2000                <1>
   349 0000030C 4C505400            <1> msg_parallel_lpt db	'LPT', 00h
   350 00000310 54657374696E672052- <1> msg_ram_testing	db	'Testing RAM (ESC to skip):  ', 00h
   350 00000319 414D20284553432074- <1>
   350 00000322 6F20736B6970293A20- <1>
   350 0000032B 2000                <1>
   351 0000032D 0D0A4552524F523A20- <1> msg_ram_error	db	0Dh, 0Ah, 'ERROR: Faulty memory detected at ', 00h
   351 00000336 4661756C7479206D65- <1>
   351 0000033F 6D6F72792064657465- <1>
   351 00000348 637465642061742000  <1>
   352 00000351 0D546F74616C20436F- <1> msg_ram_total	db      0Dh, 'Total Conventional RAM:     ', 00h
   352 0000035A 6E76656E74696F6E61- <1>
   352 00000363 6C2052414D3A202020- <1>
   352 0000036C 202000              <1>
   353                              <1> %ifdef EBDA_SIZE
   354                              <1> msg_ebda	db      'Reserved for EBDA:          ', 00h
   355                              <1> msg_ram_avail	db      'Available Conventional RAM: ', 00h
   356                              <1> %endif ; EBDA_SIZE
   357 0000036F 204B69420D0A00      <1> msg_kib		db      ' KiB', 0Dh, 0Ah, 00h
   358 00000376 426F6F74206661696C- <1> msg_boot_failed	db      'Boot failed, press any key to try again...', 0Dh, 0Ah, 0
   358 0000037F 65642C207072657373- <1>
   358 00000388 20616E79206B657920- <1>
   358 00000391 746F20747279206167- <1>
   358 0000039A 61696E2E2E2E0D0A00  <1>
   359 000003A3 4E6F20524F4D204241- <1> msg_no_basic    db      'No ROM BASIC', 0Dh, 0Ah, 0
   359 000003AC 5349430D0A00        <1>
   360 000003B2 466F756E642042494F- <1> msg_rom_found   db      'Found BIOS extension ROM at ', 0
   360 000003BB 5320657874656E7369- <1>
   360 000003C4 6F6E20524F4D206174- <1>
   360 000003CD 2000                <1>
   361 000003CF 302C20696E69746961- <1> msg_rom_init	db	'0, initializing...', 0Dh, 0Ah, 0
   361 000003D8 6C697A696E672E2E2E- <1>
   361 000003E1 0D0A00              <1>
   362 000003E4 426F6F74696E67204F- <1> msg_boot	db      'Booting OS...', 0Dh, 0Ah, 0
   362 000003ED 532E2E2E0D0A00      <1>
   363                              <1> %ifdef AT_RTC
   364                              <1> msg_rtc_bad	db	'ERROR: RTC battery is bad', 0Dh, 0Ah, 00h
   365                              <1> %endif ; AT_RTC
   366                              <1> %ifdef AT_RTC_NVRAM
   367                              <1> msg_rtc_sum	db	'ERROR: NVRAM checksum is invalid, '
   368                              <1> 		db	'loading default values to NVRAM', 0Dh, 0Ah, 00h
   369                              <1> %endif ; AT_RTC_NVRAM
   370                              <1> %ifdef BIOS_SETUP
   371                              <1> msg_setup	db	'Press F1 to run BIOS setup...',0Dh, 0Ah, 0Dh, 0Ah, 00h
   372                              <1> msg_set_welcome	db	0Dh, 0Ah, 'Welcome to the BIOS setup utility', 00h
   373                              <1> msg_set_help	db	0Dh, 0Ah
   374                              <1> 		db	'BIOS setup commands:', 0Dh, 0Ah
   375                              <1> 		db	'f - Change first floppy drive type', 0Dh, 0Ah
   376                              <1> 		db	'g - Change second floppy drive type', 0Dh, 0Ah
   377                              <1> 		db	'e - Change BIOS extension ROM scan settings', 0Dh, 0Ah
   378                              <1> 		db	'm - Change memory test settings', 0Dh, 0Ah
   379                              <1> %ifdef TURBO_MODE
   380                              <1> 		db	'c - Set default CPU clock frequency', 0Dh, 0Ah
   381                              <1> %endif ; TURBO_MODE
   382                              <1> %ifdef MACHINE_FE2010A
   383                              <1> 		db	's - Change wait state settings', 0Dh, 0Ah
   384                              <1> %endif ; MACHINE_FE2010A
   385                              <1> 		db	00h
   386                              <1> %ifdef AT_RTC
   387                              <1> msg_set_rtc_help db	't - Set time', 0Dh, 0Ah
   388                              <1> 		db	'd - Set date', 0Dh, 0Ah, 00h
   389                              <1> %endif ; AT_RTC
   390                              <1> msg_set_def_help db	'p - Print current settings', 0Dh, 0Ah
   391                              <1> 		db	'w - Save changes and exit', 0Dh, 0Ah
   392                              <1> 		db	'q - Exit without saving changes', 0Dh, 0Ah
   393                              <1> 		db	'h - Show this help', 0Dh, 0Ah, 00h
   394                              <1> msg_set_prompt	db	0Dh, 0Ah, 'Enter command (h for help): ', 00h
   395                              <1> %ifdef TURBO_MODE
   396                              <1> msg_set_clk_help db 	0Dh, 0Ah
   397                              <1> 		db	'CPU clock frequency options:', 0Dh, 0Ah
   398                              <1> 		db	'4 - 4.77 MHz', 0Dh, 0Ah
   399                              <1> %ifdef MACHINE_FE2010A
   400                              <1> 		db	'7 - 7.16 MHz', 0Dh, 0Ah
   401                              <1> 		db	'9 - 9.55 MHz', 0Dh, 0Ah, 00h
   402                              <1> %else ; MACHINE_FE2010A
   403                              <1> 		db	't - Turbo', 0Dh, 0Ah, 00h
   404                              <1> %endif ; MACHINE_FE2010A
   405                              <1> msg_set_clk_prmt db	0Dh, 0Ah, 'Enter CPU clock frequency (h for help): '
   406                              <1> 		db	00h
   407                              <1> %endif ; TURBO_MODE
   408                              <1> %ifdef AT_RTC
   409                              <1> msg_set_time	db	'Enter time (hh:mm:ss): ', 00h
   410                              <1> msg_set_date	db	'Enter date (YYYY-MM-DD): ', 00h
   411                              <1> msg_time_inval	db	'ERROR: Invalid time.', 0Dh, 0Ah, 00h
   412                              <1> msg_date_inval	db	'ERROR: Invalid date.', 0Dh, 0Ah, 00h
   413                              <1> %endif ; AT_RTC
   414                              <1> msg_set_fd_help	db	0Dh, 0Ah
   415                              <1> 		db	'Floppy drive types:', 0Dh, 0Ah
   416                              <1> 		db	'0 - Not installed   3 - 720 KB, 3.5"', 0Dh, 0Ah
   417                              <1> 		db	'1 - 360 KB, 5.25"   4 - 1.44 MB, 3.5"', 0Dh, 0Ah
   418                              <1> 		db	'2 - 1.2 MB, 5.25"   6 - 2.88 MB, 3.5"', 0Dh, 0Ah, 00h
   419                              <1> msg_set_sub_help db	'Setup commands:', 0Dh, 0Ah
   420                              <1> 		db	'r - Return to the main menu', 0Dh, 0Ah
   421                              <1> 		db	'h - Show this help', 0Dh, 0Ah, 00h
   422                              <1> msg_set_fd_prmt	db	0Dh, 0Ah, 'Enter floppy drive type (h for help): '
   423                              <1> 		db	00h
   424                              <1> msg_set_ext	db	'Scan F0000-F7FFF area for BIOS extension ROMs (y/n): '
   425                              <1> 		db	00h
   426                              <1> msg_ext_scan	db	'F0000-F7FFF BIOS ext. scan: ', 00h
   427                              <1> msg_set_mem_tst	db	'Enable memory test (y/n): ', 00h
   428                              <1> msg_mem_test	db	'Memory test:                ', 00h
   429                              <1> %ifdef MACHINE_FE2010A
   430                              <1> msg_set_ws	db	'Fast wait states (y/n, h for help): ', 00h
   431                              <1> msg_ws_help	db	0Dh, 0Ah
   432                              <1> 		db	'Wait states configuration for FE2010A and PT8010AF:',
   433                              <1> 		db	0Dh, 0Ah
   434                              <1> 		db	'7.15 MHz, normal: I/O - 4 WS; Upper memory - 2 WS'
   435                              <1> 		db	0Dh, 0Ah
   436                              <1> 		db	'7.15 MHz, fast:   I/O - 4 WS; Upper memory - 0 WS'
   437                              <1> 		db	0Dh, 0Ah
   438                              <1> 		db	'9.54 MHz, normal: I/O - 6 WS; Upper memory - 4 WS'
   439                              <1> 		db	0Dh, 0Ah
   440                              <1> 		db	'9.54 MHz, fast:   I/O - 4 WS; Upper memory - 2 WS'
   441                              <1> 		db	0Dh, 0Ah, 00h
   442                              <1> msg_ws		db	'Fast wait states:           ', 00h
   443                              <1> %endif ; MACHINE_FE2010A
   444                              <1> msg_enabled	db	'Enabled', 00h
   445                              <1> msg_disabled	db	'Disabled', 00h
   446                              <1> %ifdef FLASH_NVRAM
   447                              <1> msg_saving	db	0Dh, 0Ah, 'Saving configuration to Flash ROM... ', 00h
   448                              <1> msg_save_ok	db	'OK', 0Dh, 0Ah, 00h
   449                              <1> msg_save_error	db	'ERROR', 0Dh, 0Ah, 00h
   450                              <1> %endif ; FLASH_NVRAM
   451                              <1> %endif ; BIOS_SETUP
   452 000003F4 [8C00]              <1> tbl_floppy	dw	msg_none
   453 000003F6 [7602]              <1> 		dw	msg_floppy_360
   454 000003F8 [8402]              <1> 		dw	msg_floppy_1200
   455 000003FA [9202]              <1> 		dw	msg_floppy_720
   456 000003FC [9F02]              <1> 		dw	msg_floppy_1440
   457 000003FE [8C00]              <1> 		dw	msg_none
   458 00000400 [AD02]              <1> 		dw	msg_floppy_2880
   459 00000402 [8C00]              <1> 		dw	msg_none
   255                                  %ifndef MACHINE_XT			; No space in XT ROM for font
   256                                  %include	"fnt80-FF.inc"		; font for graphics modes
   257                              <1> ;=========================================================================
   258                              <1> ; fnt80-FF.inc - Font for graphics modes (Cyrillic font)
   259                              <1> ;       Characters from 80h to 0FFh
   260                              <1> ;-------------------------------------------------------------------------
   261                              <1> ;
   262                              <1> ; Compiles with NASM 2.13.02, might work with other versions
   263                              <1> ;
   264                              <1> ; This font is borrowed from kbd package (alt-8x8)
   265                              <1> ;
   266                              <1> ; This program is free software: you can redistribute it and/or modify
   267                              <1> ; it under the terms of the GNU General Public License as published by
   268                              <1> ; the Free Software Foundation, either version 3 of the License, or
   269                              <1> ; (at your option) any later version.
   270                              <1> ;
   271                              <1> ; This program is distributed in the hope that it will be useful,
   272                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   273                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   274                              <1> ; GNU General Public License for more details.
   275                              <1> ;
   276                              <1> ; You should have received a copy of the GNU General Public License
   277                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   278                              <1> ;
   279                              <1> ;=========================================================================
   280                              <1> int_1F:
   281 00000404 1E3666667E666600    <1> 	db	 1Eh,  36h,  66h,  66h,  7Eh,  66h,  66h,  00h
   282 0000040C 7C60607C66667C00    <1> 	db	 7Ch,  60h,  60h,  7Ch,  66h,  66h,  7Ch,  00h
   283 00000414 7C66667C66667C00    <1> 	db	 7Ch,  66h,  66h,  7Ch,  66h,  66h,  7Ch,  00h
   284 0000041C 7E60606060606000    <1> 	db	 7Eh,  60h,  60h,  60h,  60h,  60h,  60h,  00h
   285 00000424 386C6C6C6C6CFEC6    <1> 	db	 38h,  6Ch,  6Ch,  6Ch,  6Ch,  6Ch, 0FEh, 0C6h
   286 0000042C 7E60607C60607E00    <1> 	db	 7Eh,  60h,  60h,  7Ch,  60h,  60h,  7Eh,  00h
   287 00000434 DBDB7E3C7EDBDB00    <1> 	db	0DBh, 0DBh,  7Eh,  3Ch,  7Eh, 0DBh, 0DBh,  00h
   288 0000043C 3C66061C06663C00    <1> 	db	 3Ch,  66h,  06h,  1Ch,  06h,  66h,  3Ch,  00h
   289 00000444 66666E7E76666600    <1> 	db	 66h,  66h,  6Eh,  7Eh,  76h,  66h,  66h,  00h
   290 0000044C 3C666E7E76666600    <1> 	db	 3Ch,  66h,  6Eh,  7Eh,  76h,  66h,  66h,  00h
   291 00000454 666C7870786C6600    <1> 	db	 66h,  6Ch,  78h,  70h,  78h,  6Ch,  66h,  00h
   292 0000045C 1E36666666666600    <1> 	db	 1Eh,  36h,  66h,  66h,  66h,  66h,  66h,  00h
   293 00000464 C6EEFEFED6C6C600    <1> 	db	0C6h, 0EEh, 0FEh, 0FEh, 0D6h, 0C6h, 0C6h,  00h
   294 0000046C 6666667E66666600    <1> 	db	 66h,  66h,  66h,  7Eh,  66h,  66h,  66h,  00h
   295 00000474 3C66666666663C00    <1> 	db	 3Ch,  66h,  66h,  66h,  66h,  66h,  3Ch,  00h
   296 0000047C 7E66666666666600    <1> 	db	 7Eh,  66h,  66h,  66h,  66h,  66h,  66h,  00h
   297 00000484 7C6666667C606000    <1> 	db	 7Ch,  66h,  66h,  66h,  7Ch,  60h,  60h,  00h
   298 0000048C 3C66606060663C00    <1> 	db	 3Ch,  66h,  60h,  60h,  60h,  66h,  3Ch,  00h
   299 00000494 7E18181818181800    <1> 	db	 7Eh,  18h,  18h,  18h,  18h,  18h,  18h,  00h
   300 0000049C 6666663E06663C00    <1> 	db	 66h,  66h,  66h,  3Eh,  06h,  66h,  3Ch,  00h
   301 000004A4 7EDBDBDB7E181800    <1> 	db	 7Eh, 0DBh, 0DBh, 0DBh,  7Eh,  18h,  18h,  00h
   302 000004AC 66663C183C666600    <1> 	db	 66h,  66h,  3Ch,  18h,  3Ch,  66h,  66h,  00h
   303 000004B4 6666666666667F03    <1> 	db	 66h,  66h,  66h,  66h,  66h,  66h,  7Fh,  03h
   304 000004BC 6666663E06060600    <1> 	db	 66h,  66h,  66h,  3Eh,  06h,  06h,  06h,  00h
   305 000004C4 DBDBDBDBDBDBFF00    <1> 	db	0DBh, 0DBh, 0DBh, 0DBh, 0DBh, 0DBh, 0FFh,  00h
   306 000004CC DBDBDBDBDBDBFF03    <1> 	db	0DBh, 0DBh, 0DBh, 0DBh, 0DBh, 0DBh, 0FFh,  03h
   307 000004D4 E060607C66667C00    <1> 	db	0E0h,  60h,  60h,  7Ch,  66h,  66h,  7Ch,  00h
   308 000004DC C6C6C6F6DEDEF600    <1> 	db	0C6h, 0C6h, 0C6h, 0F6h, 0DEh, 0DEh, 0F6h,  00h
   309 000004E4 6060607C66667C00    <1> 	db	 60h,  60h,  60h,  7Ch,  66h,  66h,  7Ch,  00h
   310 000004EC 788C063E068C7800    <1> 	db	 78h,  8Ch,  06h,  3Eh,  06h,  8Ch,  78h,  00h
   311 000004F4 CEDBDBFBDBDBCE00    <1> 	db	0CEh, 0DBh, 0DBh, 0FBh, 0DBh, 0DBh, 0CEh,  00h
   312 000004FC 3E6666663E366600    <1> 	db	 3Eh,  66h,  66h,  66h,  3Eh,  36h,  66h,  00h
   313 00000504 0000780C7CCC7600    <1> 	db	 00h,  00h,  78h,  0Ch,  7Ch, 0CCh,  76h,  00h
   314 0000050C 003C603C66663C00    <1> 	db	 00h,  3Ch,  60h,  3Ch,  66h,  66h,  3Ch,  00h
   315 00000514 00007C667C667C00    <1> 	db	 00h,  00h,  7Ch,  66h,  7Ch,  66h,  7Ch,  00h
   316 0000051C 00007E6060606000    <1> 	db	 00h,  00h,  7Eh,  60h,  60h,  60h,  60h,  00h
   317 00000524 00003C6C6C6CFEC6    <1> 	db	 00h,  00h,  3Ch,  6Ch,  6Ch,  6Ch, 0FEh, 0C6h
   318 0000052C 00003C667E603C00    <1> 	db	 00h,  00h,  3Ch,  66h,  7Eh,  60h,  3Ch,  00h
   319 00000534 0000DB7E3C7EDB00    <1> 	db	 00h,  00h, 0DBh,  7Eh,  3Ch,  7Eh, 0DBh,  00h
   320 0000053C 00003C660C663C00    <1> 	db	 00h,  00h,  3Ch,  66h,  0Ch,  66h,  3Ch,  00h
   321 00000544 0000666E7E766600    <1> 	db	 00h,  00h,  66h,  6Eh,  7Eh,  76h,  66h,  00h
   322 0000054C 0018666E7E766600    <1> 	db	 00h,  18h,  66h,  6Eh,  7Eh,  76h,  66h,  00h
   323 00000554 0000666C786C6600    <1> 	db	 00h,  00h,  66h,  6Ch,  78h,  6Ch,  66h,  00h
   324 0000055C 00001E3666666600    <1> 	db	 00h,  00h,  1Eh,  36h,  66h,  66h,  66h,  00h
   325 00000564 0000C6FEFED6C600    <1> 	db	 00h,  00h, 0C6h, 0FEh, 0FEh, 0D6h, 0C6h,  00h
   326 0000056C 000066667E666600    <1> 	db	 00h,  00h,  66h,  66h,  7Eh,  66h,  66h,  00h
   327 00000574 00003C6666663C00    <1> 	db	 00h,  00h,  3Ch,  66h,  66h,  66h,  3Ch,  00h
   328 0000057C 00007E6666666600    <1> 	db	 00h,  00h,  7Eh,  66h,  66h,  66h,  66h,  00h
   329 00000584 1144114411441144    <1> 	db	 11h,  44h,  11h,  44h,  11h,  44h,  11h,  44h
   330 0000058C 55AA55AA55AA55AA    <1> 	db	 55h, 0AAh,  55h, 0AAh,  55h, 0AAh,  55h, 0AAh
   331 00000594 DD77DD77DD77DD77    <1> 	db	0DDh,  77h, 0DDh,  77h, 0DDh,  77h, 0DDh,  77h
   332 0000059C 1818181818181818    <1> 	db	 18h,  18h,  18h,  18h,  18h,  18h,  18h,  18h
   333 000005A4 181818F818181818    <1> 	db	 18h,  18h,  18h, 0F8h,  18h,  18h,  18h,  18h
   334 000005AC 18F818F818181818    <1> 	db	 18h, 0F8h,  18h, 0F8h,  18h,  18h,  18h,  18h
   335 000005B4 363636F636363636    <1> 	db	 36h,  36h,  36h, 0F6h,  36h,  36h,  36h,  36h
   336 000005BC 000000FE36363636    <1> 	db	 00h,  00h,  00h, 0FEh,  36h,  36h,  36h,  36h
   337 000005C4 00F818F818181818    <1> 	db	 00h, 0F8h,  18h, 0F8h,  18h,  18h,  18h,  18h
   338 000005CC 36F606F636363636    <1> 	db	 36h, 0F6h,  06h, 0F6h,  36h,  36h,  36h,  36h
   339 000005D4 3636363636363636    <1> 	db	 36h,  36h,  36h,  36h,  36h,  36h,  36h,  36h
   340 000005DC 00FE06F636363636    <1> 	db	 00h, 0FEh,  06h,  0F6h, 36h,  36h,  36h,  36h
   341 000005E4 36F606FE00000000    <1> 	db	 36h, 0F6h,  06h, 0FEh,  00h,  00h,  00h,  00h
   342 000005EC 363636FE00000000    <1> 	db	 36h,  36h,  36h, 0FEh,  00h,  00h,  00h,  00h
   343 000005F4 18F818F800000000    <1> 	db	 18h, 0F8h,  18h, 0F8h,  00h,  00h,  00h,  00h
   344 000005FC 000000F818181818    <1> 	db	 00h,  00h,  00h, 0F8h,  18h,  18h,  18h,  18h
   345 00000604 1818181F00000000    <1> 	db	 18h,  18h,  18h,  1Fh,  00h,  00h,  00h,  00h
   346 0000060C 181818FF00000000    <1> 	db	 18h,  18h,  18h, 0FFh,  00h,  00h,  00h,  00h
   347 00000614 000000FF18181818    <1> 	db	 00h,  00h,  00h, 0FFh,  18h,  18h,  18h,  18h
   348 0000061C 1818181F18181818    <1> 	db	 18h,  18h,  18h,  1Fh,  18h,  18h,  18h,  18h
   349 00000624 000000FF00000000    <1> 	db	 00h,  00h,  00h, 0FFh,  00h,  00h,  00h,  00h
   350 0000062C 181818FF18181818    <1> 	db	 18h,  18h,  18h,  0FFh, 18h,  18h,  18h,  18h
   351 00000634 181F181F18181818    <1> 	db	 18h,  1Fh,  18h,  1Fh,  18h,  18h,  18h,  18h
   352 0000063C 3636363736363636    <1> 	db	 36h,  36h,  36h,  37h,  36h,  36h,  36h,  36h
   353 00000644 3637303F00000000    <1> 	db	 36h,  37h,  30h,  3Fh,  00h,  00h,  00h,  00h
   354 0000064C 003F303736363636    <1> 	db	 00h,  3Fh,  30h,  37h,  36h,  36h,  36h,  36h
   355 00000654 36F700FF00000000    <1> 	db	 36h, 0F7h,  00h, 0FFh,  00h,  00h,  00h,  00h
   356 0000065C 00FF00F736363636    <1> 	db	 00h, 0FFh,  00h, 0F7h,  36h,  36h,  36h,  36h
   357 00000664 3637303736363636    <1> 	db	 36h,  37h,  30h,  37h,  36h,  36h,  36h,  36h
   358 0000066C 00FF00FF00000000    <1> 	db	 00h, 0FFh,  00h, 0FFh,  00h,  00h,  00h,  00h
   359 00000674 36F700F736363636    <1> 	db	 36h, 0F7h,  00h, 0F7h,  36h,  36h,  36h,  36h
   360 0000067C 18FF00FF00000000    <1> 	db	 18h, 0FFh,  00h, 0FFh,  00h,  00h,  00h,  00h
   361 00000684 363636FF00000000    <1> 	db	 36h,  36h,  36h, 0FFh,  00h,  00h,  00h,  00h
   362 0000068C 00FF00FF18181818    <1> 	db	 00h, 0FFh,  00h, 0FFh,  18h,  18h,  18h,  18h
   363 00000694 000000FF36363636    <1> 	db	 00h,  00h,  00h, 0FFh,  36h,  36h,  36h,  36h
   364 0000069C 3636363F00000000    <1> 	db	 36h,  36h,  36h,  3Fh,  00h,  00h,  00h,  00h
   365 000006A4 181F181F00000000    <1> 	db	 18h,  1Fh,  18h,  1Fh,  00h,  00h,  00h,  00h
   366 000006AC 001F181F18181818    <1> 	db	 00h,  1Fh,  18h,  1Fh,  18h,  18h,  18h,  18h
   367 000006B4 0000003F36363636    <1> 	db	 00h,  00h,  00h,  3Fh,  36h,  36h,  36h,  36h
   368 000006BC 363636FF36363636    <1> 	db	 36h,  36h,  36h, 0FFh,  36h,  36h,  36h,  36h
   369 000006C4 18FF18FF18181818    <1> 	db	 18h, 0FFh,  18h, 0FFh,  18h,  18h,  18h,  18h
   370 000006CC 181818F800000000    <1> 	db	 18h,  18h,  18h, 0F8h,  00h,  00h,  00h,  00h
   371 000006D4 0000001F18181818    <1> 	db	 00h,  00h,  00h,  1Fh,  18h,  18h,  18h,  18h
   372 000006DC FFFFFFFFFFFFFFFF    <1> 	db	0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh
   373 000006E4 000000FFFFFFFFFF    <1> 	db	 00h,  00h,  00h, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh
   374 000006EC F0F0F0F0F0F0F0F0    <1> 	db	0F0h, 0F0h, 0F0h, 0F0h, 0F0h, 0F0h, 0F0h, 0F0h
   375 000006F4 0F0F0F0F0F0F0F0F    <1> 	db	 0Fh,  0Fh,  0Fh,  0Fh,  0Fh,  0Fh,  0Fh,  0Fh
   376 000006FC FFFFFF0000000000    <1> 	db	0FFh, 0FFh, 0FFh,  00h,  00h,  00h,  00h,  00h
   377 00000704 00007C66667C6000    <1> 	db	 00h,  00h,  7Ch,  66h,  66h,  7Ch,  60h,  00h
   378 0000070C 00003C6660663C00    <1> 	db	 00h,  00h,  3Ch,  66h,  60h,  66h,  3Ch,  00h
   379 00000714 00007E1818181800    <1> 	db	 00h,  00h,  7Eh,  18h,  18h,  18h,  18h,  00h
   380 0000071C 000066663E063C00    <1> 	db	 00h,  00h,  66h,  66h,  3Eh,  06h,  3Ch,  00h
   381 00000724 00007EDBDB7E1800    <1> 	db	 00h,  00h,  7Eh, 0DBh, 0DBh,  7Eh,  18h,  00h
   382 0000072C 0000663C183C6600    <1> 	db	 00h,  00h,  66h,  3Ch,  18h,  3Ch,  66h,  00h
   383 00000734 0000666666667F03    <1> 	db	 00h,  00h,  66h,  66h,  66h,  66h,  7Fh,  03h
   384 0000073C 000066663E060600    <1> 	db	 00h,  00h,  66h,  66h,  3Eh,  06h,  06h,  00h
   385 00000744 0000DBDBDBDBFF00    <1> 	db	 00h,  00h, 0DBh, 0DBh, 0DBh, 0DBh, 0FFh,  00h
   386 0000074C 0000DBDBDBDBFF03    <1> 	db	 00h,  00h, 0DBh, 0DBh, 0DBh, 0DBh, 0FFh,  03h
   387 00000754 0000E0607C667C00    <1> 	db	 00h,  00h, 0E0h,  60h,  7Ch,  66h,  7Ch,  00h
   388 0000075C 0000C6C6F6DEF600    <1> 	db	 00h,  00h, 0C6h, 0C6h, 0F6h, 0DEh, 0F6h,  00h
   389 00000764 000060607C667C00    <1> 	db	 00h,  00h,  60h,  60h,  7Ch,  66h,  7Ch,  00h
   390 0000076C 00007C063E067C00    <1> 	db	 00h,  00h,  7Ch,  06h,  3Eh,  06h,  7Ch,  00h
   391 00000774 0000CEDBFBDBCE00    <1> 	db	 00h,  00h, 0CEh, 0DBh, 0FBh, 0DBh, 0CEh,  00h
   392 0000077C 00003E663E366600    <1> 	db	 00h,  00h,  3Eh,  66h,  3Eh,  36h,  66h,  00h
   393 00000784 66007E607C607E00    <1> 	db	 66h,  00h,  7Eh,  60h,  7Ch,  60h,  7Eh,  00h
   394 0000078C 24003C667E603C00    <1> 	db	 24h,  00h,  3Ch,  66h,  7Eh,  60h,  3Ch,  00h
   395 00000794 0030180C060C1830    <1> 	db	 00h,  30h,  18h,  0Ch,  06h,  0Ch,  18h,  30h
   396 0000079C 000C18306030180C    <1> 	db	 00h,  0Ch,  18h,  30h,  60h,  30h,  18h,  0Ch
   397 000007A4 0E1B1B1818181818    <1> 	db	 0Eh,  1Bh,  1Bh,  18h,  18h,  18h,  18h,  18h
   398 000007AC 1818181818D8D870    <1> 	db	 18h,  18h,  18h,  18h,  18h, 0D8h, 0D8h,  70h
   399 000007B4 001818007E001818    <1> 	db	 00h,  18h,  18h,  00h,  7Eh,  00h,  18h,  18h
   400 000007BC 0076DC0076DC0000    <1> 	db	 00h,  76h, 0DCh,  00h,  76h, 0DCh,  00h,  00h
   401 000007C4 00386C6C38000000    <1> 	db	 00h,  38h,  6Ch,  6Ch,  38h,  00h,  00h,  00h
   402 000007CC 0000000018000000    <1> 	db	 00h,  00h,  00h,  00h,  18h,  00h,  00h,  00h
   403 000007D4 0000003838000000    <1> 	db	 00h,  00h,  00h,  38h,  38h,  00h,  00h,  00h
   404 000007DC 03020604CC683810    <1> 	db	 03h,  02h,  06h,  04h, 0CCh,  68h,  38h,  10h
   405 000007E4 3C4299A1A199423C    <1> 	db	 3Ch,  42h,  99h, 0A1h, 0A1h,  99h,  42h,  3Ch
   406 000007EC 3048102078000000    <1> 	db	 30h,  48h,  10h,  20h,  78h,  00h,  00h,  00h
   407 000007F4 00007C7C7C7C0000    <1> 	db	 00h,  00h,  7Ch,  7Ch,  7Ch,  7Ch,  00h,  00h
   408 000007FC 0000000000427E00    <1> 	db	 00h,  00h,  00h,  00h,  00h,  42h,  7Eh,  00h
   257                                  %endif ; MACHINE_XT
   258                                  ;%include	"inttrace.inc"		; Uncomment for interrupt debugging
   259                                  %ifdef AT_RTC
   260                                  %include	"rtc.inc"		; RTC and CMOS read / write functions
   261                                  %endif ; AT_RTC
   262                                  %ifdef FLASH_NVRAM
   263                                  %include	"flash.inc"		; Flash ROM configuration functions
   264                                  %endif ; FLASH_NVRAM
   265                                  %ifdef BIOS_SETUP
   266                                  %include	"setup.inc"		; NVRAM setup functions
   267                                  %endif ; BIOS_SETUP
   268                                  %include	"delay.inc"		; delay function
   269                              <1> ;=========================================================================
   270                              <1> ; delay.inc - Delay functions
   271                              <1> ;-------------------------------------------------------------------------
   272                              <1> ;
   273                              <1> ; Compiles with NASM 2.13.02, might work with other versions
   274                              <1> ;
   275                              <1> ; Copyright (C) 2010 - 2023 Sergey Kiselev.
   276                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
   277                              <1> ;
   278                              <1> ; This program is free software: you can redistribute it and/or modify
   279                              <1> ; it under the terms of the GNU General Public License as published by
   280                              <1> ; the Free Software Foundation, either version 3 of the License, or
   281                              <1> ; (at your option) any later version.
   282                              <1> ;
   283                              <1> ; This program is distributed in the hope that it will be useful,
   284                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   285                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   286                              <1> ; GNU General Public License for more details.
   287                              <1> ;
   288                              <1> ; You should have received a copy of the GNU General Public License
   289                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   290                              <1> ;
   291                              <1> ;=========================================================================
   292                              <1> 
   293                              <1> %ifdef AT_DELAY
   294                              <1> 
   295                              <1> ;=========================================================================
   296                              <1> ; delay_15us - delay for multiplies of 15 microseconds
   297                              <1> ; Input:
   298                              <1> ;	CX = time to delay (in 15 microsecond units)
   299                              <1> ; Notes:
   300                              <1> ;	1.  Actual delay will be between (CX - 1) * 15us and CX * 15us
   301                              <1> ;	2.  This relies on the "refresh" bit of port 61h and therefore on
   302                              <1> ;	    timer channel 1. Will not function properly if timer gets
   303                              <1> ;	    reprogrammed by an application or if it was not initialized yet
   304                              <1> ;-------------------------------------------------------------------------
   305                              <1> delay_15us:
   306                              <1> 	push	ax
   307                              <1> 	push	cx
   308                              <1> .zero:
   309                              <1> 	in	al,ppi_pb_reg
   310                              <1> 	test	al,refresh_flag
   311                              <1> 	jz	.zero
   312                              <1> 	dec	cx
   313                              <1> 	jz	.exit
   314                              <1> .one:
   315                              <1> 	in	al,ppi_pb_reg
   316                              <1> 	test	al,refresh_flag
   317                              <1> 	jnz	.one
   318                              <1> 	dec	cx
   319                              <1> 	jnz	.zero
   320                              <1> .exit:
   321                              <1> 	pop	cx
   322                              <1> 	pop	ax
   323                              <1> 	ret
   324                              <1> 
   325                              <1> %else ; AT_DELAY
   326                              <1> 
   327                              <1> ;=========================================================================
   328                              <1> ; delay_15us - delay for multiplies of approximately 15 microseconds
   329                              <1> ; Input:
   330                              <1> ;	CX = time to delay (in 15 microsecond units)
   331                              <1> ; Notes:
   332                              <1> ;	This implementation does not provide precise timing
   333                              <1> ;	The actual delay depends on the CPU clock frequency
   334                              <1> ;-------------------------------------------------------------------------
   335                              <1> delay_15us:
   336 00000804 50                  <1> 	push	ax
   337 00000805 51                  <1> 	push	cx
   338                              <1> .1:
   339 00000806 B004                <1> 	mov	al,4
   340                              <1> .2:
   341 00000808 FEC8                <1> 	dec	al
   342 0000080A 75FC                <1> 	jnz	.2
   343 0000080C E2F8                <1> 	loop	.1
   344 0000080E 59                  <1> 	pop	cx
   345 0000080F 58                  <1> 	pop	ax
   346 00000810 C3                  <1> 	ret
   347                              <1> 
   348                              <1> %endif ; AT_DELAY
   349                              <1> 
   350                              <1> 
   351                              <1> %if 0
   352                              <1> ;=========================================================================
   353                              <1> ; divide_32 - divide 64-bit argument by 32-bit, return 64-bit result
   354                              <1> ; Input:
   355                              <1> ;	DX:AX	- dividend
   356                              <1> ;	CX	- divisor
   357                              <1> ; Output:
   358                              <1> ;	DX:AX	- quotient
   359                              <1> ;-------------------------------------------------------------------------
   360                              <1> divide_32:
   361                              <1> 	or	dx,dx
   362                              <1> 	jnz	.1
   363                              <1> 	div	cx
   364                              <1> 	xor	dx,dx
   365                              <1> 	ret
   366                              <1> .1:
   367                              <1> 	push	bx
   368                              <1> 	mov	bx,ax
   369                              <1> 	mov	ax,dx
   370                              <1> 	xor	dx,dx
   371                              <1> 	div	cx
   372                              <1> 	xchg	bx,ax
   373                              <1> 	div	cx
   374                              <1> 	mov	dx,bx
   375                              <1> 	pop	bx
   376                              <1> 	ret
   377                              <1> %endif ; 0
   269                                  %include	"time1.inc"		; time services
   270                              <1> ;=========================================================================
   271                              <1> ; time1.inc - BIOS Time Services
   272                              <1> ;       INT 1Ah - BIOS Time Services
   273                              <1> ;		functions AH=00h to AH=07h
   274                              <1> ;	INT 70h - IRQ8 interrupt handler (RTC alarm)
   275                              <1> ;-------------------------------------------------------------------------
   276                              <1> ;
   277                              <1> ; Compiles with NASM 2.13.02, might work with other versions
   278                              <1> ;
   279                              <1> ; Copyright (C) 2010 - 2023 Sergey Kiselev.
   280                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
   281                              <1> ;
   282                              <1> ; This program is free software: you can redistribute it and/or modify
   283                              <1> ; it under the terms of the GNU General Public License as published by
   284                              <1> ; the Free Software Foundation, either version 3 of the License, or
   285                              <1> ; (at your option) any later version.
   286                              <1> ;
   287                              <1> ; This program is distributed in the hope that it will be useful,
   288                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   289                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   290                              <1> ; GNU General Public License for more details.
   291                              <1> ;
   292                              <1> ; You should have received a copy of the GNU General Public License
   293                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   294                              <1> ;
   295                              <1> ;=========================================================================
   296                              <1> 
   297                              <1> ;=========================================================================
   298                              <1> ; int_1A_fn00 - Read current time
   299                              <1> ; Input:
   300                              <1> ;	AH = 0 - read current time
   301                              <1> ; Output:
   302                              <1> ;	CX = high word of tick count
   303                              <1> ;	DX = low word of tick count
   304                              <1> ;	AL = midnight flag: non-zero if midnight passed since time last read
   305                              <1> ;-------------------------------------------------------------------------
   306                              <1> int_1A_fn00:
   307 00000811 8B166C00            <1> 	mov	dx,word [ticks_lo]
   308 00000815 8B0E6E00            <1> 	mov	cx,word [ticks_hi]
   309 00000819 A07000              <1> 	mov	al,byte [new_day]	; read new_day to al
   310 0000081C 30067000            <1> 	xor	byte [new_day],al	; new_day = 0
   311 00000820 E96636              <1> 	jmp	int_1A_exit
   312                              <1> 
   313                              <1> ;=========================================================================
   314                              <1> ; int_1A_fn01 - Set current time and clear midnight flag
   315                              <1> ; Input:
   316                              <1> ;	AH = 01h - function 01h - set current time and clear midnight flag
   317                              <1> ;	CX = high word of tick count
   318                              <1> ;	DX = low word of tick count
   319                              <1> ; Output:
   320                              <1> ;	None
   321                              <1> ;-------------------------------------------------------------------------
   322                              <1> int_1A_fn01:
   323 00000823 89166C00            <1> 	mov	word [ticks_lo],dx
   324 00000827 890E6E00            <1> 	mov	word [ticks_hi],cx
   325 0000082B C606700000          <1> 	mov	byte [new_day],00h
   326 00000830 E95636              <1> 	jmp	int_1A_exit
   327                              <1> 
   328                              <1> %ifdef AT_RTC
   329                              <1> 
   330                              <1> ;=========================================================================
   331                              <1> ; int_1A_fn02 - Read real time clock (RTC)
   332                              <1> ; Input:
   333                              <1> ;	AH = 02h - function 02h - read RTC time
   334                              <1> ; Output:
   335                              <1> ;	CF set if RTC update is in progress and operation was not performed
   336                              <1> ;	CH = BCD hours
   337                              <1> ;	CL = BCD minutes
   338                              <1> ;	DH = BCD seconds
   339                              <1> ;	DL - daylight savings flag: 00h = standard time, 01h = daylight time
   340                              <1> ;-------------------------------------------------------------------------
   341                              <1> int_1A_fn02:
   342                              <1> %ifdef AT_RTC_AUTODETECT
   343                              <1> 	call	rtc_detect		; check that RTC is present
   344                              <1> 	jc	int_1A_exitf		; error - no RTC
   345                              <1> %endif ; AT_RTC_AUTODETECT
   346                              <1> 	push	ax
   347                              <1> 	mov	al,cmos_control_a
   348                              <1> 	call	rtc_read		; read control A register
   349                              <1> 	test	al,cmos_uip
   350                              <1> 	jz	.1			; no update in progess
   351                              <1> 	stc
   352                              <1> 	pop	ax
   353                              <1> 	jmp	int_1A_exitf
   354                              <1> .1:
   355                              <1> 	mov	al,cmos_control_b
   356                              <1> 	call	rtc_read		; read control B register
   357                              <1> 	and	al,cmos_dse		; mask the daylight savings bit
   358                              <1> 	mov	dl,al
   359                              <1> 	mov	al,cmos_seconds
   360                              <1> 	call	rtc_read		; read seconds
   361                              <1> 	mov	dh,al
   362                              <1> 	mov	al,cmos_minutes
   363                              <1> 	call	rtc_read		; read minutes
   364                              <1> 	mov	cl,al
   365                              <1> 	mov	al,cmos_hours
   366                              <1> 	call	rtc_read		; read hours
   367                              <1> 	mov	ch,al
   368                              <1> 	clc
   369                              <1> 	pop	ax
   370                              <1> 	jmp	int_1A_exitf
   371                              <1> 
   372                              <1> ;=========================================================================
   373                              <1> ; int_1A_fn03 - Set real time clock
   374                              <1> ; Input:
   375                              <1> ;	AH = 03h - function 03h - set RTC time
   376                              <1> ;	CH = BCD hours
   377                              <1> ;	CL = BCD minutes
   378                              <1> ;	DH = BCD seconds
   379                              <1> ;	DL - daylight savings flag: 00h = standard time, 01h = daylight time
   380                              <1> ; Output:
   381                              <1> ;	None
   382                              <1> ;-------------------------------------------------------------------------
   383                              <1> int_1A_fn03:
   384                              <1> %ifdef AT_RTC_AUTODETECT
   385                              <1> 	call	rtc_detect		; check that RTC is present
   386                              <1> 	jc	int_1A_exitf		; error - no RTC
   387                              <1> %endif ; AT_RTC_AUTODETECT
   388                              <1> 	push	ax
   389                              <1> 	mov	al,cmos_control_b
   390                              <1> 	call	rtc_read		; read control B register
   391                              <1> 	mov	ah,al
   392                              <1> 	or	ah,cmos_set		; set the RTC set bit
   393                              <1> 	mov	al,cmos_control_b
   394                              <1> 	call	rtc_write		; write control B register
   395                              <1> 
   396                              <1> 	and	dl,cmos_dse		; mask the daylight saving flag
   397                              <1> 	and	ah,~cmos_dse		; clear daylight saving flag for now
   398                              <1> 	or	ah,dl			; add it from the input
   399                              <1> 	mov	al,cmos_control_b
   400                              <1> 	call	rtc_write		; write control B register
   401                              <1> 
   402                              <1> 	mov	al,cmos_seconds
   403                              <1> 	mov	ah,dh
   404                              <1> 	call	rtc_write		; write seconds
   405                              <1> 	mov	al,cmos_minutes
   406                              <1> 	mov	ah,cl
   407                              <1> 	call	rtc_write		; write minutes
   408                              <1> 	mov	al,cmos_hours
   409                              <1> 	mov	ah,ch
   410                              <1> 	call	rtc_write		; write hours
   411                              <1> 
   412                              <1> 	mov	al,cmos_control_b
   413                              <1> 	call	rtc_read		; read control B register
   414                              <1> 	mov	ah,al
   415                              <1> 	and	ah,~cmos_set		; clear the RTC set bit
   416                              <1> 	mov	al,cmos_control_b
   417                              <1> 	call	rtc_write		; write control B register
   418                              <1> 	pop	ax
   419                              <1> 	jmp	int_1A_exit
   420                              <1> 
   421                              <1> ;=========================================================================
   422                              <1> ; int_1A_fn04 - Read date from real time clock
   423                              <1> ; Input:
   424                              <1> ;	AH = 04h - function 04h - read RTC date
   425                              <1> ; Output:
   426                              <1> ;	CF set if RTC update is in progress and operation was not performed
   427                              <1> ;	CH = BCD century
   428                              <1> ;	CL = BCD year
   429                              <1> ;	DH = BCD month
   430                              <1> ;	DL = BCD date
   431                              <1> ;-------------------------------------------------------------------------
   432                              <1> int_1A_fn04:
   433                              <1> %ifdef AT_RTC_AUTODETECT
   434                              <1> 	call	rtc_detect		; check that RTC is present
   435                              <1> 	jc	int_1A_exitf		; error - no RTC
   436                              <1> %endif ; AT_RTC_AUTODETECT
   437                              <1> 	push	ax
   438                              <1> 	mov	al,cmos_control_a
   439                              <1> 	call	rtc_read		; read control A register
   440                              <1> 	test	al,cmos_uip
   441                              <1> 	jz	.1			; no update in progess
   442                              <1> 	stc
   443                              <1> 	pop	ax
   444                              <1> 	jmp	int_1A_exitf
   445                              <1> .1:
   446                              <1> 	mov	al,cmos_date
   447                              <1> 	call	rtc_read		; read date
   448                              <1> 	mov	dl,al
   449                              <1> 	mov	al,cmos_month
   450                              <1> 	call	rtc_read		; read month
   451                              <1> 	mov	dh,al
   452                              <1> 	mov	al,cmos_year
   453                              <1> 	call	rtc_read		; read year
   454                              <1> 	mov	cl,al
   455                              <1> 	mov	al,cmos_century
   456                              <1> 	call	rtc_read		; read century
   457                              <1> 	mov	ch,al
   458                              <1> 	clc
   459                              <1> 	pop	ax
   460                              <1> 	jmp	int_1A_exitf
   461                              <1> 
   462                              <1> ;=========================================================================
   463                              <1> ; int_1A_fn05 - Set date in real time clock
   464                              <1> ; Input:
   465                              <1> ;	AH = 05h - function 05h - set RTC date
   466                              <1> ;	CH = BCD century
   467                              <1> ;	CL = BCD year
   468                              <1> ;	DH = BCD month
   469                              <1> ;	DL = BCD date
   470                              <1> ; Output:
   471                              <1> ;	None
   472                              <1> ;-------------------------------------------------------------------------
   473                              <1> int_1A_fn05:
   474                              <1> %ifdef AT_RTC_AUTODETECT
   475                              <1> 	call	rtc_detect		; check that RTC is present
   476                              <1> 	jc	int_1A_exitf		; error - no RTC
   477                              <1> %endif ; AT_RTC_AUTODETECT
   478                              <1> 	push	ax
   479                              <1> 	mov	al,cmos_control_b
   480                              <1> 	call	rtc_read		; read control B register
   481                              <1> 	mov	ah,al
   482                              <1> 	or	ah,cmos_set		; set the RTC set bit
   483                              <1> 	mov	al,cmos_control_b
   484                              <1> 	call	rtc_write		; write control B register
   485                              <1> 
   486                              <1> 	mov	al,cmos_date
   487                              <1> 	mov	ah,dl
   488                              <1> 	call	rtc_write		; write date
   489                              <1> 
   490                              <1> 	mov	al,cmos_month
   491                              <1> 	mov	ah,dh
   492                              <1> 	call	rtc_write		; write month
   493                              <1> 	mov	al,cmos_year
   494                              <1> 	mov	ah,cl
   495                              <1> 	call	rtc_write		; write year
   496                              <1> 	mov	al,cmos_century
   497                              <1> 	mov	ah,ch
   498                              <1> 	call	rtc_write		; write centry
   499                              <1> 
   500                              <1> 	mov	al,cmos_control_b
   501                              <1> 	call	rtc_read		; read control B register
   502                              <1> 	mov	ah,al
   503                              <1> 	and	ah,~cmos_set		; clear the RTC set bit
   504                              <1> 	mov	al,cmos_control_b
   505                              <1> 	call	rtc_write		; write control B register
   506                              <1> 	pop	ax
   507                              <1> 	jmp	int_1A_exit
   508                              <1> 
   509                              <1> ;=========================================================================
   510                              <1> ; int_1A_fn06 - Set real time clock alarm
   511                              <1> ; Input:
   512                              <1> ;	AH = 06h - function 06h - set RTC alarm time
   513                              <1> ;	CH = BCD hours
   514                              <1> ;	CL = BCD minutes
   515                              <1> ;	DH = BCD seconds
   516                              <1> ; Output:
   517                              <1> ;	CF = 1 - alarm already set
   518                              <1> ;-------------------------------------------------------------------------
   519                              <1> int_1A_fn06:
   520                              <1> %ifdef AT_RTC_AUTODETECT
   521                              <1> 	call	rtc_detect		; check that RTC is present
   522                              <1> 	jc	int_1A_exitf		; error - no RTC
   523                              <1> %endif ; AT_RTC_AUTODETECT
   524                              <1> 	push	ax
   525                              <1> 	mov	al,cmos_control_b
   526                              <1> 	call	rtc_read		; read control B register
   527                              <1> 	test	al,cmos_aie
   528                              <1> 	jz	.1			; RTC alarm interrupt is not enabled
   529                              <1> 	stc
   530                              <1> 	pop	ax
   531                              <1> 	jmp	int_1A_exitf
   532                              <1> .1:
   533                              <1> 	mov	ah,al
   534                              <1> 	or	ah,cmos_set		; set the RTC set bit
   535                              <1> 	mov	al,cmos_control_b
   536                              <1> 	call	rtc_write		; write control B register
   537                              <1> 
   538                              <1> 	mov	al,cmos_alarm_secs
   539                              <1> 	mov	ah,dh
   540                              <1> 	call	rtc_write		; write alarm seconds
   541                              <1> 	mov	al,cmos_alarm_mins
   542                              <1> 	mov	ah,cl
   543                              <1> 	call	rtc_write		; write alarm minutes
   544                              <1> 	mov	al,cmos_alarm_hrs
   545                              <1> 	mov	ah,ch
   546                              <1> 	call	rtc_write		; write alarm hours
   547                              <1> 
   548                              <1> 	mov	al,cmos_control_b
   549                              <1> 	call	rtc_read		; read control B register
   550                              <1> 	mov	ah,al
   551                              <1> 	and	ah,~cmos_set		; set the RTC set bit
   552                              <1> 	mov	al,cmos_control_b
   553                              <1> 	call	rtc_write		; write control B register
   554                              <1> 
   555                              <1> 	mov	al,cmos_control_b
   556                              <1> 	call	rtc_read		; read control B register
   557                              <1> 	mov	ah,al
   558                              <1> 	or	ah,cmos_aie		; set alarm interrupt flag
   559                              <1> 	mov	al,cmos_control_b
   560                              <1> 	call	rtc_write		; write control B register with AIE set
   561                              <1> 
   562                              <1> 	pop	ax
   563                              <1> 	clc
   564                              <1> 	jmp	int_1A_exitf
   565                              <1> 
   566                              <1> ;=========================================================================
   567                              <1> ; int_1A_fn07 - Reset real time clock alarm
   568                              <1> ; Input:
   569                              <1> ;	AH = 07h - function 07h - set RTC time
   570                              <1> ; Output:
   571                              <1> ;	None
   572                              <1> ;-------------------------------------------------------------------------
   573                              <1> int_1A_fn07:
   574                              <1> %ifdef AT_RTC_AUTODETECT
   575                              <1> 	call	rtc_detect		; check that RTC is present
   576                              <1> 	jc	int_1A_exitf		; error - no RTC
   577                              <1> %endif ; AT_RTC_AUTODETECT
   578                              <1> 	push	ax
   579                              <1> 
   580                              <1> 	mov	al,cmos_control_b
   581                              <1> 	call	rtc_read		; read control B register
   582                              <1> 	mov	ah,al
   583                              <1> 	and	ah,~cmos_aie		; clear alarm interrupt flag
   584                              <1> 	mov	al,cmos_control_b
   585                              <1> 	call	rtc_write		; write control B reg. with AIE cleared
   586                              <1> 
   587                              <1> 	pop	ax
   588                              <1> 	jmp	int_1A_exit
   589                              <1> 	
   590                              <1> %ifdef SECOND_PIC
   591                              <1> ;=========================================================================
   592                              <1> ; int_70 - RTC interrupt service routine (IRQ8)
   593                              <1> ; Notes:
   594                              <1> ;	Calls INT 4Ah if interrupt is caused by RTC alarm
   595                              <1> ;-------------------------------------------------------------------------
   596                              <1> int_70:
   597                              <1> 	push	ax
   598                              <1> 	mov	al,20h
   599                              <1> 	out	pic2_reg0,al		; signal EOI to the slave PIC
   600                              <1> 	out	pic1_reg0,al		; signal EOI to the master PIC
   601                              <1> 	mov	al,cmos_control_c
   602                              <1> 	call	rtc_read		; read control C register
   603                              <1> 	test	al,cmos_af		; check for alarm flag
   604                              <1> 	jz	.1
   605                              <1> 	int	4Ah			; call INT 4Ah
   606                              <1> .1:
   607                              <1> 	pop	ax
   608                              <1> 	iret
   609                              <1> %endif ; SECOND_PIC
   610                              <1> 
   611                              <1> %endif ; AT_RTC
   270                                  %include	"floppy1.inc"		; floppy services
   271                              <1> ;=========================================================================
   272                              <1> ; floppy1.inc - BIOS floppy disk services (part 1 of 2)
   273                              <1> ;	INT 13h, function AH=00h
   274                              <1> ;	INT 13h, function AH=01h
   275                              <1> ;	INT 13h, function AH=08h
   276                              <1> ;	INT 13h, function AH=15h
   277                              <1> ;	INT 13h, function AH=16h
   278                              <1> ;	INT 13h, function AH=17h
   279                              <1> ;	INT 13h, function AH=18h
   280                              <1> ;	INT 13h, function AH=08h
   281                              <1> ;	- see floppy2.inc for other INT 13h functions
   282                              <1> ;-------------------------------------------------------------------------
   283                              <1> ;
   284                              <1> ; Compiles with NASM 2.13.02, might work with other versions
   285                              <1> ;
   286                              <1> ; Copyright (C) 2010 - 2023 Sergey Kiselev.
   287                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
   288                              <1> ;
   289                              <1> ; This program is free software: you can redistribute it and/or modify
   290                              <1> ; it under the terms of the GNU General Public License as published by
   291                              <1> ; the Free Software Foundation, either version 3 of the License, or
   292                              <1> ; (at your option) any later version.
   293                              <1> ;
   294                              <1> ; This program is distributed in the hope that it will be useful,
   295                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   296                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   297                              <1> ; GNU General Public License for more details.
   298                              <1> ;
   299                              <1> ; You should have received a copy of the GNU General Public License
   300                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   301                              <1> ;
   302                              <1> ;=========================================================================
   303                              <1> 
   304                              <1> ;-------------------------------------------------------------------------
   305                              <1> ; FDC registers
   306                              <1> 
   307                              <1> fdc_dor_reg	equ	3F2h		; FDC digital output register (W)
   308                              <1> fdc_status_reg	equ	3F4h		; FDC main status register (R)
   309                              <1> fdc_data_reg	equ	3F5h		; FDC data register (R/W)
   310                              <1> fdc_dir_reg	equ	3F7h		; FDC digital input register (W)
   311                              <1> fdc_ccr_reg	equ	3F7h		; FDC control configuration register (R)
   312                              <1> 
   313                              <1> ; FDC status register bits
   314                              <1> fdc_stat_ready	equ	80h		; 1 = FDC is ready to send / receive
   315                              <1> fdc_stat_dir	equ	40h		; 0 = CPU -> FDC; 1 = FDC -> CPU
   316                              <1> fdc_stat_dma	equ	20h		; 1 = DMA and IRQ enabled
   317                              <1> fdc_stat_busy	equ	10h		; 1 = FDC is busy
   318                              <1> 
   319                              <1> ;-------------------------------------------------------------------------
   320                              <1> ; DMAC registers
   321                              <1> 
   322                              <1> dmac_ch0_addr_reg	equ	00h	; DMAC channel 0 base addres (W)
   323                              <1> dmac_ch0_count_reg	equ	01h	; DMAC channel 0 word count (W)
   324                              <1> dmac_ch1_addr_reg	equ	02h	; DMAC channel 1 base addres (W)
   325                              <1> dmac_ch1_count_reg	equ	03h	; DMAC channel 1 word count (W)
   326                              <1> dmac_ch2_addr_reg	equ	04h	; DMAC channel 2 base addres (W)
   327                              <1> dmac_ch2_count_reg	equ	05h	; DMAC channel 2 word count (W)
   328                              <1> dmac_mask_reg		equ	0Ah	; DMAC single mask bit register (W)
   329                              <1> dmac_mode_reg		equ	0Bh	; DMAC mode register (R/W)
   330                              <1> dmac_ff_reg		equ	0Ch	; DMAC set (R) or clear (W)
   331                              <1> 					; first / last flip-flop
   332                              <1> dmapage_ch2_reg		equ	81h	; DMA page channel 2 register
   333                              <1> 
   334                              <1> ;-------------------------------------------------------------------------
   335                              <1> ; Floppy disk services - error codes
   336                              <1> 
   337                              <1> fdc_e_success	equ	00h		; successful completion
   338                              <1> fdc_e_invalid	equ	01h		; invalid function or parameter
   339                              <1> fdc_e_address	equ	02h		; address mark not found
   340                              <1> fdc_e_wprotect	equ	03h		; disk write-protected
   341                              <1> fdc_e_notfound	equ	04h		; sector not found
   342                              <1> fdc_e_changed	equ	06h		; disk changed
   343                              <1> fdc_e_dma	equ	08h		; DMA overrun
   344                              <1> fdc_e_boundary	equ	09h		; attempted DMA across 64K boundary
   345                              <1> fdc_e_format	equ	0Ch		; not supported or drive type unknown
   346                              <1> fdc_e_crc	equ	10h		; uncorrectable CRC error on read
   347                              <1> fdc_e_failure	equ	20h		; controller failure
   348                              <1> fdc_e_seek	equ	40h		; seek failed
   349                              <1> fdc_e_timeout	equ	80h		; timeout / device not ready
   350                              <1> 
   351                              <1> ;-------------------------------------------------------------------------
   352                              <1> ; Drive media state for fdc_media_state
   353                              <1> 
   354                              <1> fdc_m_rate_bits		equ	0C0h	; bits 7-6: data transfer rate
   355                              <1> 					; 00b = 500 Kbit/sec
   356                              <1> 					; 01b = 300 Kbit/sec
   357                              <1> 					; 10b = 250 Kbit/sec
   358                              <1> 					; 11b = 1 Mbit/sec
   359                              <1> fdc_m_double_step	equ	20h	; bit 5:    1 = double stepping required
   360                              <1> fdc_m_established	equ	10h	; bit 4:    1 = media/drive established
   361                              <1> fdc_m_state_bits	equ	07h	; bits 2-0: media state bits
   362                              <1> 					; 000b = trying 360K in 360K drive
   363                              <1> 					; 001b = trying 360K in 1.2M drive
   364                              <1> 					; 010b = trying 1.2M in 1.2M drive
   365                              <1> 					; 011b = known 360K in 360K drive
   366                              <1> 					; 100b = known 360K in 1.2M drive
   367                              <1> 					; 101b = known 1.2M in 1.2M drive
   368                              <1> 					; 110b = not used
   369                              <1> 					; 111b = 720K in 720K or 1.44M in 1.44M
   370                              <1> fdc_m_360in360		equ	93h	; 250 Kbps, established, 360K in 360K
   371                              <1> fdc_m_720		equ	97h	; 250 Kbps, established, other drive
   372                              <1> fdc_m_try_360in1200	equ	61h	; 300 Kbps, not established, 360K in 1.2
   373                              <1> fdc_m_360in1200		equ	74h	; 300 Kbps, established, 360K in 1.2M
   374                              <1> fdc_m_try_1200in1200	equ	02h	; 500 Kbps, not established, 1.2M in 1.2
   375                              <1> fdc_m_1200in1200	equ	15h	; 500 Kbps, established, 1.2M in 1.2M
   376                              <1> fdc_m_try_1440		equ	07h	; 500 Kbps, not established, other drive
   377                              <1> fdc_m_1440		equ	17h	; 500 Kbps, established, other drive
   378                              <1> fdc_m_try_2880		equ	0C7h	; 1 Mbps, not established, other drive
   379                              <1> fdc_m_2880		equ	0D7h	; 1 Mbps, established, other drive
   380                              <1> 
   381                              <1> ;-------------------------------------------------------------------------
   382                              <1> ; IRQ flag - fdc_calib_state, bit 7. Set by INT 0Eh (IRQ6) interrupt handler
   383                              <1> ;	     when IRQ6 happens to indicate completion of an I/O operation
   384                              <1> 
   385                              <1> fdc_irq_flag	equ	80h		; IRQ6 had occurred
   386                              <1> 
   387                              <1> ; write flag - fdc_motor_state, bit 7. Set for write or format,
   388                              <1> ;	       unset for read or verify
   389                              <1> 
   390                              <1> fdc_write_flag	equ	80h		; write or format operation
   391                              <1> 
   392                              <1> ;-------------------------------------------------------------------------
   393                              <1> ; floppy drive type definitions
   394                              <1> 
   395                              <1> type_none	equ	00h
   396                              <1> type_360	equ	01h
   397                              <1> type_1200	equ	02h
   398                              <1> type_720	equ	03h
   399                              <1> type_1440	equ	04h
   400                              <1> type_2880	equ	06h
   401                              <1> 
   402                              <1> ;=========================================================================
   403                              <1> ; int_13_fn00: Reset disk system
   404                              <1> ; Input:
   405                              <1> ;	AH = 00h
   406                              <1> ;	DL = drive number (bit 7 not set - floppy drive)
   407                              <1> ; Output:
   408                              <1> ;	CF clear if successful
   409                              <1> ;		AH = 00h - successful completion
   410                              <1> ;	CF set on error
   411                              <1> ;		AH = 20h - controller failure
   412                              <1> ;		AH = 80h - timeout / device not ready
   413                              <1> ; Note:
   414                              <1> ;	This function doesn't check drive number, but HDD BIOS (if installed)
   415                              <1> ;	normally will call this functions if bit 7 of DL is not set
   416                              <1> ;-------------------------------------------------------------------------
   417                              <1> int_13_fn00:
   418 00000833 E80700              <1> 	call	fdc_init
   419 00000836 88264100            <1> 	mov	byte [fdc_last_error],ah  ; save the error code
   420 0000083A E9B424              <1> 	jmp	int_13_exit
   421                              <1> 
   422                              <1> ;=========================================================================
   423                              <1> ; fdc_init - Initialize floppy disk controller
   424                              <1> ; Input:
   425                              <1> ;	none
   426                              <1> ; Output:
   427                              <1> ;	CF clear on success
   428                              <1> ;		AH = 00h - successful completion
   429                              <1> ;	CF set if error
   430                              <1> ;		AH = 20h - controller failure
   431                              <1> ;		AH = 80h - timeout / device not ready
   432                              <1> ;-------------------------------------------------------------------------
   433                              <1> fdc_init:
   434 0000083D 80263E00F0          <1> 	and	byte [fdc_calib_state],0F0h ; require recalibration
   435 00000842 E8BA05              <1> 	call	fdc_reset		; reset FDC
   436 00000845 7257                <1> 	jc	fdc_init_error
   437 00000847 BAF403              <1> 	mov	dx,fdc_status_reg	; get status register address
   438 0000084A EC                  <1> 	in	al,dx
   439 0000084B A880                <1> 	test	al,80h
   440 0000084D 7404                <1> 	jz	.try_again		; try again if FDC not ready
   441 0000084F A840                <1> 	test	al,40h
   442 00000851 740F                <1> 	jz	.fdc_ready		; FDC ready to recieve data
   443                              <1> .try_again:
   444 00000853 E8A905              <1> 	call	fdc_reset
   445 00000856 BAF403              <1> 	mov	dx,fdc_status_reg	; get status register address
   446 00000859 EC                  <1> 	in	al,dx
   447 0000085A A880                <1> 	test	al,80h
   448 0000085C 7440                <1> 	jz	fdc_init_error
   449 0000085E A840                <1> 	test	al,40h
   450 00000860 753C                <1> 	jnz	fdc_init_error
   451                              <1> .fdc_ready:
   452 00000862 B008                <1> 	mov	al,08h			; FDC Sense Interrupt Status command
   453 00000864 E8D904              <1> 	call	fdc_write		; send the command
   454 00000867 7235                <1> 	jc	fdc_init_error
   455 00000869 E83105              <1> 	call	fdc_read		; read ST0
   456 0000086C 7230                <1> 	jc	fdc_init_error
   457 0000086E A24200              <1> 	mov	byte [fdc_ctrl_status],al  ; save ST0
   458 00000871 88C4                <1> 	mov	ah,al			; save AL to AH
   459 00000873 E82705              <1> 	call	fdc_read		; read current cylinder
   460 00000876 7226                <1> 	jc	fdc_init_error
   461 00000878 A24300              <1> 	mov	byte [fdc_ctrl_status+1],al  ; save
   462 0000087B 80E4C0              <1> 	and	ah,0C0h
   463 0000087E 80FCC0              <1> 	cmp	ah,0C0h			; abnormal termination?
   464 00000881 751B                <1> 	jne	fdc_init_error	; not an abnormal termination
   465                              <1> 
   466                              <1> ; fall through to fdc_send_specify
   467                              <1> 
   468                              <1> ;=========================================================================
   469                              <1> ; fdc_send_specify - Send specify command to FDC
   470                              <1> ; Input:
   471                              <1> ;	none
   472                              <1> ; Output:
   473                              <1> ;	CF clear on success
   474                              <1> ;		AH = 00 - successful completion
   475                              <1> ;	CF set if error
   476                              <1> ;		AH = 20h - controller failure
   477                              <1> ;	AX,CL,SI trashed
   478                              <1> ; Note:
   479                              <1> ;	Specify command parameters are obtained from table at INT 1Eh vector
   480                              <1> ;-------------------------------------------------------------------------
   481                              <1> fdc_send_specify:
   482 00000883 1E                  <1> 	push	ds
   483 00000884 31F6                <1> 	xor	si,si
   484 00000886 8EDE                <1> 	mov	ds,si
   485 00000888 C5367800            <1> 	lds	si,[1Eh*4]		; DS:SI -> INT 1Eh
   486 0000088C B003                <1> 	mov	al,3		 	; FDC Specify command
   487 0000088E 8A24                <1> 	mov	ah,byte [si]		; specify command - byte 0
   488 00000890 8B7401              <1> 	mov	si,word [si+1]		; specify command - byte 1
   489 00000893 B103                <1> 	mov	cl,3			; command length 3 bytes (AX, SI - low)
   490 00000895 1F                  <1> 	pop	ds
   491 00000896 E85B04              <1> 	call	fdc_send_cmd		; send specify command to FDC
   492 00000899 7203                <1> 	jc	fdc_init_error
   493 0000089B B400                <1> 	mov	ah,fdc_e_success	; successful completion
   494 0000089D C3                  <1> 	ret
   495                              <1> 
   496                              <1> fdc_init_error:
   497 0000089E B420                <1> 	mov	ah,fdc_e_failure
   498 000008A0 F9                  <1> 	stc
   499 000008A1 C3                  <1> 	ret
   500                              <1> 
   501                              <1> ;=========================================================================
   502                              <1> ; int_13_fn01 - Get status of last operation
   503                              <1> ; Input:
   504                              <1> ;	AH = 01h
   505                              <1> ;	DL = drive number (bit 7 not set - floppy drive)
   506                              <1> ; Output:
   507                              <1> ;	CF clear if last operation was successful
   508                              <1> ;		AH = 00h - successful completion
   509                              <1> ;	CF set on error
   510                              <1> ;		AH - error code of the last operation
   511                              <1> ; Note:
   512                              <1> ;	This function doesn't check drive number, but HDD BIOS (if installed)
   513                              <1> ;	normally will call this functions if bit 7 of DL is not set
   514                              <1> ;-------------------------------------------------------------------------
   515                              <1> int_13_fn01:
   516 000008A2 8A264100            <1> 	mov	ah,byte [fdc_last_error]
   517 000008A6 08E4                <1> 	or	ah,ah
   518 000008A8 7401                <1> 	jz	.no_error
   519 000008AA F9                  <1> 	stc
   520                              <1> .no_error:
   521 000008AB E94324              <1> 	jmp	int_13_exit
   522                              <1> 
   523                              <1> ;=========================================================================
   524                              <1> ; int_13_fn08: Get drive parameters
   525                              <1> ; Input:
   526                              <1> ;	AH = 08h
   527                              <1> ;	DL = drive number (0 - 7Fh)
   528                              <1> ; Output:
   529                              <1> ;	CF clear if successful
   530                              <1> ;		AX = 0000h
   531                              <1> ;		BH = 00h
   532                              <1> ;		BL = drive type
   533                              <1> ;		CH = maximal cylinder number - 1
   534                              <1> ;		CL = maximal sector number
   535                              <1> ;		DH = maximal head number
   536                              <1> ;		DL = number of drives
   537                              <1> ;		ES:DI -> diskette parameter table
   538                              <1> ;	CF set on error
   539                              <1> ;		AH = 01h - drive number is greater than 7Fh
   540                              <1> ; Notes:
   541                              <1> ;	- If non-existent drive number is specified, function returns zeros in
   542                              <1> ;	AX,BX,CX,DH,ES,DI and number of floppy drives in DL (0 if no floppies)
   543                              <1> ;	- If media type is not established function sets media parameters 
   544                              <1> ;	based on drive type
   545                              <1> ;-------------------------------------------------------------------------
   546                              <1> int_13_fn08:
   547 000008AE 80FA80              <1> 	cmp	dl,80h			; valid floppy drive number?
   548 000008B1 7203E99E00          <1> 	jae	.invalid_drive		; hard drive number specified
   549 000008B6 A01000              <1> 	mov	al,byte [equipment_list]
   550 000008B9 2441                <1> 	and	al,equip_floppies|equip_floppy2
   551 000008BB B402                <1> 	mov	ah,2			; assume two floppy drives
   552 000008BD 3C41                <1> 	cmp	al,equip_floppies|equip_floppy2 ; two floppy drives?
   553 000008BF 7406                <1> 	je	.check_drive_number
   554 000008C1 FECC                <1> 	dec	ah			; assume one floppy drive
   555 000008C3 3C01                <1> 	cmp	al,equip_floppies	; one floppy drive?
   556 000008C5 757B                <1> 	jne	.no_drives
   557                              <1> 
   558                              <1> .check_drive_number:
   559 000008C7 886608              <1> 	mov	byte [bp+int_13_dl],ah	; pass number of drives to caller
   560 000008CA 38E2                <1> 	cmp	dl,ah			; requested drive number is larger
   561                              <1> 					; than number of disks?
   562 000008CC 7378                <1> 	jnb	.non_existent_drive	; jump if non existent drive requested
   563 000008CE E8D006              <1> 	call	get_drive_type		; returns drive type in AL
   564 000008D1 7273                <1> 	jc	.non_existent_drive	; return no drive if there is an error
   565                              <1> 
   566 000008D3 C6460901            <1> 	mov	byte [bp+int_13_dh],1	; maximal head number is 1 for floppy
   567 000008D7 88460C              <1> 	mov	byte [bp+int_13_bl],al	; pass drive type to caller
   568 000008DA 8CC9                <1> 	mov	cx,cs
   569 000008DC 8EC1                <1> 	mov	es,cx			; diskette parameter table segment
   570                              <1> 
   571 000008DE 3C01                <1> 	cmp	al,type_360
   572 000008E0 7417                <1> 	je	.set_360
   573 000008E2 3C03                <1> 	cmp	al,type_720
   574 000008E4 741E                <1> 	je	.set_720
   575 000008E6 3C02                <1> 	cmp	al,type_1200
   576 000008E8 7425                <1> 	je	.set_1200
   577 000008EA 3C04                <1> 	cmp	al,type_1440
   578 000008EC 742C                <1> 	je	.set_1440
   579                              <1> 
   580                              <1> .set_2880:
   581 000008EE B0C7                <1> 	mov	al,fdc_m_try_2880	; try 2.88M in 2.88M drive
   582 000008F0 8D3E[B02F]          <1> 	lea	di,[media_2880]		; only 2.88M uses 1 Mbps rate
   583 000008F4 B9244F              <1> 	mov	cx,4F24h		; 2.88M - 80 cylinders, 36 sectors
   584 000008F7 EB2A                <1> 	jmp	.set_media_type
   585                              <1> 
   586                              <1> .set_360:
   587 000008F9 B093                <1> 	mov	al,fdc_m_360in360
   588 000008FB 8D3E[6F2F]          <1> 	lea	di,[media_360_in_360]
   589 000008FF B90927              <1> 	mov	cx,2709h		; 360K - 40 cylinders, 9 sectors
   590 00000902 EB1F                <1> 	jmp	.set_media_type
   591                              <1> 
   592                              <1> .set_720:
   593 00000904 B097                <1> 	mov	al,fdc_m_720
   594 00000906 8D3E[892F]          <1> 	lea	di,[media_720]
   595 0000090A B9094F              <1> 	mov	cx,4F09h		; 720K - 80 cylinders, 9 sectors
   596 0000090D EB14                <1> 	jmp	.set_media_type
   597                              <1> 
   598                              <1> .set_1200:
   599 0000090F B002                <1> 	mov	al,fdc_m_try_1200in1200
   600 00000911 8D3E[7C2F]          <1> 	lea	di,[media_1200]
   601 00000915 B90F4F              <1> 	mov	cx,4F0Fh		; 1.2M - 80 cylinders, 15 sectors
   602 00000918 EB09                <1> 	jmp	.set_media_type
   603                              <1> 
   604                              <1> .set_1440:
   605 0000091A B007                <1> 	mov	al,fdc_m_try_1440
   606 0000091C 8D3E[962F]          <1> 	lea	di,[media_1440]
   607 00000920 B9124F              <1> 	mov	cx,4F12h		; 1.44M - 80 cylinders, 18 sectors
   608                              <1> 
   609                              <1> .set_media_type:
   610 00000923 E81C06              <1> 	call	get_media_state
   611 00000926 F6C310              <1> 	test	bl,fdc_m_established	; media type established?
   612 00000929 7503                <1> 	jnz	.set_parameters		; no need to update if established
   613 0000092B E81E06              <1> 	call	set_media_state
   614                              <1> 
   615                              <1> .set_parameters:
   616 0000092E 31C0                <1> 	xor	ax,ax			; AH = 00h - successful completion
   617 00000930 88460E              <1> 	mov	byte [bp+int_13_al],al	; successful completion
   618 00000933 A24100              <1> 	mov	byte [fdc_last_error],al
   619 00000936 88460D              <1> 	mov	byte [bp+int_13_bh],al	; clear BH just in case
   620 00000939 894E0A              <1> 	mov	word [bp+int_13_cx],cx	; cylinders / sectors
   621 0000093C 897E04              <1> 	mov	word [bp+int_13_di],di	; diskette parameter table pointer
   622 0000093F E9AF23              <1> 	jmp	int_13_exit
   623                              <1> 
   624                              <1> .no_drives:
   625 00000942 C6460800            <1> 	mov	byte [bp+int_13_dl],0	; zero drives
   626                              <1> 
   627                              <1> .non_existent_drive:
   628 00000946 31C9                <1> 	xor	cx,cx
   629 00000948 31FF                <1> 	xor	di,di
   630 0000094A 884E0C              <1> 	mov	byte [bp+int_13_bl],cl	; drive type is zero
   631 0000094D 884E09              <1> 	mov	byte [bp+int_13_dh],cl	; maximal head number is zero
   632 00000950 8EC1                <1> 	mov	es,cx			; disk parameter table segment = 0000h
   633 00000952 EBDA                <1> 	jmp	.set_parameters
   634                              <1> 
   635                              <1> .invalid_drive:
   636 00000954 B401                <1> 	mov	ah,fdc_e_invalid
   637 00000956 F9                  <1> 	stc
   638 00000957 E99723              <1> 	jmp	int_13_exit
   639                              <1> 
   640                              <1> ;=========================================================================
   641                              <1> ; int_13_fn15: Get disk type
   642                              <1> ; Input:
   643                              <1> ;	AH = 15h
   644                              <1> ;	DL = drive number (0 or 1)
   645                              <1> ; Output:
   646                              <1> ;	AH = type code:
   647                              <1> ;		00h - no such drive (invalid drive specified)
   648                              <1> ;		01h - floppy without change-line support
   649                              <1> ;		02h - floppy with change-line support
   650                              <1> ;-------------------------------------------------------------------------
   651                              <1> int_13_fn15:
   652 0000095A B400                <1> 	mov	ah,00h			; assume no drive
   653 0000095C 3C00                <1> 	cmp	al,type_none
   654 0000095E 740C                <1> 	je	.exit
   655 00000960 B401                <1> 	mov	ah,01h			; assume no change-line support
   656 00000962 3C01                <1> 	cmp	al,type_360
   657 00000964 7406                <1> 	je	.exit
   658 00000966 3C03                <1> 	cmp	al,type_720		; no change-line support on 720K drives?
   659 00000968 7402                <1> 	je	.exit
   660 0000096A B402                <1> 	mov	ah,02h			; otherwise it supports change-line
   661                              <1> 
   662                              <1> .exit:
   663 0000096C F8                  <1> 	clc
   664 0000096D C606410000          <1> 	mov	byte [fdc_last_error],0
   665 00000972 E97C23              <1> 	jmp	int_13_exit
   666                              <1> 
   667                              <1> ;=========================================================================
   668                              <1> ; int_13_fn16 - Detect disk change
   669                              <1> ; Input:
   670                              <1> ;	AH = 16h
   671                              <1> ;	DL = drive number (0 or 1)
   672                              <1> ; Output:
   673                              <1> ;	CF clear if change line inactive
   674                              <1> ;		AH = 00h - disk not changed
   675                              <1> ;	CF set if change line active or error
   676                              <1> ;		AH = 01h - invalid drive number
   677                              <1> ;		AH = 06h - disk changed or change line not supported
   678                              <1> ;		AH = 80h - timeout / device not ready
   679                              <1> ;-------------------------------------------------------------------------
   680                              <1> int_13_fn16:
   681 00000975 3C01                <1> 	cmp	al,type_360
   682 00000977 742E                <1> 	je	.no_change_line		; report disk changed for 360K drives
   683 00000979 3C03                <1> 	cmp	al,type_720
   684 0000097B 742A                <1> 	je	.no_change_line		; report disk changed for 720K drives
   685                              <1> 
   686 0000097D E81602              <1> 	call	fdc_motor_on		; turn motor on
   687 00000980 30E4                <1> 	xor	ah,ah			; assume disk not changed
   688 00000982 BAF703              <1> 	mov	dx,fdc_dir_reg		; get digital input register address
   689 00000985 EC                  <1> 	in	al,dx			; read disk change line
   690 00000986 D0E0                <1> 	shl	al,1			; bit 7 to CF
   691 00000988 7303                <1> 	jnc	.exit
   692 0000098A B406                <1> 	mov	ah,fdc_e_changed
   693 0000098C F9                  <1> 	stc
   694                              <1> 
   695                              <1> .exit:
   696 0000098D 88264100            <1> 	mov	byte [fdc_last_error],ah  ; save the error code
   697 00000991 9C                  <1> 	pushf
   698 00000992 1E                  <1> 	push	ds
   699 00000993 31F6                <1> 	xor	si,si
   700 00000995 8EDE                <1> 	mov	ds,si
   701 00000997 C5367800            <1> 	lds	si,[1Eh*4]		; DS:SI -> INT 1Eh
   702 0000099B 8A4C02              <1> 	mov	cl,byte [si+2]
   703 0000099E 1F                  <1> 	pop	ds
   704 0000099F 880E4000            <1> 	mov	byte [fdc_motor_tout],cl ; ticks before turning off the motor
   705 000009A3 9D                  <1> 	popf
   706 000009A4 E94A23              <1> 	jmp	int_13_exit
   707                              <1> 
   708                              <1> .no_change_line:
   709 000009A7 B406                <1> 	mov	ah,fdc_e_changed	; can't detect - report disk changed
   710 000009A9 F9                  <1> 	stc
   711 000009AA 88264100            <1> 	mov	byte [fdc_last_error],ah
   712 000009AE E94023              <1> 	jmp	int_13_exit
   713                              <1> 
   714                              <1> .invalid_drive:
   715 000009B1 B401                <1> 	mov	ah,fdc_e_invalid
   716 000009B3 F9                  <1> 	stc
   717 000009B4 E93A23              <1> 	jmp	int_13_exit
   718                              <1> 
   719                              <1> ;=========================================================================
   720                              <1> ; int_13_fn17 - Set disk type for format
   721                              <1> ; Input:
   722                              <1> ;	AH = 17h
   723                              <1> ;	AL = format type
   724                              <1> ;		01h - 320K / 360K disk in 360K drive
   725                              <1> ;		02h - 320K / 360K disk in 1.2M drive
   726                              <1> ;		03h - 1.2M disk in 1.2M drive
   727                              <1> ;		04h - 720K disk in 720K or 1.2M drive
   728                              <1> ;	DL = drive number (0 or 1)
   729                              <1> ; Output:
   730                              <1> ;	CF clear if successful
   731                              <1> ;		AH = 00h - successful completion
   732                              <1> ;	CF set on error
   733                              <1> ;		AH = 01h - invalid drive number
   734                              <1> ;		AH = 06h - disk changed
   735                              <1> ;		AH = 80h - timeout / device not ready
   736                              <1> ;-------------------------------------------------------------------------
   737                              <1> int_13_fn17:
   738 000009B7 8A4E0E              <1> 	mov	cl,byte [bp+int_13_al]	; get original AL value to CL
   739 000009BA 80F900              <1> 	cmp	cl,0			; validate parameters
   740 000009BD 744F                <1> 	je	.invalid_parameters
   741 000009BF 80F904              <1> 	cmp	cl,4
   742 000009C2 774A                <1> 	ja	.invalid_parameters
   743 000009C4 80F901              <1> 	cmp	cl,1			; 360K disk in 360K drive?
   744 000009C7 7506                <1> 	jne	.not_360in360
   745 000009C9 B400                <1> 	mov	ah,0			; no error
   746 000009CB B093                <1> 	mov	al,fdc_m_360in360	; 360K disk in 360K drive
   747 000009CD EB30                <1> 	jmp	.exit_check_error
   748                              <1> 
   749                              <1> .not_360in360:
   750 000009CF E8C401              <1> 	call	fdc_motor_on
   751 000009D2 E86602              <1> 	call	fdc_disk_change		; check if disk has been changed
   752 000009D5 80FC06              <1> 	cmp	ah,fdc_e_changed
   753 000009D8 7611                <1> 	jbe	.set_type		; disk changed (no errors other than
   754                              <1> 					; "disk changed" from fdc_disk_change)
   755 000009DA 80FC80              <1> 	cmp	ah,fdc_e_timeout
   756 000009DD 750C                <1> 	jne	.set_type		; floppy disk is installed
   757 000009DF E86005              <1> 	call	get_media_state		; BL = media state
   758 000009E2 80FB97              <1> 	cmp	bl,fdc_m_720		; 250 Kbps and not 5.25?
   759 000009E5 7418                <1> 	je	.exit_check_error
   760 000009E7 B061                <1> 	mov	al,fdc_m_try_360in1200	; 300 Kpbs, try 360 in 1.2M
   761 000009E9 EB14                <1> 	jmp	.exit_check_error
   762                              <1> 
   763                              <1> .set_type:
   764 000009EB 80F904              <1> 	cmp	cl,4			; 720K in 720K?
   765 000009EE 7504                <1> 	jne	.check_360in1200	; jump if not 720K in 720K
   766 000009F0 B097                <1> 	mov	al,fdc_m_720
   767 000009F2 EB0B                <1> 	jmp	.exit_check_error
   768                              <1> 
   769                              <1> .check_360in1200:
   770 000009F4 80F902              <1> 	cmp	cl,2			; 360K in 1.2M?
   771 000009F7 7504                <1> 	jne	.set_1200in1200		; jump if not 360K in 1.2M
   772 000009F9 B074                <1> 	mov	al,fdc_m_360in1200
   773 000009FB EB02                <1> 	jmp	.exit_check_error
   774                              <1> 
   775                              <1> .set_1200in1200:
   776 000009FD B015                <1> 	mov	al,fdc_m_1200in1200	; 1.2M in 1.2M
   777                              <1> 
   778                              <1> .exit_check_error:
   779 000009FF E84A05              <1> 	call	set_media_state		; set media state to value in AL
   780 00000A02 88264100            <1> 	mov	byte [fdc_last_error],ah
   781 00000A06 08E4                <1> 	or	ah,ah
   782 00000A08 7401                <1> 	jz	.exit			; jump if no error
   783 00000A0A F9                  <1> 	stc				; indicate error
   784                              <1> 
   785                              <1> .exit:
   786 00000A0B E9C422              <1> 	jmp	int_13_upd_exit
   787                              <1> 
   788                              <1> .invalid_parameters:
   789 00000A0E B401                <1> 	mov	ah,fdc_e_invalid
   790 00000A10 EBF9                <1> 	jmp	.exit
   791                              <1> 
   792                              <1> ;=========================================================================
   793                              <1> ; int_13_fn18 - Set media type for format
   794                              <1> ; Input:
   795                              <1> ;	AH = 18h
   796                              <1> ;	DL = drive number (0 or 1)
   797                              <1> ;	CH = number of cylinders - 1
   798                              <1> ;	CL = sectors per track
   799                              <1> ; Output:
   800                              <1> ;	CF = clear if successful
   801                              <1> ;		AH = 00h - requested format is supported
   802                              <1> ;		ES:DI -> diskette parameter table
   803                              <1> ;	CF = set on error
   804                              <1> ;		AH = 01h - invalid drive number specified
   805                              <1> ;		AH = 0Ch - format is not supported or drive type is unknown
   806                              <1> ;-------------------------------------------------------------------------
   807                              <1> int_13_fn18:
   808 00000A12 3C01                <1> 	cmp	al,type_360		; 360K drive?
   809 00000A14 750E                <1> 	jne	.try_drive_1200
   810 00000A16 81F90927            <1> 	cmp	cx,2709h	 	; 40 tracks 9 sectors?
   811 00000A1A 7573                <1> 	jnz	.unsupported_format
   812 00000A1C B093                <1> 	mov	al,fdc_m_360in360	; 360K in 360K established, 250 Kbps
   813 00000A1E 8D3E[6F2F]          <1> 	lea	di,[media_360_in_360]
   814 00000A22 EB54                <1> 	jmp	.set_media
   815                              <1> 
   816                              <1> .try_drive_1200:
   817 00000A24 3C02                <1> 	cmp	al,type_1200		; 1.2M drive?
   818 00000A26 751C                <1> 	jne	.try_drive_2880
   819 00000A28 81F90F4F            <1> 	cmp	cx,4F0Fh		; 80 tracks 15 sectors?
   820 00000A2C 7508                <1> 	jne	.try_media_360_in_1200
   821 00000A2E B015                <1> 	mov	al,fdc_m_1200in1200	; 1.2M in 1.2M established, 500Kbps
   822 00000A30 8D3E[7C2F]          <1> 	lea	di,[media_1200]		; 1.2M
   823 00000A34 EB42                <1> 	jmp	.set_media
   824                              <1> 
   825                              <1> .try_media_360_in_1200:
   826 00000A36 81F90927            <1> 	cmp	cx,2709h		; 80 tracks 9 sectors?
   827 00000A3A 7553                <1> 	jne	.unsupported_format
   828 00000A3C B074                <1> 	mov	al,fdc_m_360in1200	; 360K in 1.2M established, 300Kbps
   829 00000A3E 8D3E[A32F]          <1> 	lea	di,[media_360_in_1200]	; 360K in 1.2M
   830 00000A42 EB34                <1> 	jmp	.set_media
   831                              <1> 
   832                              <1> .try_drive_2880:
   833 00000A44 3C06                <1> 	cmp	al,type_2880		; 2.88M drive?
   834 00000A46 750E                <1> 	jne	.try_drive_1440
   835 00000A48 81F9244F            <1> 	cmp	cx,4F24h		; 80 tracks 36 sectors?
   836 00000A4C 750C                <1> 	jne	.try_media_1440
   837 00000A4E B0D7                <1> 	mov	al,fdc_m_2880		; indicate 2.88M
   838 00000A50 8D3E[B02F]          <1> 	lea	di,[media_2880]
   839 00000A54 EB22                <1> 	jmp	.set_media
   840                              <1> 
   841                              <1> .try_drive_1440:
   842 00000A56 3C04                <1> 	cmp	al,type_1440		; 1.44M drive?
   843 00000A58 750E                <1> 	jne	.try_drive_720
   844                              <1> 
   845                              <1> .try_media_1440:
   846 00000A5A 81F9124F            <1> 	cmp	cx,4F12h		; 80 tracks 18 sectors?
   847 00000A5E 750C                <1> 	jne	.try_media_720
   848 00000A60 B017                <1> 	mov	al,fdc_m_1440		; indicate 1.44M
   849 00000A62 8D3E[962F]          <1> 	lea	di,[media_1440]
   850 00000A66 EB10                <1> 	jmp	.set_media
   851                              <1> 
   852                              <1> .try_drive_720:
   853 00000A68 3C03                <1> 	cmp	al,type_720		; 720K drive?
   854 00000A6A 7523                <1> 	jne	.unsupported_format	; should never happen...
   855                              <1> 
   856                              <1> .try_media_720:	
   857 00000A6C 81F9094F            <1> 	cmp	cx,4F09h		; 80 tracks 9 sectors?
   858 00000A70 751D                <1> 	jne	.unsupported_format
   859 00000A72 B097                <1> 	mov	al,fdc_m_720		; other established, 250Kbps
   860 00000A74 8D3E[892F]          <1> 	lea	di,[media_720]		; 720K
   861                              <1> 
   862                              <1> .set_media:
   863 00000A78 E8D104              <1> 	call	set_media_state		; set drive media state (in AL)
   864 00000A7B E87404              <1> 	call	fdc_set_rate		; transfer rate in AL (bits 7-6)
   865 00000A7E 897E04              <1> 	mov	word [bp+int_13_di],di	; return parameters table - offset
   866 00000A81 8CC9                <1> 	mov	cx,cs
   867 00000A83 8EC1                <1> 	mov	es,cx			; return parameters table - segment
   868 00000A85 C606410000          <1> 	mov	byte [fdc_last_error],0	; no errors
   869 00000A8A 30E4                <1> 	xor	ah,ah
   870 00000A8C E94322              <1> 	jmp	int_13_upd_exit
   871                              <1> 
   872                              <1> .unsupported_format:
   873 00000A8F B40C                <1> 	mov	ah,fdc_e_format		; not supported or drive type unknown
   874 00000A91 F9                  <1> 	stc
   875 00000A92 E93D22              <1> 	jmp	int_13_upd_exit
   876                              <1> 
   877                              <1> ;=========================================================================
   878                              <1> ; fdc_recalibrate - Recalibrate disk drive, seek to cylinder 0
   879                              <1> ; Input:
   880                              <1> ;	[BP+int_13_dl] = drive number (0 or 1)
   881                              <1> ; Output:
   882                              <1> ;	CF clear if successful
   883                              <1> ;		AH = 00h - successful completion
   884                              <1> ;	CF set on error
   885                              <1> ;		AH = 20h - controller failure
   886                              <1> ;		AH = 20h - timeout
   887                              <1> ;	AH trashed
   888                              <1> ;-------------------------------------------------------------------------
   889                              <1> fdc_recalibrate:
   890 00000A95 56                  <1> 	push	si
   891 00000A96 51                  <1> 	push	cx
   892 00000A97 52                  <1> 	push	dx
   893 00000A98 B007                <1> 	mov	al,07h			; FDC Recalibrate command
   894 00000A9A 8A6608              <1> 	mov	ah,byte [bp+int_13_dl]	; drive number - 2nd byte of command
   895 00000A9D B102                <1> 	mov	cl,2			; 2 bytes command
   896 00000A9F 80263E007F          <1> 	and	byte [fdc_calib_state],~fdc_irq_flag ; clear IRQ flag
   897 00000AA4 E84D02              <1> 	call	fdc_send_cmd
   898 00000AA7 7236                <1> 	jc	recal_end		; failure
   899 00000AA9 E85F04              <1> 	call	fdc_wait_irq		; wait for IRQ
   900 00000AAC 7231                <1> 	jc	recal_end		; timeout waiting for interrupt
   901 00000AAE B008                <1> 	mov	al,08h			; FDC Sense Interrupt Status command
   902 00000AB0 B101                <1> 	mov	cl,1			; 1 byte command
   903 00000AB2 E83F02              <1> 	call	fdc_send_cmd
   904 00000AB5 7228                <1> 	jc	recal_end		; failure
   905 00000AB7 B90200              <1> 	mov	cx,2			; 2 bytes result
   906 00000ABA E8A902              <1> 	call	fdc_get_result		; store result
   907 00000ABD 7220                <1> 	jc	recal_end		; failure
   908 00000ABF BB4200              <1> 	mov	bx,fdc_ctrl_status
   909 00000AC2 B440                <1> 	mov	ah,fdc_e_seek
   910 00000AC4 8A17                <1> 	mov	dl,byte [bx]			; ST0
   911 00000AC6 80E260              <1> 	and	dl,60h
   912 00000AC9 80FA60              <1> 	cmp	dl,60h			; abnormal termination + seek end
   913 00000ACC F9                  <1> 	stc				; indicate error
   914 00000ACD 7410                <1> 	je	recal_end		; failure
   915                              <1> 
   916 00000ACF B500                <1> 	mov	ch,0
   917 00000AD1 E89004              <1> 	call	set_cylinder		; set current cylinder to 0
   918 00000AD4 E8A704              <1> 	call	set_drive_calibrated	; set drive calibrated in data area
   919 00000AD7 B94300              <1> 	mov	cx,43h
   920 00000ADA E827FD              <1> 	call	delay_15us		; 1 ms delay
   921 00000ADD 30E4                <1> 	xor	ah,ah			; AH = 0, CF = 0 - no error
   922                              <1> 
   923                              <1> recal_end:
   924 00000ADF 88264100            <1> 	mov	byte [fdc_last_error],ah
   925 00000AE3 5A                  <1> 	pop	dx
   926 00000AE4 59                  <1> 	pop	cx
   927 00000AE5 5E                  <1> 	pop	si
   928 00000AE6 C3                  <1> 	ret
   929                              <1> 
   930                              <1> ;=========================================================================
   931                              <1> ; fdc_seek - Move floppy drive head to the specified cylinder
   932                              <1> ; Input:
   933                              <1> ;	DL = drive number
   934                              <1> ;	DH = head number
   935                              <1> ;	CH = cylinder
   936                              <1> ; Output:
   937                              <1> ;	CF clear if successful
   938                              <1> ;		AH = 00h - successful completion
   939                              <1> ;	CF set on error
   940                              <1> ;		AH = 20h - controller failure
   941                              <1> ;		AH = 40h - seek failed
   942                              <1> ;		AH = 80h - timeout / device not ready
   943                              <1> ;-------------------------------------------------------------------------
   944                              <1> fdc_seek:
   945 00000AE7 53                  <1> 	push	bx
   946 00000AE8 51                  <1> 	push	cx
   947 00000AE9 52                  <1> 	push	dx
   948 00000AEA E88304              <1> 	call	check_drive_calibrated
   949 00000AED 720A                <1> 	jc	.skip_recalibrate	; jump if drive is already calibrated
   950 00000AEF E8A3FF              <1> 	call	fdc_recalibrate
   951 00000AF2 7305                <1> 	jnc	.skip_recalibrate	; jump if calibration successful
   952 00000AF4 E89EFF              <1> 	call	fdc_recalibrate		; try recalibrating again
   953 00000AF7 727B                <1> 	jc	.exit			; no luck...
   954                              <1> 
   955                              <1> .skip_recalibrate:
   956 00000AF9 E84604              <1> 	call	get_media_state		; BL = media state
   957 00000AFC F6C320              <1> 	test	bl,fdc_m_double_step 	; check double stepping bit
   958 00000AFF 7402                <1> 	jz	.no_double_stepping
   959 00000B01 D0E5                <1> 	shl	ch,1			; CH = CH * 2 (double cylinder number)
   960                              <1> 
   961                              <1> .no_double_stepping:
   962 00000B03 E85204              <1> 	call	check_cylinder		; already at the right cylinder?
   963 00000B06 750B                <1> 	jnz	.do_seek		; jump if seek is required
   964 00000B08 803E410040          <1> 	cmp	byte [fdc_last_error],fdc_e_seek
   965 00000B0D 7404                <1> 	je	.do_seek		; jump if it was a seek error
   966 00000B0F 30E4                <1> 	xor	ah,ah			; AH = 0, CF = 0 - success
   967 00000B11 EB61                <1> 	jmp	.exit
   968                              <1> 
   969                              <1> .do_seek:
   970 00000B13 88E8                <1> 	mov	al,ch			; cylinder
   971 00000B15 89C6                <1> 	mov	si,ax			; SI - low = cylinder number
   972 00000B17 B00F                <1> 	mov	al,0Fh			; FDC Seek command
   973 00000B19 88F4                <1> 	mov	ah,dh			; head
   974 00000B1B D0E4                <1> 	shl	ah,1			; move head to bit 2
   975 00000B1D D0E4                <1> 	shl	ah,1
   976 00000B1F 0A6608              <1> 	or	ah,byte [bp+int_13_dl]	; seek - byte 1 (head / drive)
   977 00000B22 B103                <1> 	mov	cl,3			; 3 bytes command
   978 00000B24 80263E007F          <1> 	and	byte [fdc_calib_state],~fdc_irq_flag ; clear IRQ flag
   979 00000B29 E8C801              <1> 	call	fdc_send_cmd
   980 00000B2C 7242                <1> 	jc	.set_result		; seek error
   981 00000B2E E8DA03              <1> 	call	fdc_wait_irq		; wait for IRQ
   982 00000B31 723D                <1> 	jc	.set_result		; timeout waiting for interrupt
   983                              <1> 
   984 00000B33 B008                <1> 	mov	al,08h			; FDC Sense Interrupt Status command
   985 00000B35 B101                <1> 	mov	cl,1			; 1 byte command
   986 00000B37 E8BA01              <1> 	call	fdc_send_cmd
   987 00000B3A 7234                <1> 	jc	.set_result		; failure
   988 00000B3C B102                <1> 	mov	cl,2
   989 00000B3E 53                  <1> 	push	bx
   990 00000B3F E82402              <1> 	call	fdc_get_result		; read result bytes
   991 00000B42 5B                  <1> 	pop	bx
   992 00000B43 722B                <1> 	jc	.set_result		; error
   993 00000B45 B440                <1> 	mov	ah,fdc_e_seek
   994 00000B47 A04200              <1> 	mov	al,byte [fdc_ctrl_status] ; ST0
   995 00000B4A 2460                <1> 	and	al,60h
   996 00000B4C 3C60                <1> 	cmp	al,60h			; abnormal termination + seek end
   997 00000B4E F9                  <1> 	stc
   998 00000B4F 741F                <1> 	je	.set_result		; seek error
   999 00000B51 E81004              <1> 	call	set_cylinder		; save new cylinder number
  1000                              <1> 
  1001 00000B54 1E                  <1> 	push	ds
  1002 00000B55 31F6                <1> 	xor	si,si
  1003 00000B57 8EDE                <1> 	mov	ds,si
  1004 00000B59 C5367800            <1> 	lds	si,[1Eh*4]		; DS:SI -> INT 1Eh
  1005 00000B5D 8A4409              <1> 	mov	al,byte [si+9]		; AL = head settle time in ms
  1006 00000B60 1F                  <1> 	pop	ds
  1007                              <1> 
  1008 00000B61 08C0                <1> 	or	al,al			; head settle time is zero?!
  1009 00000B63 7413                <1> 	jz	.get_settle_time
  1010                              <1> 
  1011 00000B65 B143                <1> 	mov	cl,67			; 15 us * 67 ~= 1 ms
  1012 00000B67 F6E1                <1> 	mul	cl			; AX = delay in 15 us intervals
  1013 00000B69 89C1                <1> 	mov	cx,ax
  1014                              <1> 
  1015                              <1> .wait:
  1016 00000B6B E896FC              <1> 	call	delay_15us
  1017                              <1> 
  1018                              <1> .wait_end:
  1019 00000B6E 30E4                <1> 	xor	ah,ah			; AH = 0, CF = 0 - no error
  1020                              <1> 
  1021                              <1> .set_result:
  1022 00000B70 88264100            <1> 	mov	byte [fdc_last_error],ah
  1023                              <1> 
  1024                              <1> .exit:
  1025 00000B74 5A                  <1> 	pop	dx
  1026 00000B75 59                  <1> 	pop	cx
  1027 00000B76 5B                  <1> 	pop	bx
  1028 00000B77 C3                  <1> 	ret
  1029                              <1> 
  1030                              <1> .get_settle_time:
  1031 00000B78 F6063F0080          <1> 	test	byte [fdc_motor_state],fdc_write_flag ; test the write bit
  1032 00000B7D 74EF                <1> 	jz	.wait_end		; jump if read / verify - no wait
  1033                              <1> 
  1034 00000B7F E8C003              <1> 	call	get_media_state	
  1035 00000B82 88DC                <1> 	mov	ah,bl			; AH = media state
  1036 00000B84 80E407              <1> 	and	ah,fdc_m_state_bits	; leave only drive media state bits
  1037 00000B87 B92D05              <1> 	mov	cx,1325			; 20 ms delay for 360K drives
  1038 00000B8A 74DF                <1> 	jz	.wait			; jump if 360K, media not established
  1039 00000B8C 80FC03              <1> 	cmp	ah,fdc_m_360in360 & fdc_m_state_bits
  1040 00000B8F 74DA                <1> 	je	.wait			; jump if 360K, media established
  1041 00000B91 B9E303              <1> 	mov	cx,995			; 15 ms delay for other drives
  1042 00000B94 EBD5                <1> 	jmp	.wait
  1043                              <1> 
  1044                              <1> ;=========================================================================
  1045                              <1> ; fdc_motor_on - Turn motor on (if it is not on yet)
  1046                              <1> ; Input:
  1047                              <1> ;	DL = drive number (0 or 1) -- FIXME: Does it receive DL?
  1048                              <1> ; Output:
  1049                              <1> ;	none
  1050                              <1> ;-------------------------------------------------------------------------
  1051                              <1> fdc_motor_on:
  1052 00000B96 50                  <1> 	push	ax
  1053 00000B97 51                  <1> 	push	cx
  1054 00000B98 52                  <1> 	push	dx
  1055 00000B99 FA                  <1> 	cli				; entering critical section
  1056 00000B9A C6064000FF          <1> 	mov	byte [fdc_motor_tout],0FFh  ; set timeout to maximum
  1057 00000B9F 8A5608              <1> 	mov	dl,byte [bp+int_13_dl]	; DL = drive number
  1058 00000BA2 88D1                <1> 	mov	cl,dl			; CL = drive number
  1059 00000BA4 FEC1                <1> 	inc	cl			; CL = drive number + 1
  1060 00000BA6 A03F00              <1> 	mov	al,byte [fdc_motor_state] ; AL = motor state byte
  1061 00000BA9 88C6                <1> 	mov	dh,al			; keep a copy in motor state in DH
  1062 00000BAB 24CF                <1> 	and	al,0CFh			; clear drive select bits (5-4)
  1063                              <1> 
  1064 00000BAD D0E2                <1> 	shl	dl,1			; shift drive number to bits (5-4)
  1065 00000BAF D0E2                <1> 	shl	dl,1
  1066 00000BB1 D0E2                <1> 	shl	dl,1
  1067 00000BB3 D0E2                <1> 	shl	dl,1
  1068 00000BB5 08D0                <1> 	or	al,dl			; select drive
  1069 00000BB7 D2EE                <1> 	shr	dh,cl			; set CF if motor for is on
  1070 00000BB9 724A                <1> 	jc	.already_on
  1071 00000BBB B201                <1> 	mov	dl,1
  1072 00000BBD FEC9                <1> 	dec	cl
  1073 00000BBF D2E2                <1> 	shl	dl,cl
  1074 00000BC1 08D0                <1> 	or	al,dl			; indicate that motor is on
  1075 00000BC3 A23F00              <1> 	mov	byte [fdc_motor_state],al ; update motor state in data area
  1076 00000BC6 FB                  <1> 	sti
  1077 00000BC7 0C40                <1> 	or	al,40h			; no reset
  1078 00000BC9 E86703              <1> 	call	set_fdc_dor
  1079 00000BCC B8FD90              <1> 	mov	ax,90FDh
  1080 00000BCF CD15                <1> 	int	15h			; call OS hook
  1081 00000BD1 722E                <1> 	jc	.exit
  1082 00000BD3 1E                  <1> 	push	ds
  1083 00000BD4 56                  <1> 	push	si
  1084 00000BD5 31F6                <1> 	xor	si,si
  1085 00000BD7 8EDE                <1> 	mov	ds,si
  1086 00000BD9 C5367800            <1> 	lds	si,[1Eh*4]		; DS:SI -> INT 1Eh
  1087 00000BDD 8A440A              <1> 	mov	al,byte [si+0Ah]	; AL = motor start time in 1/8 second
  1088 00000BE0 5E                  <1> 	pop	si
  1089 00000BE1 1F                  <1> 	pop	ds
  1090                              <1> 
  1091 00000BE2 F6063F0080          <1> 	test	byte [fdc_motor_state],fdc_write_flag ; test the write bit
  1092 00000BE7 7408                <1> 	jz	.read_verify		; jump if not write operation
  1093 00000BE9 3C08                <1> 	cmp	al,8
  1094 00000BEB 730A                <1> 	jae	.wait_loop		; jump if at least 1 second start time
  1095 00000BED B008                <1> 	mov	al,8			; wait at least 1 second for write
  1096 00000BEF EB06                <1> 	jmp	.wait_loop
  1097                              <1> 
  1098                              <1> .read_verify:
  1099 00000BF1 3C05                <1> 	cmp	al,5
  1100 00000BF3 7302                <1> 	jae	.wait_loop		; jump if at least 625 ms start time
  1101 00000BF5 B005                <1> 	mov	al,5			; wait at least 625 ms for read / verify
  1102                              <1> 
  1103                              <1> .wait_loop:
  1104 00000BF7 B95F20              <1> 	mov	cx,8287			; 8287 * 15.09us ~= 125ms
  1105 00000BFA E807FC              <1> 	call	delay_15us		; wait 125 ms
  1106 00000BFD FEC8                <1> 	dec	al
  1107 00000BFF 75F6                <1> 	jnz	.wait_loop		; repeat until AL = 0
  1108                              <1> 
  1109                              <1> .exit:
  1110 00000C01 5A                  <1> 	pop	dx
  1111 00000C02 59                  <1> 	pop	cx
  1112 00000C03 58                  <1> 	pop	ax
  1113 00000C04 C3                  <1> 	ret
  1114                              <1> 
  1115                              <1> .already_on:
  1116 00000C05 A23F00              <1> 	mov	byte [fdc_motor_state],al ; update motor state (AL) in data area
  1117 00000C08 FB                  <1> 	sti
  1118 00000C09 0C40                <1> 	or	al,40h			; no reset
  1119 00000C0B E82503              <1> 	call	set_fdc_dor
  1120 00000C0E EBF1                <1> 	jmp	.exit
  1121                              <1> 
  1122                              <1> ;=========================================================================
  1123                              <1> ; fdc_end_io - Set motor timeout, return next sector to be transferred
  1124                              <1> ; Input:
  1125                              <1> ;	CH = cylinder
  1126                              <1> ;	DH = head
  1127                              <1> ; Output:
  1128                              <1> ;	BL = next sector to be transferred
  1129                              <1> ;-------------------------------------------------------------------------	
  1130                              <1> fdc_end_io:
  1131 00000C10 50                  <1> 	push	ax
  1132 00000C11 1E                  <1> 	push	ds
  1133 00000C12 31DB                <1> 	xor	bx,bx
  1134 00000C14 8EDB                <1> 	mov	ds,bx
  1135 00000C16 C51E7800            <1> 	lds	bx,[1Eh*4]		; DS:BX -> INT 1Eh
  1136 00000C1A 8A6702              <1> 	mov	ah,byte [bx+2]		; motor timeout (ticks)
  1137 00000C1D 8A4704              <1> 	mov	al,byte [bx+4]		; sectors per track
  1138 00000C20 FEC0                <1> 	inc	al
  1139 00000C22 1F                  <1> 	pop	ds
  1140 00000C23 BB4200              <1> 	mov	bx,fdc_ctrl_status
  1141 00000C26 3A6F03              <1> 	cmp	ch,byte [bx+3]		; same result cylinder?
  1142 00000C29 7508                <1> 	jne	.exit
  1143 00000C2B 3A7704              <1> 	cmp	dh,byte [bx+4]		; same result head?
  1144 00000C2E 7503                <1> 	jne	.exit
  1145 00000C30 8A4705              <1> 	mov	al,byte [bx+5]		; result sector number
  1146                              <1> .exit:
  1147 00000C33 88264000            <1> 	mov	byte [fdc_motor_tout],ah  ; motor timeout
  1148 00000C37 88C3                <1> 	mov	bl,al			; next sector to be transferred
  1149 00000C39 58                  <1> 	pop	ax
  1150 00000C3A C3                  <1> 	ret
  1151                              <1> 
  1152                              <1> ;========================================================================
  1153                              <1> ; fdc_disk_change - Read disk change line, reset it if active
  1154                              <1> ; Input:
  1155                              <1> ;	AL = drive type
  1156                              <1> ; Output:
  1157                              <1> ;	CF clear if disk not changed
  1158                              <1> ;		AH = 00h - disk not changed
  1159                              <1> ;	CF set if disk changed or on error
  1160                              <1> ;		AH = 06h - disk changed
  1161                              <1> ;		AH = error code
  1162                              <1> ;		AL - trashed
  1163                              <1> ; Note:
  1164                              <1> ;	Motor needs to be turned on before calling this function
  1165                              <1> ;------------------------------------------------------------------------
  1166                              <1> fdc_disk_change:
  1167 00000C3B 53                  <1> 	push	bx
  1168 00000C3C 51                  <1> 	push	cx
  1169 00000C3D B400                <1> 	mov	ah,0
  1170 00000C3F 3C01                <1> 	cmp	al,type_360
  1171 00000C41 7443                <1> 	je	.exit			; jump if 360K drive (no change line)
  1172 00000C43 3C03                <1> 	cmp	al,type_720
  1173 00000C45 743F                <1> 	je	.exit			; jump if 720K drive (no change line)
  1174                              <1> 
  1175 00000C47 E8F802              <1> 	call	get_media_state
  1176 00000C4A 88D8                <1> 	mov	al,bl			; AL = drive media state
  1177 00000C4C 2407                <1> 	and	al,fdc_m_state_bits
  1178 00000C4E 7436                <1> 	jz	.exit			; jump if 360K drive (no change line)
  1179 00000C50 3C03                <1> 	cmp	al,3
  1180 00000C52 7432                <1> 	je	.exit			; jump if 360K drive (no change line)
  1181 00000C54 BAF703              <1> 	mov	dx,fdc_dir_reg		; get digital input register address
  1182 00000C57 EC                  <1> 	in	al,dx			; read disk change line
  1183 00000C58 D0E0                <1> 	shl	al,1
  1184 00000C5A 732A                <1> 	jnc	.exit			; no disk change
  1185 00000C5C 88D8                <1> 	mov	al,bl			; AL = drive media state
  1186 00000C5E 24EF                <1> 	and	al,~fdc_m_established	; media not detected
  1187 00000C60 E8E902              <1> 	call	set_media_state
  1188 00000C63 E8D7FB              <1> 	call	fdc_init		; full initialization
  1189 00000C66 721E                <1> 	jc	.exit
  1190 00000C68 8B5608              <1> 	mov	dx,word [bp+int_13_dx]	; restore DX
  1191 00000C6B B501                <1> 	mov	ch,1
  1192 00000C6D E877FE              <1> 	call	fdc_seek		; seek to cylinder 1
  1193 00000C70 7214                <1> 	jc	.exit
  1194 00000C72 B500                <1> 	mov	ch,0
  1195 00000C74 E870FE              <1> 	call	fdc_seek		; seek to cylinder 0
  1196 00000C77 720D                <1> 	jc	.exit
  1197 00000C79 B406                <1> 	mov	ah,fdc_e_changed
  1198 00000C7B BAF703              <1> 	mov	dx,fdc_dir_reg		; get digital input register address
  1199 00000C7E EC                  <1> 	in	al,dx			; read disk change line
  1200 00000C7F D0E0                <1> 	shl	al,1
  1201 00000C81 7302                <1> 	jnc	.changed_or_error	; jump if disk change line was reset
  1202 00000C83 B480                <1> 	mov	ah,fdc_e_timeout	; failed: no floppy
  1203                              <1> 
  1204                              <1> .changed_or_error:
  1205 00000C85 F9                  <1> 	stc
  1206                              <1> 
  1207                              <1> .exit:
  1208 00000C86 8B5608              <1> 	mov	dx,word [bp+int_13_dx]	; restore dx
  1209 00000C89 59                  <1> 	pop	cx
  1210 00000C8A 5B                  <1> 	pop	bx
  1211 00000C8B C3                  <1> 	ret
  1212                              <1> 
  1213                              <1> ;=========================================================================
  1214                              <1> ; fdc_configure_dma - Configure DMA controller for FDC operation (channel 2)
  1215                              <1> ; Input:
  1216                              <1> ;	AL = DMA mode byte
  1217                              <1> ;		42h - verify (single mode, addr increment, verify, channel 2)
  1218                              <1> ;		46h - read   (single mode, addr increment, write, channel 2)
  1219                              <1> ;		4Ah - write  (single mode, addr increment, read, channel 2)
  1220                              <1> ;	CX = byte count (minus 1)
  1221                              <1> ;	ES:BX -> buffer address for DMA operation (BX is from [BP+int_13_bx])
  1222                              <1> ; Output:
  1223                              <1> ;	CF clear on success
  1224                              <1> ;	CF set if error
  1225                              <1> ;		AH = 08h - DMA overrun
  1226                              <1> ;	AX,BX trashed
  1227                              <1> ; Note:
  1228                              <1> ;	Translates ES:BX to DMA page and base address and configures DMAC
  1229                              <1> ;-------------------------------------------------------------------------
  1230                              <1> fdc_configure_dma:
  1231 00000C8C 52                  <1> 	push	dx
  1232 00000C8D 8B5E0C              <1> 	mov	bx,word [bp+int_13_bx]	; get BX from the stack
  1233 00000C90 8CC2                <1> 	mov	dx,es			; user's buffer segment
  1234 00000C92 D1C2                <1> 	rol	dx,1
  1235 00000C94 D1C2                <1> 	rol	dx,1
  1236 00000C96 D1C2                <1> 	rol	dx,1
  1237 00000C98 D1C2                <1> 	rol	dx,1
  1238 00000C9A 88D4                <1> 	mov	ah,dl			; calculate DMA page number
  1239 00000C9C 80E40F              <1> 	and	ah,0Fh			; AH = page number: bits 19 - 16 of ES
  1240 00000C9F 80E2F0              <1> 	and	dl,0F0h			; DX = DMA offset: bits 15 - 0 of ES
  1241 00000CA2 01DA                <1> 	add	dx,bx			; add user's buffer offset
  1242 00000CA4 80D400              <1> 	adc	ah,0			; increment page number on overflow
  1243                              <1> 
  1244 00000CA7 89D3                <1> 	mov	bx,dx			; check if crossing DMA page boundary:
  1245 00000CA9 01CB                <1> 	add	bx,cx			;   add DMA buffer address to byte count
  1246 00000CAB 7243                <1> 	jc	.dma_boundary		; jump if crossing DMA boundary (64 KiB)
  1247                              <1> 
  1248 00000CAD FA                  <1> 	cli
  1249 00000CAE E60B                <1> 	out	dmac_mode_reg,al	; send DMA mode byte
  1250 00000CB0 EB00                <1> 	jmp	$+2
  1251 00000CB2 EB00                <1> 	jmp	$+2
  1252 00000CB4 E60C                <1> 	out	dmac_ff_reg,al		; clear first/last flip-flop
  1253 00000CB6 EB00                <1> 	jmp	$+2
  1254 00000CB8 EB00                <1> 	jmp	$+2
  1255 00000CBA 88C8                <1> 	mov	al,cl
  1256 00000CBC E605                <1> 	out	dmac_ch2_count_reg,al	; send word count - low byte
  1257 00000CBE EB00                <1> 	jmp	$+2
  1258 00000CC0 EB00                <1> 	jmp	$+2
  1259 00000CC2 88E8                <1> 	mov	al,ch
  1260 00000CC4 E605                <1> 	out	dmac_ch2_count_reg,al	; send word count - high byte
  1261 00000CC6 EB00                <1> 	jmp	$+2
  1262 00000CC8 EB00                <1> 	jmp	$+2
  1263 00000CCA E60C                <1> 	out	dmac_ff_reg,al		; clear first/last flip-flop
  1264 00000CCC EB00                <1> 	jmp	$+2
  1265 00000CCE EB00                <1> 	jmp	$+2
  1266 00000CD0 88D0                <1> 	mov	al,dl
  1267 00000CD2 E604                <1> 	out	dmac_ch2_addr_reg,al	; send base address - low byte
  1268 00000CD4 EB00                <1> 	jmp	$+2
  1269 00000CD6 EB00                <1> 	jmp	$+2
  1270 00000CD8 88F0                <1> 	mov	al,dh
  1271 00000CDA E604                <1> 	out	dmac_ch2_addr_reg,al	; send base address - high byte
  1272 00000CDC EB00                <1> 	jmp	$+2
  1273 00000CDE EB00                <1> 	jmp	$+2
  1274 00000CE0 88E0                <1> 	mov	al,ah
  1275 00000CE2 E681                <1> 	out	dmapage_ch2_reg,al	; channel 2 page register
  1276 00000CE4 EB00                <1> 	jmp	$+2
  1277 00000CE6 EB00                <1> 	jmp	$+2
  1278 00000CE8 B002                <1> 	mov	al,2
  1279 00000CEA E60A                <1> 	out	dmac_mask_reg,al	; enable DMA channel 2
  1280 00000CEC FB                  <1> 	sti
  1281 00000CED F8                  <1> 	clc				; CF = 0 - no error
  1282                              <1> 
  1283                              <1> .exit:
  1284 00000CEE 5A                  <1> 	pop	dx
  1285 00000CEF C3                  <1> 	ret
  1286                              <1> 
  1287                              <1> .dma_boundary:				; Note: CF is already set
  1288 00000CF0 B409                <1> 	mov	ah,fdc_e_boundary
  1289 00000CF2 EBFA                <1> 	jmp	.exit
  1290                              <1> 
  1291                              <1> ;=========================================================================
  1292                              <1> ; fdc_send_cmd - Send a command to FDC
  1293                              <1> ; Input:
  1294                              <1> ;	AL = 1st byte of the command
  1295                              <1> ;	AH = 2nd byte of the command
  1296                              <1> ;	SI = 3rd and 4th bytes of the command
  1297                              <1> ;	DI = 5th and 6th bytes of the command
  1298                              <1> ;	BL = 7th byte of the command
  1299                              <1> ;	BH = 8th byte of the command
  1300                              <1> ;	CH = 9th byte of the command
  1301                              <1> ;	CL = command length (number of bytes)
  1302                              <1> ; Output:
  1303                              <1> ;	CF clear if successful
  1304                              <1> ;		AH = 00h - successful completion
  1305                              <1> ;	CF set on error
  1306                              <1> ;		AH = 20h - controller failure
  1307                              <1> ;		AH = 80h - timeout / device not ready
  1308                              <1> ;	AX trashed
  1309                              <1> ;-------------------------------------------------------------------------
  1310                              <1> fdc_send_cmd:
  1311 00000CF4 E84900              <1> 	call	fdc_write		; send AL (1st byte)
  1312 00000CF7 FEC9                <1> 	dec	cl
  1313 00000CF9 7644                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  1314 00000CFB 88E0                <1> 	mov	al,ah
  1315 00000CFD E84000              <1> 	call	fdc_write		; send AH (2nd byte)
  1316 00000D00 FEC9                <1> 	dec	cl
  1317 00000D02 763B                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  1318 00000D04 89F0                <1> 	mov	ax,si
  1319 00000D06 E83700              <1> 	call	fdc_write		; send SI / low byte (3th byte)
  1320 00000D09 FEC9                <1> 	dec	cl
  1321 00000D0B 7632                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  1322 00000D0D 88E0                <1> 	mov	al,ah
  1323 00000D0F E82E00              <1> 	call	fdc_write		; send SI / high byte (4th byte)
  1324 00000D12 FEC9                <1> 	dec	cl
  1325 00000D14 7629                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  1326 00000D16 89F8                <1> 	mov	ax,di
  1327 00000D18 E82500              <1> 	call	fdc_write		; send DI / low byte (5th byte)
  1328 00000D1B FEC9                <1> 	dec	cl
  1329 00000D1D 7620                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  1330 00000D1F 88E0                <1> 	mov	al,ah
  1331 00000D21 E81C00              <1> 	call	fdc_write		; send DI / high byte (6th byte)
  1332 00000D24 FEC9                <1> 	dec	cl
  1333 00000D26 7617                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  1334 00000D28 88D8                <1> 	mov	al,bl
  1335 00000D2A E81300              <1> 	call	fdc_write		; send BL (7rd byte)
  1336 00000D2D FEC9                <1> 	dec	cl
  1337 00000D2F 760E                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  1338 00000D31 88F8                <1> 	mov	al,bh
  1339 00000D33 E80A00              <1> 	call	fdc_write		; send BH (8th byte)
  1340 00000D36 FEC9                <1> 	dec	cl
  1341 00000D38 7605                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  1342 00000D3A 88E8                <1> 	mov	al,ch
  1343 00000D3C E80100              <1> 	call	fdc_write		; send CH (9th byte)
  1344                              <1> 
  1345                              <1> .send_cmd_exit:
  1346 00000D3F C3                  <1> 	ret
  1347                              <1> 
  1348                              <1> ;=========================================================================
  1349                              <1> ; fdc_write - Send byte to FDC
  1350                              <1> ; Input:
  1351                              <1> ;	AL = byte to send
  1352                              <1> ; Output:
  1353                              <1> ;	CF clear if successful
  1354                              <1> ;	CF set if timeout
  1355                              <1> ;		AH = 80h - timeout / device not ready
  1356                              <1> ;-------------------------------------------------------------------------
  1357                              <1> fdc_write:
  1358 00000D40 51                  <1> 	push	cx
  1359 00000D41 52                  <1> 	push	dx
  1360 00000D42 50                  <1> 	push	ax
  1361 00000D43 BAF403              <1> 	mov	dx,fdc_status_reg	; get status register address
  1362 00000D46 31C9                <1> 	xor	cx,cx			; busy wait counter
  1363                              <1> 
  1364                              <1> .wait_ready:
  1365 00000D48 EC                  <1> 	in	al,dx			; read fdc_status_reg
  1366 00000D49 A880                <1> 	test	al,fdc_stat_ready	; exit loop if FDC is ready
  1367 00000D4B 7508                <1> 	jnz	.fdc_ready
  1368 00000D4D E2F9                <1> 	loop	.wait_ready
  1369 00000D4F 58                  <1> 	pop	ax
  1370 00000D50 B480                <1> 	mov	ah,fdc_e_timeout	; timeout
  1371 00000D52 F9                  <1> 	stc				; indicate error
  1372 00000D53 EB08                <1> 	jmp	.exit
  1373                              <1> 
  1374                              <1> .fdc_ready:
  1375 00000D55 A860                <1> 	test	al,fdc_stat_dir|fdc_stat_dma ; check that DIR and DMA flags are 0
  1376 00000D57 7507                <1> 	jnz	.failure		; FDC failure if they are set
  1377 00000D59 58                  <1> 	pop	ax
  1378 00000D5A 42                  <1> 	inc	dx			; DX = fdc_data_reg = fdc_status_reg + 1
  1379 00000D5B EE                  <1> 	out	dx,al			; write byte
  1380 00000D5C F8                  <1> 	clc				; no error
  1381                              <1> 
  1382                              <1> .exit:
  1383 00000D5D 5A                  <1> 	pop	dx
  1384 00000D5E 59                  <1> 	pop	cx
  1385 00000D5F C3                  <1> 	ret
  1386                              <1> 
  1387                              <1> .failure:
  1388 00000D60 58                  <1> 	pop	ax
  1389 00000D61 B420                <1> 	mov	ah,fdc_e_failure	; FDC failure
  1390 00000D63 F9                  <1> 	stc
  1391 00000D64 EBF7                <1> 	jmp	.exit
  1392                              <1> 
  1393                              <1> ;=========================================================================
  1394                              <1> ; fdc_get_result - Read FDC result
  1395                              <1> ; Input:
  1396                              <1> ;	none
  1397                              <1> ; Output:
  1398                              <1> ;	CF clear if successful
  1399                              <1> ;		AH = 00h - operation successful
  1400                              <1> ;		Result is returned in fdc_ctrl_status BIOS area
  1401                              <1> ;	CF set on error
  1402                              <1> ;		AH = 20h - controller failure
  1403                              <1> ;		AH = 80h - timeout / device not ready
  1404                              <1> ;	AL,BX - trashed
  1405                              <1> ;-------------------------------------------------------------------------
  1406                              <1> fdc_get_result:
  1407 00000D66 51                  <1> 	push	cx
  1408 00000D67 52                  <1> 	push	dx
  1409 00000D68 BB4200              <1> 	mov	bx,fdc_ctrl_status
  1410 00000D6B BAF403              <1> 	mov	dx,fdc_status_reg	; get status register address
  1411                              <1> 
  1412                              <1> .next_byte:
  1413 00000D6E 31C9                <1>         xor     cx,cx			; busy wait counter
  1414                              <1> 
  1415                              <1> .wait_ready:
  1416 00000D70 EC                  <1> 	in	al,dx			; read fdc_status_reg
  1417 00000D71 A880                <1> 	test	al,fdc_stat_ready	; exit loop if FDC is ready
  1418 00000D73 7507                <1> 	jnz	.fdc_ready
  1419 00000D75 E2F9                <1> 	loop	.wait_ready
  1420 00000D77 B480                <1> 	mov	ah,fdc_e_timeout	; timeout
  1421 00000D79 F9                  <1> 	stc				; indicate error
  1422 00000D7A EB19                <1> 	jmp	.exit
  1423                              <1> 
  1424                              <1> .fdc_ready:
  1425 00000D7C 2470                <1> 	and	al,fdc_stat_dir|fdc_stat_dma|fdc_stat_busy
  1426 00000D7E A8EF                <1> 	test	al,~fdc_stat_busy	; controller finished sending result?
  1427 00000D80 7411                <1> 	je	.done
  1428 00000D82 3C50                <1> 	cmp	al,fdc_stat_dir|fdc_stat_busy
  1429 00000D84 7512                <1> 	jne	.failure		; invalid FDC status, indicate FDC failure
  1430 00000D86 83FB49              <1> 	cmp	bx,fdc_ctrl_status+7	; already read 7 bytes?
  1431 00000D89 730D                <1> 	jnb	.failure		; controller error if so
  1432 00000D8B 42                  <1> 	inc	dx			; DX = fdc_data_reg = fdc_status_reg + 1
  1433 00000D8C EC                  <1> 	in	al,dx
  1434 00000D8D 8807                <1> 	mov	byte [bx],al
  1435 00000D8F 43                  <1> 	inc	bx
  1436 00000D90 4A                  <1> 	dec	dx			; DX = fdc_status_reg = fdc_data_reg - 1
  1437 00000D91 EBDB                <1> 	jmp	.next_byte
  1438                              <1> 
  1439                              <1> .done:
  1440 00000D93 30E4                <1> 	xor	ah,ah			; operation successful
  1441                              <1> 
  1442                              <1> .exit:
  1443 00000D95 5A                  <1> 	pop	dx
  1444 00000D96 59                  <1> 	pop	cx
  1445 00000D97 C3                  <1> 	ret
  1446                              <1> 
  1447                              <1> .failure:
  1448 00000D98 B420                <1> 	mov	ah,fdc_e_failure
  1449 00000D9A F9                  <1> 	stc
  1450 00000D9B EBF8                <1> 	jmp	.exit
  1451                              <1> 
  1452                              <1> ;=========================================================================
  1453                              <1> ; fdc_read - Read byte from FDC
  1454                              <1> ; Input:
  1455                              <1> ;	none
  1456                              <1> ; Output:
  1457                              <1> ;	CF clear if successful
  1458                              <1> ;		AL = byte read from FDC
  1459                              <1> ;		AH - unchanged
  1460                              <1> ;	CF set on error
  1461                              <1> ;		AH = 20h - controller failure
  1462                              <1> ;		AH = 80h - timeout / device not ready
  1463                              <1> ;-------------------------------------------------------------------------
  1464                              <1> fdc_read:
  1465 00000D9D 51                  <1> 	push	cx
  1466 00000D9E 52                  <1> 	push	dx
  1467 00000D9F BAF403              <1> 	mov	dx,fdc_status_reg	; get status register address
  1468 00000DA2 31C9                <1>         xor     cx,cx			; busy wait counter
  1469                              <1> 
  1470                              <1> .wait_ready:
  1471 00000DA4 EC                  <1> 	in	al,dx			; read fdc_status_reg
  1472 00000DA5 A880                <1> 	test	al,fdc_stat_ready	; exit loop if FDC is ready
  1473 00000DA7 7507                <1> 	jnz	.fdc_ready
  1474 00000DA9 E2F9                <1> 	loop	.wait_ready
  1475 00000DAB B480                <1> 	mov	ah,fdc_e_timeout	; timeout
  1476 00000DAD F9                  <1> 	stc				; indicate error
  1477 00000DAE EB08                <1> 	jmp	.exit
  1478                              <1> 
  1479                              <1> .fdc_ready:
  1480 00000DB0 EC                  <1> 	in	al,dx
  1481 00000DB1 A840                <1> 	test	al,fdc_stat_dir		; FDC is ready to send a byte? 
  1482 00000DB3 7406                <1> 	jz	.failure		; jump if not ready
  1483                              <1> ;	jmp	short $+2		; I/O delay
  1484                              <1> ;	jmp	short $+2
  1485 00000DB5 42                  <1> 	inc	dx			; DX = fdc_data_reg = fdc_status_reg + 1
  1486 00000DB6 EC                  <1> 	in	al,dx			; read the byte
  1487 00000DB7 F8                  <1> 	clc				; no error
  1488                              <1> 
  1489                              <1> .exit:
  1490 00000DB8 5A                  <1> 	pop	dx
  1491 00000DB9 59                  <1> 	pop	cx
  1492 00000DBA C3                  <1> 	ret
  1493                              <1> 
  1494                              <1> .failure:
  1495 00000DBB B420                <1> 	mov	ah,fdc_e_failure
  1496 00000DBD F9                  <1> 	stc
  1497 00000DBE EBF8                <1> 	jmp	.exit
  1498                              <1> 
  1499                              <1> ;=========================================================================
  1500                              <1> ; fdc_get_error - Translate FDC status to BIOS error number
  1501                              <1> ; Input:
  1502                              <1> ;	DS:[fdc_ctrl_status] - FDC status bytes
  1503                              <1> ; Output:
  1504                              <1> ;	AH = error code
  1505                              <1> ;-------------------------------------------------------------------------
  1506                              <1> fdc_get_error:
  1507 00000DC0 8B1E4200            <1> 	mov	bx,word [fdc_ctrl_status]
  1508 00000DC4 F6C3C0              <1> 	test	bl,0C0h			; BL = ST1
  1509 00000DC7 B400                <1> 	mov	ah,fdc_e_success
  1510 00000DC9 7433                <1> 	jz	.exit			; jump if successful completion
  1511 00000DCB F6C340              <1> 	test	bl,40h			; abnormal termination?
  1512 00000DCE B420                <1> 	mov	ah,fdc_e_failure
  1513 00000DD0 742C                <1> 	jz	.exit
  1514 00000DD2 F6C701              <1> 	test	bh,1			; address mark not found?
  1515 00000DD5 B402                <1> 	mov	ah,fdc_e_address
  1516 00000DD7 7525                <1> 	jnz	.exit
  1517 00000DD9 F6C702              <1> 	test	bh,2			; disk write protected?
  1518 00000DDC B403                <1> 	mov	ah,fdc_e_wprotect
  1519 00000DDE 751E                <1> 	jnz	.exit
  1520 00000DE0 F6C704              <1> 	test	bh,4			; sector not found?
  1521 00000DE3 B404                <1> 	mov	ah,fdc_e_notfound
  1522 00000DE5 7517                <1> 	jnz	.exit
  1523 00000DE7 F6C710              <1> 	test	bh,10H			; DMA overrun?
  1524 00000DEA B408                <1> 	mov	ah,fdc_e_dma
  1525 00000DEC 7510                <1> 	jnz	.exit
  1526 00000DEE F6C720              <1> 	test	bh,20H			; CRC error?
  1527 00000DF1 B410                <1> 	mov	ah,fdc_e_crc
  1528 00000DF3 7509                <1> 	jnz	.exit
  1529 00000DF5 F6C780              <1> 	test	bh,80h			; access after last sector?
  1530 00000DF8 B404                <1> 	mov	ah,fdc_e_notfound
  1531 00000DFA 7502                <1> 	jnz	.exit
  1532 00000DFC B420                <1> 	mov	ah,fdc_e_failure	; return FDC failure for other errors
  1533                              <1> 
  1534                              <1> .exit:
  1535 00000DFE C3                  <1> 	ret
  1536                              <1> 
  1537                              <1> ;=========================================================================
  1538                              <1> ; fdc_reset - Reset FDC
  1539                              <1> ; Input:
  1540                              <1> ;	none
  1541                              <1> ; Output:
  1542                              <1> ;	Resets FDC flags in BIOS area
  1543                              <1> ;	AX,CX,DX - trashed 
  1544                              <1> ;-------------------------------------------------------------------------
  1545                              <1> fdc_reset:
  1546 00000DFF FA                  <1> 	cli
  1547 00000E00 80263E007F          <1> 	and	byte [fdc_calib_state],~fdc_irq_flag ; clear IRQ flag
  1548 00000E05 80263F007F          <1> 	and	byte [fdc_motor_state],~fdc_write_flag ; clear the write bit
  1549 00000E0A A03F00              <1> 	mov	al,byte [fdc_motor_state] ; AL = motor state byte
  1550 00000E0D 24BF                <1> 	and	al,0BFh			; clear bit 6 - reset
  1551 00000E0F 50                  <1> 	push	ax			; set_fdc_dor trashes AX, save it
  1552 00000E10 E82001              <1> 	call	set_fdc_dor
  1553 00000E13 58                  <1> 	pop	ax
  1554 00000E14 B90300              <1> 	mov	cx,3
  1555 00000E17 E8EAF9              <1> 	call	delay_15us		; 30-45 us delay
  1556 00000E1A 0C40                <1> 	or	al,40h			; set bit 6 - no reset
  1557 00000E1C E81401              <1> 	call	set_fdc_dor
  1558 00000E1F FB                  <1> 	sti
  1559 00000E20 E8E800              <1> 	call	fdc_wait_irq		; wait for IRQ
  1560 00000E23 7207                <1> 	jc	.exit
  1561 00000E25 80263E007F          <1> 	and	byte [fdc_calib_state],~fdc_irq_flag ; clear IRQ flag
  1562 00000E2A 30E4                <1> 	xor	ah,ah			; no errors
  1563                              <1> .exit:
  1564 00000E2C C3                  <1> 	ret
  1565                              <1> 
  1566                              <1> ;=========================================================================
  1567                              <1> ; fdc_detect_media - Detect media type, update it in fdc_media_state[drive]
  1568                              <1> ; Input:
  1569                              <1> ;	[BP+int_13_dl] = drive number
  1570                              <1> ; Output:
  1571                              <1> ;	CF clear if successful
  1572                              <1> ;		AH = 00h
  1573                              <1> ;	CF set on error
  1574                              <1> ;		AH = 20h - invalid drive type
  1575                              <1> ;-------------------------------------------------------------------------
  1576                              <1> fdc_detect_media:
  1577 00000E2D 52                  <1> 	push	dx
  1578 00000E2E 51                  <1> 	push	cx
  1579                              <1> 
  1580 00000E2F B420                <1> 	mov	ah,fdc_e_failure	; in case the get_drive_type fails
  1581 00000E31 8A5608              <1> 	mov	dl,byte [bp+int_13_dl]	; restore DL in case it was trashed
  1582 00000E34 E86A01              <1> 	call	get_drive_type		; get drive type to AL
  1583 00000E37 726B                <1> 	jc	.exit			; drive doesn't exist or invalid type
  1584                              <1> 
  1585 00000E39 3C03                <1> 	cmp	al,type_720
  1586 00000E3B 7410                <1> 	je	.set_720
  1587 00000E3D 3C02                <1> 	cmp	al,type_1200
  1588 00000E3F 7415                <1> 	je	.detect_1200
  1589 00000E41 3C04                <1> 	cmp	al,type_1440
  1590 00000E43 7427                <1> 	je	.detect_1440
  1591 00000E45 3C06                <1> 	cmp	al,type_2880
  1592 00000E47 7439                <1> 	je	.detect_2880
  1593                              <1> 
  1594 00000E49 B093                <1> 	mov	al,fdc_m_360in360	; set 360K disk in 360K drive
  1595 00000E4B EB02                <1> 	jmp	.set_rate
  1596                              <1> 
  1597                              <1> .set_720:
  1598 00000E4D B097                <1> 	mov	al,fdc_m_720
  1599                              <1> 
  1600                              <1> .set_rate:
  1601 00000E4F 50                  <1> 	push	ax
  1602 00000E50 E89F00              <1> 	call	fdc_set_rate		; transfer rate in AL
  1603 00000E53 58                  <1> 	pop	ax
  1604 00000E54 EB49                <1> 	jmp	.exit_set_media
  1605                              <1> 
  1606                              <1> .detect_1200:
  1607 00000E56 B000                <1> 	mov	al,0			; try 500 Kbps
  1608 00000E58 E85000              <1> 	call	fdc_read_id
  1609 00000E5B B015                <1> 	mov	al,fdc_m_1200in1200
  1610 00000E5D 7340                <1> 	jnc	.exit_set_media		; jump if successful
  1611 00000E5F B040                <1> 	mov	al,40h			; try 300 Kbps
  1612 00000E61 E84700              <1> 	call	fdc_read_id
  1613 00000E64 B074                <1> 	mov	al,fdc_m_360in1200
  1614 00000E66 7337                <1> 	jnc	.exit_set_media		; jump if successful
  1615 00000E68 B002                <1> 	mov	al,fdc_m_try_1200in1200
  1616 00000E6A EB33                <1> 	jmp	.exit_set_media
  1617                              <1> 
  1618                              <1> .detect_1440:
  1619 00000E6C B000                <1> 	mov	al,0			; try 500 Kbps
  1620 00000E6E E83A00              <1> 	call	fdc_read_id
  1621 00000E71 B017                <1> 	mov	al,fdc_m_1440
  1622 00000E73 732A                <1> 	jnc	.exit_set_media		; jump if successful
  1623 00000E75 B080                <1> 	mov	al,80h			; try 250 Kbps
  1624 00000E77 E83100              <1> 	call	fdc_read_id
  1625 00000E7A B097                <1> 	mov	al,fdc_m_720
  1626 00000E7C 7321                <1> 	jnc	.exit_set_media		; jump if successful
  1627 00000E7E B007                <1> 	mov	al,fdc_m_try_1440
  1628 00000E80 EB1D                <1> 	jmp	.exit_set_media
  1629                              <1> 
  1630                              <1> .detect_2880:
  1631 00000E82 B0C0                <1> 	mov	al,0C0h			; try 1 Mbps
  1632 00000E84 E82400              <1> 	call	fdc_read_id
  1633 00000E87 B0D7                <1> 	mov	al,fdc_m_2880
  1634 00000E89 7314                <1> 	jnc	.exit_set_media		; jump if successful
  1635 00000E8B B000                <1> 	mov	al,0			; try 500 Kbps
  1636 00000E8D E81B00              <1> 	call	fdc_read_id
  1637 00000E90 B017                <1> 	mov	al,fdc_m_1440
  1638 00000E92 730B                <1> 	jnc	.exit_set_media		; jump if successful
  1639 00000E94 B080                <1> 	mov	al,80h			; try 250 Kbps
  1640 00000E96 E81200              <1> 	call	fdc_read_id
  1641 00000E99 B097                <1> 	mov	al,fdc_m_720
  1642 00000E9B 7302                <1> 	jnc	.exit_set_media		; jump_if successful
  1643 00000E9D B0C7                <1> 	mov	al,fdc_m_try_2880
  1644                              <1> 
  1645                              <1> .exit_set_media:
  1646 00000E9F E8AA00              <1> 	call	set_media_state		; set media state
  1647 00000EA2 30E4                <1> 	xor	ah,ah			; AH = 0, CF = 0 - no error
  1648                              <1> .exit:
  1649 00000EA4 88264100            <1> 	mov	byte [fdc_last_error],ah
  1650 00000EA8 59                  <1> 	pop	cx
  1651 00000EA9 5A                  <1> 	pop	dx
  1652 00000EAA C3                  <1> 	ret
  1653                              <1> 
  1654                              <1> ;=========================================================================
  1655                              <1> ; fdc_read_id - Read ID
  1656                              <1> ; Input:
  1657                              <1> ;	[BP+int_13_dl] = drive number
  1658                              <1> ; Output:
  1659                              <1> ;	CF clear if successful
  1660                              <1> ;		AH = 0 - successful completion
  1661                              <1> ;		AL = ID (bits 7-6)
  1662                              <1> ;	CF set on error
  1663                              <1> ;		AH = error code
  1664                              <1> ;	AX,CX - trashed
  1665                              <1> ;-------------------------------------------------------------------------
  1666                              <1> fdc_read_id:
  1667 00000EAB 53                  <1> 	push	bx
  1668 00000EAC C6064000FF          <1> 	mov	byte [fdc_motor_tout],0FFh ; set timeout to maximum
  1669 00000EB1 E83E00              <1> 	call	fdc_set_rate		; transfer rate in AL
  1670 00000EB4 8A5608              <1> 	mov	dl,byte [bp+int_13_dl]
  1671 00000EB7 E8DBFB              <1> 	call	fdc_recalibrate		; recalibrate
  1672 00000EBA 7305                <1> 	jnc	.do_read_id
  1673 00000EBC E8D6FB              <1> 	call	fdc_recalibrate		; second attempt
  1674 00000EBF 722E                <1> 	jc	.error
  1675                              <1> 
  1676                              <1> .do_read_id:
  1677 00000EC1 B90300              <1> 	mov	cx,3			; 3 attempts
  1678                              <1> 
  1679                              <1> .read_id_loop:
  1680 00000EC4 51                  <1> 	push	cx
  1681 00000EC5 B04A                <1> 	mov	al,4Ah			; FDC Read ID command
  1682                              <1> ; FIXME - does drive number in DL gets to here?
  1683                              <1> ;	mov	ah,dl			; read id - byte 1 (head = 0 / drive)
  1684 00000EC7 8A6608              <1> 	mov	ah,byte [bp+int_13_dl]	; read id - byte 1 (head = 0 / drive)
  1685 00000ECA B102                <1> 	mov	cl,2			; 2 byte commands
  1686 00000ECC 80263E007F          <1> 	and	byte [fdc_calib_state],~fdc_irq_flag ; clear IRQ6 flag
  1687 00000ED1 E820FE              <1> 	call	fdc_send_cmd
  1688 00000ED4 7218                <1> 	jc	.error_cmd
  1689 00000ED6 E83200              <1> 	call	fdc_wait_irq		; wait for IRQ6
  1690 00000ED9 7213                <1> 	jc	.error_cmd		; timeout waiting for interrupt
  1691 00000EDB B107                <1> 	mov	cl,7
  1692 00000EDD E886FE              <1> 	call	fdc_get_result		; read result bytes
  1693 00000EE0 720C                <1> 	jc	.error_cmd
  1694 00000EE2 E8DBFE              <1> 	call	fdc_get_error		; get error code
  1695 00000EE5 59                  <1> 	pop	cx
  1696 00000EE6 08E4                <1> 	or	ah,ah
  1697 00000EE8 7406                <1> 	jz	.exit			; if no errors
  1698 00000EEA E2D8                <1> 	loop	.read_id_loop		; retry
  1699 00000EEC EB01                <1> 	jmp	.error
  1700                              <1> 
  1701                              <1> .error_cmd:
  1702 00000EEE 59                  <1> 	pop	cx
  1703                              <1> 
  1704                              <1> .error:
  1705 00000EEF F9                  <1> 	stc
  1706                              <1> 
  1707                              <1> .exit:
  1708 00000EF0 5B                  <1> 	pop	bx
  1709 00000EF1 C3                  <1> 	ret
  1710                              <1> 
  1711                              <1> ;=========================================================================
  1712                              <1> ; fdc_set_rate - Set transfer rate
  1713                              <1> ; Input:
  1714                              <1> ;	AL = transfer rate (bits 7 and 6)
  1715                              <1> ;		00h - 500 Kbps (1.2M and 1.44M disks)
  1716                              <1> ;		40h - 300 Kbps (360K disk in 1.2M drive)
  1717                              <1> ;		80h - 250 Kbps (360K disk in 360K drive, or 720K disk)
  1718                              <1> ;		0C0h - 1 Mbps (2.88M disks)
  1719                              <1> ; Output:
  1720                              <1> ;	none
  1721                              <1> ;-------------------------------------------------------------------------
  1722                              <1> fdc_set_rate:
  1723 00000EF2 50                  <1> 	push	ax
  1724 00000EF3 24C0                <1> 	and	al,fdc_m_rate_bits	; get the data rate bits only
  1725 00000EF5 80268B003F          <1> 	and	byte [fdc_last_rate],~fdc_m_rate_bits ; clear rate bits
  1726 00000EFA 08068B00            <1> 	or	byte [fdc_last_rate],al	; set new rate bits
  1727 00000EFE D0C0                <1> 	rol	al,1
  1728 00000F00 D0C0                <1> 	rol	al,1
  1729 00000F02 BAF703              <1> 	mov	dx,fdc_ccr_reg		; get control configuration register address
  1730 00000F05 EE                  <1> 	out	dx,al
  1731 00000F06 8B5608              <1> 	mov	dx,word [bp+int_13_dx]	; restore DX
  1732 00000F09 58                  <1> 	pop	ax
  1733 00000F0A C3                  <1> 	ret
  1734                              <1> 
  1735                              <1> ;=========================================================================
  1736                              <1> ; fdc_wait_irq - Wait for FDC interrupt for 2 seconds
  1737                              <1> ; Input:
  1738                              <1> ;	none
  1739                              <1> ; Output:
  1740                              <1> ;	CF clear if interrupt had occurred
  1741                              <1> ;		AH = 00h - successful completion
  1742                              <1> ;	CF set if no interrupt
  1743                              <1> ;		AH = 80h - timeout
  1744                              <1> ;	BX = fdc_calib_state
  1745                              <1> ;	AL - trashed
  1746                              <1> ;-------------------------------------------------------------------------
  1747                              <1> fdc_wait_irq:
  1748 00000F0B 51                  <1> 	push	cx
  1749 00000F0C FB                  <1> 	sti
  1750 00000F0D F8                  <1> 	clc
  1751 00000F0E B80190              <1> 	mov	ax,9001h
  1752 00000F11 CD15                <1> 	int	15h			; call OS hook
  1753 00000F13 7212                <1> 	jc	.timeout
  1754 00000F15 BB3E00              <1> 	mov	bx,fdc_calib_state	; contains IRQ flag
  1755 00000F18 31C9                <1> 	xor	cx,cx
  1756                              <1> 
  1757                              <1> %ifdef AT_DELAY
  1758                              <1> 
  1759                              <1> .zero_loop:
  1760                              <1> 	test	byte [bx],fdc_irq_flag	; test IRQ flag
  1761                              <1> 	jnz	.exit			; exit loop if interrupt had occurred
  1762                              <1> 	in	al,ppi_pb_reg
  1763                              <1> 	test	al,refresh_flag
  1764                              <1> 	jz	.zero_loop		; wait 15.09 us
  1765                              <1> 	loop	.one_loop		; DEC CX; JNZ .one_loop
  1766                              <1> 	jmp	.timeout
  1767                              <1> 
  1768                              <1> .one_loop:
  1769                              <1> 	test	byte [bx],fdc_irq_flag	; test IRQ flag
  1770                              <1> 	jnz	.exit			; exit loop if interrupt had occurred
  1771                              <1> 	in	al,ppi_pb_reg
  1772                              <1> 	test	al,refresh_flag
  1773                              <1> 	jnz	.one_loop		; wait 15.09 us
  1774                              <1> 	loop	.zero_loop		; DEC CX; JNZ .zero_loop
  1775                              <1> 
  1776                              <1> %else ; AT_DELAY
  1777                              <1> 
  1778                              <1> .1:
  1779                              <1> 	; wait 38.13 us (Intel 8088 CPU running on 4.77 MHz)
  1780 00000F1A B00A                <1> 	mov	al,10
  1781                              <1> .2:
  1782 00000F1C F60780              <1> 	test	byte [bx],fdc_irq_flag	; test IRQ flag
  1783 00000F1F 750B                <1> 	jnz	.exit			; exit loop if interrupt had occurred
  1784 00000F21 FEC8                <1> 	dec	al
  1785 00000F23 75F7                <1> 	jnz	.2
  1786 00000F25 E2F3                <1> 	loop	.1
  1787                              <1> 
  1788                              <1> %endif ; AT_DELAY
  1789                              <1> 
  1790                              <1> .timeout:
  1791 00000F27 B480                <1> 	mov	ah,fdc_e_timeout	; timeout
  1792 00000F29 F9                  <1> 	stc
  1793 00000F2A 59                  <1> 	pop	cx
  1794 00000F2B C3                  <1> 	ret
  1795                              <1> 
  1796                              <1> .exit:
  1797 00000F2C 80277F              <1> 	and	byte [bx],~fdc_irq_flag	; clear IRQ flag
  1798 00000F2F 30E4                <1> 	xor	ah,ah			; AH = 0, CF = 0 - no error
  1799 00000F31 59                  <1> 	pop	cx
  1800 00000F32 C3                  <1> 	ret
  1801                              <1> 
  1802                              <1> ;=========================================================================
  1803                              <1> ; set_fdc_dor - set FDC Digital Output Register - DOR
  1804                              <1> ; Input:
  1805                              <1> ;	AL = new motor state
  1806                              <1> ; Output:
  1807                              <1> ;	AL, DX trashed
  1808                              <1> ;-------------------------------------------------------------------------
  1809                              <1> set_fdc_dor:
  1810 00000F33 D0C8                <1> 	ror	al,1
  1811 00000F35 D0C8                <1> 	ror	al,1
  1812 00000F37 D0C8                <1> 	ror	al,1
  1813 00000F39 D0C8                <1> 	ror	al,1
  1814 00000F3B 0C08                <1> 	or	al,08h			; DMA+IRQ enabled
  1815 00000F3D BAF203              <1> 	mov	dx,fdc_dor_reg		; get digital output register address
  1816 00000F40 EE                  <1> 	out	dx,al			; send the state to FDC
  1817 00000F41 C3                  <1> 	ret
  1818                              <1> 
  1819                              <1> ;=========================================================================
  1820                              <1> ; get_media_state - Get drive's media state from the data area
  1821                              <1> ; Input:
  1822                              <1> ;	[BP+int_13_dl] = drive number
  1823                              <1> ; Output:
  1824                              <1> ;	BL = drive's media state
  1825                              <1> ;	BH = 0 (destroyed)
  1826                              <1> ;-------------------------------------------------------------------------
  1827                              <1> get_media_state:
  1828 00000F42 8A5E08              <1> 	mov	bl,byte [bp+int_13_dl]
  1829 00000F45 B700                <1> 	mov	bh,0			; BX = drive number
  1830 00000F47 8A9F9000            <1> 	mov	bl,byte [fdc_media_state+bx]
  1831 00000F4B C3                  <1> 	ret
  1832                              <1> 
  1833                              <1> ;=========================================================================
  1834                              <1> ; set_media_state - Store drive's media state in the data area
  1835                              <1> ; Input:
  1836                              <1> ;	AL = media state
  1837                              <1> ;	[BP+int_13_dl] = drive number
  1838                              <1> ; Output:
  1839                              <1> ;	none
  1840                              <1> ;-------------------------------------------------------------------------
  1841                              <1> set_media_state:
  1842 00000F4C 53                  <1> 	push	bx
  1843 00000F4D 8A5E08              <1> 	mov	bl,byte [bp+int_13_dl]
  1844 00000F50 B700                <1> 	mov	bh,0			; BX = drive number
  1845 00000F52 88879000            <1> 	mov	byte [fdc_media_state+bx],al
  1846 00000F56 5B                  <1> 	pop	bx
  1847 00000F57 C3                  <1> 	ret
  1848                              <1> 
  1849                              <1> ;=========================================================================
  1850                              <1> ; check_cylinder - Compare specified cylinder with value in the BIOS data area
  1851                              <1> ; Input:
  1852                              <1> ;	CH = current cylinder
  1853                              <1> ;	[BP+int_13_dl] = drive number
  1854                              <1> ; Output:
  1855                              <1> ;	ZF = 1 - cylinder matches
  1856                              <1> ;-------------------------------------------------------------------------
  1857                              <1> check_cylinder:
  1858 00000F58 53                  <1> 	push	bx
  1859 00000F59 8A5E08              <1> 	mov	bl,byte [bp+int_13_dl]
  1860 00000F5C B700                <1> 	mov	bh,0			; BX = drive number
  1861 00000F5E 38AF9400            <1> 	cmp	byte [fdc_cylinder+bx],ch
  1862 00000F62 5B                  <1> 	pop	bx
  1863 00000F63 C3                  <1> 	ret
  1864                              <1> 
  1865                              <1> ;=========================================================================
  1866                              <1> ; set_cylinder - Store drive's current cylinder into the BIOS data area
  1867                              <1> ; Input:
  1868                              <1> ;	CH = current cylinder
  1869                              <1> ;	[BP+int_13_dl] = drive number
  1870                              <1> ; Output:
  1871                              <1> ;	none
  1872                              <1> ;-------------------------------------------------------------------------
  1873                              <1> set_cylinder:
  1874 00000F64 53                  <1> 	push	bx
  1875 00000F65 8A5E08              <1> 	mov	bl,byte [bp+int_13_dl]
  1876 00000F68 B700                <1> 	mov	bh,0			; BX = drive number
  1877 00000F6A 88AF9400            <1> 	mov	byte [fdc_cylinder+bx],ch
  1878 00000F6E 5B                  <1> 	pop	bx
  1879 00000F6F C3                  <1> 	ret
  1880                              <1> 
  1881                              <1> ;=========================================================================
  1882                              <1> ; check_drive_calibrated - Check if the drive calibrated bit is set
  1883                              <1> ;			   in the BIOS data area
  1884                              <1> ; Input:
  1885                              <1> ;	[BP+int_13_dl] = drive number
  1886                              <1> ; Output:
  1887                              <1> ;	CF = 1 - bit set (drive calibrated)
  1888                              <1> ;-------------------------------------------------------------------------
  1889                              <1> check_drive_calibrated:
  1890 00000F70 51                  <1> 	push	cx
  1891 00000F71 8A2E3E00            <1> 	mov	ch,byte [fdc_calib_state] ; calibration state for primary FDC
  1892 00000F75 8A4E08              <1> 	mov	cl,byte [bp+int_13_dl]	; CL = drive number
  1893 00000F78 FEC1                <1> 	inc	cl
  1894 00000F7A D2ED                <1> 	shr	ch,cl			; set CF if drive is calibrated
  1895 00000F7C 59                  <1> 	pop	cx
  1896 00000F7D C3                  <1> 	ret
  1897                              <1> 
  1898                              <1> ;=========================================================================
  1899                              <1> ; set_drive_calibrated - Set drive calibrated bit in the BIOS data area
  1900                              <1> ; Input:
  1901                              <1> ;	[BP+int_13_dl] = drive number
  1902                              <1> ; Output:
  1903                              <1> ;	none
  1904                              <1> ;-------------------------------------------------------------------------
  1905                              <1> set_drive_calibrated:
  1906 00000F7E 51                  <1> 	push	cx
  1907 00000F7F 8A4E08              <1> 	mov	cl,byte [bp+int_13_dl]	; CL = drive number
  1908 00000F82 B501                <1> 	mov	ch,1			; bit 0 set
  1909 00000F84 D2E5                <1> 	shl	ch,cl			; move it into the right position
  1910 00000F86 082E3E00            <1> 	or	byte [fdc_calib_state],ch ; set the bit for the primary FDC
  1911 00000F8A 59                  <1> 	pop	cx
  1912 00000F8B C3                  <1> 	ret
  1913                              <1> 
  1914                              <1> ;=========================================================================
  1915                              <1> ; detect_floppy - Detect floppy configuration
  1916                              <1> ;                 set equipment bits accordingly
  1917                              <1> ; Input:
  1918                              <1> ;	none
  1919                              <1> ; Ouput:
  1920                              <1> ;	AL = NVRAM floppy configuration byte
  1921                              <1> ;-------------------------------------------------------------------------
  1922                              <1> detect_floppy:
  1923                              <1> %ifdef BIOS_SETUP
  1924                              <1> 	call	get_floppy
  1925                              <1> %else ; BIOS_SETUP
  1926 00000F8C B044                <1> 	mov	al,44h			; FIXME: fake two 1.44MB floppy drives
  1927                              <1> %endif ; BIOS_SETUP
  1928 00000F8E 3C00                <1> 	cmp	al,00h			; No floppy drives?
  1929 00000F90 740E                <1> 	je	.exit
  1930 00000F92 800E100001          <1> 	or	byte [equipment_list],equip_floppies
  1931 00000F97 A80F                <1> 	test	al,0Fh			; Second floppy drive installed?
  1932 00000F99 7405                <1> 	jz	.exit
  1933 00000F9B 800E100040          <1> 	or	byte [equipment_list],equip_floppy2
  1934                              <1> .exit:
  1935 00000FA0 C3                  <1> 	ret
  1936                              <1> 
  1937                              <1> ;=========================================================================
  1938                              <1> ; get_drive_type - Read drive type from NVRAM or Flash ROM configuration
  1939                              <1> ; Input:
  1940                              <1> ;	DL = drive number (0 or 1)
  1941                              <1> ; Output:
  1942                              <1> ;	CF clear if successful
  1943                              <1> ;		AL = drive type
  1944                              <1> ;	CF set on error (invalid drive type)
  1945                              <1> ;=========================================================================
  1946                              <1> 
  1947                              <1> get_drive_type:
  1948                              <1> %ifdef BIOS_SETUP
  1949                              <1> 	call	get_floppy
  1950                              <1> %else ; BIOS_SETUP
  1951 00000FA1 B044                <1> 	mov	al,44h			; FIXME: fake two 1.44MB floppy drives
  1952                              <1> %endif ; BIOS_SETUP
  1953 00000FA3 08D2                <1> 	or	dl,dl			; drive 0?
  1954 00000FA5 7508                <1> 	jnz	.drive_1		; jump if drive 1 - type in bits 3-0
  1955 00000FA7 D0E8                <1> 	shr	al,1			; shift drive 0 bits 7-4 to 3-0
  1956 00000FA9 D0E8                <1> 	shr	al,1
  1957 00000FAB D0E8                <1> 	shr	al,1
  1958 00000FAD D0E8                <1> 	shr	al,1
  1959                              <1> .drive_1:
  1960 00000FAF 240F                <1> 	and	al,0Fh			; mask drive bits
  1961 00000FB1 3C00                <1> 	cmp	al,type_none
  1962 00000FB3 740A                <1> 	je	.error
  1963 00000FB5 3C05                <1> 	cmp	al,5			; invalid value
  1964 00000FB7 7406                <1> 	je	.error
  1965 00000FB9 3C06                <1> 	cmp	al,type_2880
  1966 00000FBB 7702                <1> 	ja	.error
  1967 00000FBD F8                  <1> 	clc
  1968 00000FBE C3                  <1> 	ret
  1969                              <1> 
  1970                              <1> .error:
  1971 00000FBF F9                  <1> 	stc
  1972 00000FC0 C3                  <1> 	ret
  1973                              <1> 
  1974                              <1> ;=========================================================================
  1975                              <1> ; print_floppy - Print floppy configuration
  1976                              <1> ; Input:
  1977                              <1> ;	AL = NVRAM floppy configuration byte
  1978                              <1> ; Ouput:
  1979                              <1> ;	none
  1980                              <1> ;-------------------------------------------------------------------------
  1981                              <1> print_floppy:
  1982 00000FC1 50                  <1> 	push	ax
  1983 00000FC2 56                  <1> 	push	si
  1984 00000FC3 BE[4402]            <1> 	mov	si,msg_floppy
  1985 00000FC6 E8CA07              <1> 	call	print
  1986 00000FC9 D0C8                <1> 	ror	al,1
  1987 00000FCB D0C8                <1> 	ror	al,1
  1988 00000FCD D0C8                <1> 	ror	al,1
  1989 00000FCF D0C8                <1> 	ror	al,1
  1990 00000FD1 89C6                <1> 	mov	si,ax
  1991 00000FD3 83E607              <1> 	and	si,0007h
  1992 00000FD6 D1E6                <1> 	shl	si,1
  1993 00000FD8 2E8BB4[F403]        <1>     cs	mov	si,word [tbl_floppy+si]
  1994 00000FDD E8B307              <1> 	call	print
  1995 00000FE0 BE[6A02]            <1> 	mov	si,msg_floppy_2
  1996 00000FE3 E8AD07              <1> 	call	print
  1997 00000FE6 D0C8                <1> 	ror	al,1
  1998 00000FE8 D0C8                <1> 	ror	al,1
  1999 00000FEA D0C8                <1> 	ror	al,1
  2000 00000FEC D0C8                <1> 	ror	al,1
  2001 00000FEE 89C6                <1> 	mov	si,ax
  2002 00000FF0 83E607              <1> 	and	si,0007h
  2003 00000FF3 D1E6                <1> 	shl	si,1
  2004 00000FF5 2E8BB4[F403]        <1>     cs	mov	si,word [tbl_floppy+si]
  2005 00000FFA E89607              <1> 	call	print
  2006 00000FFD BE[8900]            <1> 	mov	si,msg_crlf
  2007 00001000 E89007              <1> 	call	print
  2008 00001003 5E                  <1> 	pop	si
  2009 00001004 58                  <1> 	pop	ax
  2010 00001005 C3                  <1> 	ret
   271                                  %ifdef AT_KEYBOARD
   272                                  %include	"at_kbc.inc"		; keyboard controller functions
   273                                  %endif ; AT_KEYBOARD
   274                                  %include	"scancode.inc"		; keyboard scancodes translation func.
   275                              <1> ;=========================================================================
   276                              <1> ; scancode.inc - Keyboard scancode to ASCII code conversion
   277                              <1> ;		 and related INT 16h functions:
   278                              <1> ;	INT 16h - BIOS Keyboard Services
   279                              <1> ;		- function AH=00h
   280                              <1> ;		- function AH=01h
   281                              <1> ;		- function AH=10h
   282                              <1> ;		- function AH=11h
   283                              <1> ;-------------------------------------------------------------------------
   284                              <1> ;
   285                              <1> ; Compiles with NASM 2.13.02, might work with other versions
   286                              <1> ;
   287                              <1> ; Copyright (C) 2010 - 2023 Sergey Kiselev.
   288                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
   289                              <1> ;
   290                              <1> ; This program is free software: you can redistribute it and/or modify
   291                              <1> ; it under the terms of the GNU General Public License as published by
   292                              <1> ; the Free Software Foundation, either version 3 of the License, or
   293                              <1> ; (at your option) any later version.
   294                              <1> ;
   295                              <1> ; This program is distributed in the hope that it will be useful,
   296                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   297                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   298                              <1> ; GNU General Public License for more details.
   299                              <1> ;
   300                              <1> ; You should have received a copy of the GNU General Public License
   301                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   302                              <1> ;
   303                              <1> ;=========================================================================
   304                              <1> 
   305                              <1> ;=========================================================================
   306                              <1> ; scan_xlat_table - Keyboard scan code to ASCII and
   307                              <1> ;                   BIOS scan code translation table
   308                              <1> ; Note 1: Table starts with scancode == 1
   309                              <1> ; Note 2: The high byte of the 'Normal' field indicates key flags
   310                              <1> ;	00 - no flags
   311                              <1> ;	1x - keypad numeric keys, can be used with Alt to enter ASCII codes
   312                              <1> ;	     x in this case equals digit value
   313                              <1> ;	20 - key is affected by Caps Log or Num Lock (reverses Shift operation)
   314                              <1> ;	40 - there is an extended key, so check for 0E0h flag
   315                              <1> ;	8x - F11, F12 BIOS scan codes
   316                              <1> ;	     (observation: for all other keys BIOS scan code == kbd scan code)
   317                              <1> ;-------------------------------------------------------------------------
   318                              <1> 
   319                              <1> scan_xlat_table:
   320                              <1> ;		Normal	Shift	Ctrl	Alt	Key	KeySh	Scan
   321 00001006 1B001B011B01F001    <1> 	dw	001Bh,	011Bh,	011Bh,	01F0h	; Esc		01h
   322 0000100E 3100210200000078    <1> 	dw	0031h,	0221h,	0,	7800h	; 1	!	02h
   323 00001016 3200400300030079    <1> 	dw	0032h,	0340h,	0300h,	7900h	; 2	@	03h
   324 0000101E 330023040000007A    <1> 	dw	0033h,	0423h,	0,	7A00h	; 3	#	04h
   325 00001026 340024050000007B    <1> 	dw	0034h,	0524h,	0,	7B00h	; 4	$	05h
   326 0000102E 350025060000007C    <1> 	dw	0035h,	0625h,	0,	7C00h	; 5	%	06h
   327 00001036 36005E071E07007D    <1> 	dw	0036h,	075Eh,	071Eh,	7D00h	; 6	^	07h
   328 0000103E 370026080000007E    <1> 	dw	0037h,	0826h,	0,	7E00h	; 7	&	08h
   329 00001046 38002A090000007F    <1> 	dw	0038h,	092Ah,	0,	7F00h	; 8	*	09h
   330 0000104E 3900280A00000080    <1> 	dw	0039h,	0A28h,	0,	8000h	; 9	(	0Ah
   331 00001056 3000290B00000081    <1> 	dw	0030h,	0B29h,	0,	8100h	; 0	)	0Bh
   332 0000105E 2D005F0C1F0C0082    <1> 	dw	002Dh,	0C5Fh,	0C1Fh,	8200h	; -	_	0Ch
   333 00001066 3D002B0D00000083    <1> 	dw	003Dh,	0D2Bh,	0,	8300h	; =	+	0Dh
   334 0000106E 0800080E7F0EF00E    <1> 	dw	0008h,	0E08h,	0E7Fh,	0EF0h	; Back Space	0Eh
   335 00001076 0900000F009400A5    <1> 	dw	0009h,	0F00h,	9400h,	0A500h	; Tab		0Fh
   336 0000107E 7120511011100010    <1> 	dw	2071h,	1051h,	1011h,	1000h	; q	Q	10h
   337                              <1> ;		Normal	Shift	Ctrl	Alt	Key	KeySh	Scan
   338 00001086 7720571117110011    <1> 	dw	2077h,	1157h,	1117h,	1100h	; w	W	11h
   339 0000108E 6520451205120012    <1> 	dw	2065h,	1245h,	1205h,	1200h	; e	E	12h
   340 00001096 7220521312130013    <1> 	dw	2072h,	1352h,	1312h,	1300h	; r	R	13h
   341 0000109E 7420541414140014    <1> 	dw	2074h,	1454h,	1414h,	1400h	; t	T	14h
   342 000010A6 7920591519150015    <1> 	dw	2079h,	1559h,	1519h,	1500h	; y	Y	15h
   343 000010AE 7520551615160016    <1> 	dw	2075h,	1655h,	1615h,	1600h	; u	U	16h
   344 000010B6 6920491709170017    <1> 	dw	2069h,	1749h,	1709h,	1700h	; i	I	17h
   345 000010BE 6F204F180F180018    <1> 	dw	206Fh,	184Fh,	180Fh,	1800h	; o	O	18h
   346 000010C6 7020501910190019    <1> 	dw	2070h,	1950h,	1910h,	1900h	; p	P	19h
   347 000010CE 5B007B1A1B1AF01A    <1> 	dw	005Bh,	1A7Bh,	1A1Bh,	1AF0h	; [	{	1Ah
   348 000010D6 5D007D1B1D1BF01B    <1> 	dw	005Dh,	1B7Dh,	1B1Dh,	1BF0h	; ]	}	1Bh
   349 000010DE 0D400D1C0A1CF01C    <1> 	dw	400Dh,	1C0Dh,	1C0Ah,	1CF0h	; Enter		1Ch
   350 000010E6 0000000000000000    <1> 	dw	0,	0,	0,	0,	; Ctrl		1Dh
   351 000010EE 6120411E011E001E    <1> 	dw	2061h,	1E41h,	1E01h,	1E00h	; a	A	1Eh
   352 000010F6 7320531F131F001F    <1> 	dw	2073h,	1F53h,	1F13h,	1F00h	; s	S	1Fh
   353 000010FE 6420442004200020    <1> 	dw	2064h,	2044h,	2004h,	2000h	; d	D	20h
   354                              <1> ;		Normal	Shift	Ctrl	Alt	Key	KeySh	Scan
   355 00001106 6620462106210021    <1> 	dw	2066h,	2146h,	2106h,	2100h	; f	F	21h
   356 0000110E 6720472207220022    <1> 	dw	2067h,	2247h,	2207h,	2200h	; g	G	22h
   357 00001116 6820482308230023    <1> 	dw	2068h,	2348h,	2308h,	2300h	; h	H	23h
   358 0000111E 6A204A240A240024    <1> 	dw	206Ah,	244Ah,	240Ah,	2400h	; j	J	24h
   359 00001126 6B204B250B250025    <1> 	dw	206Bh,	254Bh,	250Bh,	2500h	; k	K	25h
   360 0000112E 6C204C260C260026    <1> 	dw	206Ch,	264Ch,	260Ch,	2600h	; l	L	26h
   361 00001136 3B003A270000F027    <1> 	dw	003Bh,	273Ah,	0,	27F0h	; ;	:	27h
   362 0000113E 270022280000F028    <1> 	dw	0027h,	2822h,	0,	28F0h	; '	"	28h
   363 00001146 60007E290000F029    <1> 	dw	0060h,	297Eh,	0,	29F0h	; `	~	29h
   364 0000114E 0000000000000000    <1> 	dw	0,	0,	0,	0	; Left Shift	2Ah
   365 00001156 5C007C2B1C2BF02B    <1> 	dw	005Ch,	2B7Ch,	2B1Ch,	2BF0h	; \	|	2Bh
   366 0000115E 7A205A2C1A2C002C    <1> 	dw	207Ah,	2C5Ah,	2C1Ah,	2C00h	; z	Z	2Ch
   367 00001166 7820582D182D002D    <1> 	dw	2078h,	2D58h,	2D18h,	2D00h	; x	X	2Dh
   368 0000116E 6320432E032E002E    <1> 	dw	2063h,	2E43h,	2E03h,	2E00h	; c	C	2Eh
   369 00001176 7620562F162F002F    <1> 	dw	2076h,	2F56h,	2F16h,	2F00h	; v	V	2Fh
   370 0000117E 6220423002300030    <1> 	dw	2062h,	3042h,	3002h,	3000h	; b	B	30h
   371                              <1> ;		Normal	Shift	Ctrl	Alt	Key	KeySh	Scan
   372 00001186 6E204E310E310031    <1> 	dw	206Eh,	314Eh,	310Eh,	3100h	; n	N	31h
   373 0000118E 6D204D320D320032    <1> 	dw	206Dh,	324Dh,	320Dh,	3200h	; m	M	32h
   374 00001196 2C003C330000F033    <1> 	dw	002Ch,	333Ch,	0,	33F0h	; ,	<	33h
   375 0000119E 2E003E340000F034    <1> 	dw	002Eh,	343Eh,	0,	34F0h	; .	>	34h
   376 000011A6 2F603F350000F035    <1> 	dw	602Fh,	353Fh,	0,	35F0h	; /	?	35h
   377 000011AE 0000000000000000    <1> 	dw	0,	0,	0,	0	; Right Shift	36h
   378 000011B6 2A6000000096F037    <1> 	dw	602Ah,	0,	9600h,	37F0h	; *	PrtSc	37h
   379 000011BE 0000000000000000    <1> 	dw	0,	0,	0,	0	; Alt		38h
   380 000011C6 2000203920392039    <1> 	dw	0020h,	3920h,	3920h,	3920h	; Space		39h
   381 000011CE 0000000000000000    <1> 	dw	0,	0,	0,	0	; Caps Lock	3Ah
   382 000011D6 00000054005E0068    <1> 	dw	0000h,	5400h,	5E00h,	6800h	; F1		3Bh
   383 000011DE 00000055005F0069    <1> 	dw	0000h,	5500h,	5F00h,	6900h	; F2		3Ch
   384 000011E6 000000560060006A    <1> 	dw	0000h,	5600h,	6000h,	6A00h	; F3		3Dh
   385 000011EE 000000570061006B    <1> 	dw	0000h,	5700h,	6100h,	6B00h	; F4		3Eh
   386 000011F6 000000580062006C    <1> 	dw	0000h,	5800h,	6200h,	6C00h	; F5		3Fh
   387 000011FE 000000590063006D    <1> 	dw	0000h,	5900h,	6300h,	6D00h	; F6		40h
   388                              <1> ;		Normal	Shift	Ctrl	Alt	Key	KeySh	Scan
   389 00001206 0000005A0064006E    <1> 	dw	0000h,	5A00h,	6400h,	6E00h	; F7		41h
   390 0000120E 0000005B0065006F    <1> 	dw	0000h,	5B00h,	6500h,	6F00h	; F8		42h
   391 00001216 0000005C00660070    <1> 	dw	0000h,	5C00h,	6600h,	7000h	; F9		43h
   392 0000121E 0000005D00670071    <1> 	dw	0000h,	5D00h,	6700h,	7100h	; F10		44h
   393 00001226 0000000000000000    <1> 	dw	0,	0,	0,	0	; Num Lock	45h
   394 0000122E 0000000000000000    <1> 	dw	0,	0,	0,	0	; Scroll Lock	46h
   395 00001236 0077374700770097    <1> 	dw	7700h,	4737h,	7700h,	9700h	; Home	7	47h
   396 0000123E 00783848008D0098    <1> 	dw	7800h,	4838h,	8D00h,	9800h	; Up 	8	48h
   397 00001246 0079394900840099    <1> 	dw	7900h,	4939h,	8400h,	9900h	; PgUp	9	49h
   398 0000124E 2D002D4A008EF04A    <1> 	dw	002Dh,	4A2Dh,	8E00h,	4AF0h	; Gray -	4Ah
   399 00001256 0074344B0073009B    <1> 	dw	7400h,	4B34h,	7300h,	9B00h	; Left	4	4Bh
   400 0000125E F075354C008FF04C    <1> 	dw	75F0h,	4C35h,	8F00h,	4CF0h	; Center5	4Ch
   401 00001266 0076364D0074009D    <1> 	dw	7600h,	4D36h,	7400h,	9D00h	; Right	6 	4Dh
   402 0000126E 2B002B4E0090F04E    <1> 	dw	002Bh,	4E2Bh,	9000h,	4EF0h	; Gray +	4Eh
   403 00001276 0071314F0075009F    <1> 	dw	7100h,	4F31h,	7500h,	9F00h	; End	1	4Fh
   404 0000127E 00723250009100A0    <1> 	dw	7200h,	5032h,	9100h,	0A000h	; Down	2	50h
   405                              <1> ;		Normal	Shift	Ctrl	Alt	Key		Scan
   406 00001286 00733351007600A1    <1> 	dw	7300h,	5133h,	7600h,	0A100h	; PgDn	3	51h
   407 0000128E 00703052009200A2    <1> 	dw	7000h,	5230h,	9200h,	0A200h	; Ins	0	52h
   408 00001296 00602E53009300A3    <1> 	dw	6000h,	532Eh,	9300h,	0A300h	; Del	.	53h
   409 0000129E 0000000000000000    <1> 	dw	0,	0,	0,	0	; SysRq		54h
   410 000012A6 0000000000000000    <1> 	dw	0,	0,	0,	0	; NoKey		55h
   411 000012AE 0000000000000000    <1> 	dw	0,	0,	0,	0	; NoKey		56h
   412 000012B6 008500870089008B    <1> 	dw	8500h,	8700h,	8900h,	8B00h	; F11		57h
   413 000012BE 00860088008A008C    <1> 	dw	8600h,	8800h,	8A00h,	8C00h	; F12		58h
   414                              <1> .end:
   415                              <1> scan_xlat_table_size equ (.end-scan_xlat_table)/8
   416                              <1> 
   417                              <1> ;=========================================================================
   418                              <1> ; scan_xlat - Translate scan code to ASCII character / scan code pair
   419                              <1> ; Input:
   420                              <1> ;	AL - scan code
   421                              <1> ; Output:
   422                              <1> ;	AX - ASCII character / scan code pair
   423                              <1> ;-------------------------------------------------------------------------
   424                              <1> scan_xlat:
   425 000012C6 53                  <1> 	push	bx
   426 000012C7 FEC8                <1> 	dec	al
   427 000012C9 3C58                <1> 	cmp	al,scan_xlat_table_size
   428 000012CB 7205                <1> 	jb	.1
   429 000012CD 31C0                <1> 	xor	ax,ax
   430 000012CF E9AB00              <1> 	jmp	.exit
   431                              <1> 
   432                              <1> .1:
   433 000012D2 B700                <1> 	mov	bh,00h				; calculate offset of the key
   434 000012D4 88C3                <1> 	mov	bl,al				; in scan_xlat_table
   435 000012D6 D1E3                <1> 	shl	bx,1				; BX = AL * 8
   436 000012D8 D1E3                <1> 	shl	bx,1
   437 000012DA D1E3                <1> 	shl	bx,1
   438                              <1> 
   439 000012DC F606170008          <1> 	test	byte [kbd_flags_1],kbd_alt_bit	; is the Alt key pressed?
   440 000012E1 7428                <1> 	jz	.check_ctrl			; Alt key is not pressed
   441 000012E3 2E8B87[0C10]        <1>     cs	mov	ax,word [scan_xlat_table+6+bx]	; Alt codes are in 4th column
   442                              <1> 	; check for numeric Keypad keys
   443 000012E8 2EF687[0710]10      <1>     cs  test	byte [scan_xlat_table+1+bx],10h ; keypad?
   444 000012EE 7474                <1> 	jz	.check_extended
   445 000012F0 F606960002          <1> 	test	byte [kbd_flags_3],10b		; previous scan code was 0E0h?
   446 000012F5 756D                <1> 	jnz	.check_extended			; ... yes, it is a 0E0h
   447                              <1> 						; and so it is not a keypad key
   448                              <1> 
   449 000012F7 2E8A87[0710]        <1>     cs	mov	al,byte [scan_xlat_table+1+bx]
   450 000012FC 240F                <1> 	and	al,0Fh				; get the numeric value
   451 000012FE 8A261900            <1> 	mov	ah,byte [kbd_alt_keypad]	; load value from work area
   452 00001302 D50A                <1> 	aad	0Ah				; AL = AH * 10 + AL
   453 00001304 A21900              <1> 	mov	byte [kbd_alt_keypad],al	; store it back to the work area
   454                              <1> 
   455 00001307 31C0                <1> 	xor	ax,ax				; return nothing
   456 00001309 EB72                <1> 	jmp	.exit
   457                              <1> 
   458                              <1> .check_ctrl:
   459 0000130B F606170004          <1> 	test	byte [kbd_flags_1],kbd_ctrl_bit	; is the Ctrl key pressed?
   460 00001310 7407                <1> 	jz	.check_locks			; Ctrl key is not pressed
   461 00001312 2E8B87[0A10]        <1>     cs	mov	ax,word [scan_xlat_table+4+bx]	; Ctrl codes are in 3rd column
   462 00001317 EB4B                <1> 	jmp	.check_extended
   463                              <1> 
   464                              <1> .check_locks:
   465 00001319 2EF687[0710]20      <1>     cs	test	byte [scan_xlat_table+1+bx],20h	; is this key affected by Locks?
   466 0000131F 741D                <1> 	jz	.check_shift			; not affected by Locks
   467                              <1> 
   468 00001321 3C46                <1> 	cmp	al,46h				; Num Lock affects scancodes
   469 00001323 7309                <1> 	jae	.check_num_lock			; above or equal 47h
   470                              <1> 
   471 00001325 F606170040          <1> 	test	byte [kbd_flags_1],kbd_caps_bit	; is Caps Lock active?
   472 0000132A 7412                <1> 	jz	.check_shift			; Caps Lock is not active
   473 0000132C EB07                <1> 	jmp	.lock_active
   474                              <1> 
   475                              <1> .check_num_lock:
   476 0000132E F606170020          <1> 	test    byte [kbd_flags_1],kbd_num_bit	; is Num Lock active?
   477 00001333 7409                <1> 	jz	.check_shift			; Num Lock is not active
   478                              <1> .lock_active:
   479                              <1> 	; are any of Shift keys active?
   480 00001335 F606170003          <1> 	test	byte [kbd_flags_1],kbd_lshft_bit|kbd_rshft_bit
   481 0000133A 7409                <1> 	jz	.shift				; Lock active, Shift inactive
   482 0000133C EB0E                <1> 	jmp	.no_shift			; Lock active, Shift active
   483                              <1> 
   484                              <1> .check_shift:
   485                              <1> 	; are any of Shift keys active?
   486 0000133E F606170003          <1> 	test	byte [kbd_flags_1],kbd_lshft_bit|kbd_rshft_bit
   487 00001343 7407                <1> 	jz	.no_shift
   488                              <1> .shift:
   489 00001345 2E8B87[0810]        <1>     cs	mov	ax,word [scan_xlat_table+2+bx]	; Shift codes are in 2nd column
   490 0000134A EB18                <1> 	jmp	.check_extended
   491                              <1> 
   492                              <1> .no_shift:
   493 0000134C 88C4                <1> 	mov	ah,al				; Move scan code to AH
   494 0000134E FEC4                <1> 	inc	ah
   495 00001350 2E8A87[0610]        <1>     cs	mov	al,byte [scan_xlat_table+bx]	; Normal codes are in 1st column
   496 00001355 2EF687[0710]80      <1>     cs	test	byte [scan_xlat_table+1+bx],80h	; F11 or F12?
   497 0000135B 7407                <1> 	jz	.check_extended			; not F11 or F12
   498 0000135D 2E8AA7[0710]        <1>     cs  mov	ah,byte [scan_xlat_table+bx+1]	; Load scan code for F11 or F12
   499 00001362 EB19                <1> 	jmp	.exit
   500                              <1> 
   501                              <1> .check_extended:
   502 00001364 2EF687[0710]40      <1>    cs	test	byte [scan_xlat_table+1+bx],40h	; have an extended key?
   503 0000136A 7411                <1> 	jz	.exit				; no extended key
   504 0000136C F606960002          <1> 	test	byte [kbd_flags_3],10b		; previous scan code was 0E0h?
   505 00001371 740A                <1> 	jz	.exit				; ... not a 0E0h
   506 00001373 3C00                <1> 	cmp	al,00h
   507 00001375 7504                <1> 	jnz	.ascii_code			; key has an ASCII code
   508 00001377 B0E0                <1> 	mov	al,0E0h				; indicate extended key
   509 00001379 EB02                <1> 	jmp	.exit
   510                              <1> 
   511                              <1> .ascii_code:
   512 0000137B B4E0                <1> 	mov	ah,0E0h				; indicate extended key for a
   513                              <1> 						; key with valid ASCII code
   514                              <1> 						; (Keypad Enter, *, and /)
   515                              <1> 
   516                              <1> .exit:
   517 0000137D 5B                  <1> 	pop	bx
   518 0000137E C3                  <1> 	ret
   519                              <1> 
   520                              <1> ;=========================================================================
   521                              <1> ; int_16_fn00 - get keystroke
   522                              <1> ; Input:
   523                              <1> ;	AH = 00h
   524                              <1> ; Output:
   525                              <1> ;	AH = BIOS scan code
   526                              <1> ;	AL = ASCII character
   527                              <1> ; Notes:
   528                              <1> ;	- Waits for the keystroke if keyboard buffer is empty
   529                              <1> ;	- Converts extended keystrokes (101+ key keyboards) to standard
   530                              <1> ;	  keystrokes, discards extended keystrokes without standard analogs
   531                              <1> ;	- Use function AH=10h for extended keystrokes handling
   532                              <1> ;-------------------------------------------------------------------------
   533                              <1> int_16_fn00:
   534 0000137F FB                  <1> 	sti
   535                              <1> .1:
   536 00001380 8B1E1A00            <1> 	mov	bx,word [kbd_buffer_head]
   537 00001384 3B1E1C00            <1> 	cmp	bx,word [kbd_buffer_tail] ; keystroke available?
   538 00001388 74F6                <1> 	jz	.1			; wait or keystroke
   539 0000138A 8B07                <1> 	mov	ax,word [bx]		; get the keystroke
   540 0000138C 83C302              <1> 	add	bx,2			; move kbd_buffer_head to the next
   541                              <1> 					;   location
   542 0000138F 3B1E8200            <1> 	cmp	bx,word [kbd_buffer_end]
   543 00001393 7504                <1> 	jne	.2
   544 00001395 8B1E8000            <1> 	mov	bx,word [kbd_buffer_start]
   545                              <1> .2:
   546 00001399 891E1A00            <1> 	mov	word [kbd_buffer_head],bx
   547 0000139D 3CE0                <1> 	cmp	al,0E0h			; a convertible (to standard)
   548                              <1> 					;   extended key?
   549 0000139F 7504                <1> 	jne	.3			; not a convertible key
   550 000013A1 B000                <1> 	mov	al,00h			; convert to a standard key
   551 000013A3 EB2C                <1> 	jmp	.exit
   552                              <1> .3:
   553 000013A5 3CF0                <1> 	cmp	al,0F0h			; an ignored extended key?
   554 000013A7 74D7                <1> 	je	.1			; an ignored extended key, get next key
   555 000013A9 80FC84              <1> 	cmp	ah,084h			; an ignored extended key?
   556                              <1> 					;   (scancode above 84h)
   557 000013AC 77D2                <1> 	ja	.1			; an ignored extended key, get next key
   558 000013AE 80FCE0              <1> 	cmp	ah,0E0h			; a convertible ASCII extended key?
   559 000013B1 751E                <1> 	jne	.exit
   560 000013B3 3C0A                <1> 	cmp	al,0Ah			; LF (Ctrl + Keypad Enter)
   561 000013B5 7504                <1> 	jne	.4
   562 000013B7 B41C                <1> 	mov	ah,1Ch			; standard Enter scancode
   563 000013B9 EB16                <1> 	jmp	.exit
   564                              <1> .4:
   565 000013BB 3C0D                <1> 	cmp	al,0Dh			; CR (Keypad Enter)
   566 000013BD 7504                <1> 	jne	.5
   567 000013BF B41C                <1> 	mov	ah,1Ch			; standard Enter scancode
   568 000013C1 EB0E                <1> 	jmp	.exit
   569                              <1> .5:
   570 000013C3 3C2F                <1> 	cmp	al,2Fh			; Keypad /
   571 000013C5 7504                <1> 	jne	.6
   572 000013C7 B435                <1> 	mov	ah,35h			; standard / scancode
   573 000013C9 EB06                <1> 	jmp	.exit
   574                              <1> .6:
   575 000013CB 3C2A                <1> 	cmp	al,2Ah			; Keypad *
   576 000013CD 7502                <1> 	jne	.exit
   577 000013CF B437                <1> 	mov	ah,37h			; standard * scancode
   578                              <1> .exit:
   579 000013D1 E99714              <1> 	jmp	int_16_exit
   580                              <1> 
   581                              <1> ;=========================================================================
   582                              <1> ; int_16_fn01 - check for keystroke
   583                              <1> ; Input:
   584                              <1> ;	AH = 01h
   585                              <1> ; Output:
   586                              <1> ;	ZF = 1 - no keystroke available
   587                              <1> ;	ZF = 0 = keystroke is available and put in AX
   588                              <1> ;		AH = BIOS scan code
   589                              <1> ;		AL = ASCII character
   590                              <1> ; Notes:
   591                              <1> ;	- Does not remove keystroke from keyboard buffer
   592                              <1> ;	- Converts extended keystrokes (101+ key keyboards) to standard
   593                              <1> ;	  keystrokes, discards extended keystrokes without standard analogs
   594                              <1> ;	- Use function AH=11h for extended keystrokes handling
   595                              <1> ;-------------------------------------------------------------------------
   596                              <1> int_16_fn01:
   597 000013D4 8B1E1A00            <1> 	mov	bx,word [kbd_buffer_head]
   598 000013D8 8B07                <1> 	mov	ax,word [bx]
   599 000013DA 3B1E1C00            <1> 	cmp	bx,word [kbd_buffer_tail]
   600 000013DE 7436                <1> 	jz	.exit			; no keystroke, exit
   601 000013E0 3CE0                <1> 	cmp	al,0E0h			; a convertible (to standard)
   602                              <1> 					;   extended key?
   603 000013E2 7504                <1> 	jne	.1			; not a convertible key
   604 000013E4 B000                <1> 	mov	al,00h			; convert to a standard key
   605 000013E6 EB2C                <1> 	jmp	.clear_zf
   606                              <1> .1:
   607 000013E8 3CF0                <1> 	cmp	al,0F0h			; an ignored extended key?
   608 000013EA 742D                <1> 	je	.discard_key		; an ignored extended key, discard
   609 000013EC 80FC84              <1> 	cmp	ah,084h			; an ignored extended key?
   610                              <1> 					;   (scancode above 84h)
   611 000013EF 7728                <1> 	ja	.discard_key		; an ignored extended key, discard
   612 000013F1 80FCE0              <1> 	cmp	ah,0E0h			; a convertible ASCII extended key?
   613 000013F4 751E                <1> 	jne	.clear_zf
   614 000013F6 3C0A                <1> 	cmp	al,0Ah			; LF (Ctrl + Keypad Enter)
   615 000013F8 7504                <1> 	jne	.2
   616 000013FA B41C                <1> 	mov	ah,1Ch			; standard Enter scancode
   617 000013FC EB16                <1> 	jmp	.clear_zf
   618                              <1> .2:
   619 000013FE 3C0D                <1> 	cmp	al,0Dh			; CR (Keypad Enter)
   620 00001400 7504                <1> 	jne	.3
   621 00001402 B41C                <1> 	mov	ah,1Ch			; standard Enter scancode
   622 00001404 EB0E                <1> 	jmp	.clear_zf
   623                              <1> .3:
   624 00001406 3C2F                <1> 	cmp	al,2Fh			; Keypad /
   625 00001408 7504                <1> 	jne	.4
   626 0000140A B435                <1> 	mov	ah,35h			; standard / scancode
   627 0000140C EB06                <1> 	jmp	.clear_zf
   628                              <1> .4:
   629 0000140E 3C2A                <1> 	cmp	al,2Ah			; Keypad *
   630 00001410 7502                <1> 	jne	.clear_zf
   631 00001412 B437                <1> 	mov	ah,37h			; standard * scancode
   632                              <1> 
   633                              <1> .clear_zf:
   634 00001414 09C0                <1> 	or	ax,ax			; clear ZF (AX is always non-zero)
   635                              <1> .exit:
   636 00001416 E95514              <1> 	jmp	int_16_exitf
   637                              <1> 
   638                              <1> .discard_key:
   639 00001419 83C302              <1> 	add	bx,2			; move kbd_buffer_head to the next
   640                              <1> 					;   location
   641 0000141C 3B1E8200            <1> 	cmp	bx,word [kbd_buffer_end]
   642 00001420 7504                <1> 	jne	.5
   643 00001422 8B1E8000            <1> 	mov	bx,word [kbd_buffer_start]
   644                              <1> .5:
   645 00001426 891E1A00            <1> 	mov	word [kbd_buffer_head],bx
   646 0000142A EBA8                <1> 	jmp	int_16_fn01		; check for the next key
   647                              <1> 	
   648                              <1> 
   649                              <1> ;=========================================================================
   650                              <1> ; int_16_fn10 - get extended keystroke
   651                              <1> ; Input:
   652                              <1> ;	AH = 10h
   653                              <1> ; Output:
   654                              <1> ;	AH = BIOS scan code
   655                              <1> ;	AL = ASCII character
   656                              <1> ; Note:
   657                              <1> ;	- Waits for the keystroke if keyboard buffer is empty
   658                              <1> ;-------------------------------------------------------------------------
   659                              <1> int_16_fn10:
   660 0000142C FB                  <1> 	sti
   661                              <1> .1:
   662 0000142D 8B1E1A00            <1> 	mov	bx,word [kbd_buffer_head]
   663 00001431 3B1E1C00            <1> 	cmp	bx,word [kbd_buffer_tail] ; keystroke available?
   664 00001435 74F6                <1> 	jz	.1			; wait or keystroke
   665 00001437 8B07                <1> 	mov	ax,word [bx]		; get the keystroke
   666 00001439 83C302              <1> 	add	bx,2			; move kbd_buffer_head to the next
   667                              <1> 					;   location
   668 0000143C 3B1E8200            <1> 	cmp	bx,word [kbd_buffer_end]
   669 00001440 7504                <1> 	jne	.2
   670 00001442 8B1E8000            <1> 	mov	bx,word [kbd_buffer_start]
   671                              <1> .2:
   672 00001446 891E1A00            <1> 	mov	word [kbd_buffer_head],bx
   673 0000144A 3CF0                <1> 	cmp	al,0F0h			; an extended key?
   674 0000144C 7507                <1> 	jne	.exit			; not an extended key
   675 0000144E 80FC00              <1> 	cmp	ah,00h			; is it Alt + 240 (F0 00)?
   676 00001451 7402                <1> 	je	.exit			; yes it is Alt + 240, return ASCII
   677 00001453 B000                <1> 	mov	al,00h			; set ASCII character to zero
   678                              <1> 
   679                              <1> .exit:
   680 00001455 E91314              <1> 	jmp	int_16_exit
   681                              <1> 
   682                              <1> ;=========================================================================
   683                              <1> ; int_16_fn11 - check for extended keystroke
   684                              <1> ; Input:
   685                              <1> ;	AH = 01h
   686                              <1> ; Output:
   687                              <1> ;	ZF = 1 - no keystroke available
   688                              <1> ;	ZF = 0 = keystroke is available and put in AX
   689                              <1> ;		AH = BIOS scan code
   690                              <1> ;		AL = ASCII character
   691                              <1> ; Note:
   692                              <1> ;	- Does not remove keystroke from keyboard buffer
   693                              <1> ;-------------------------------------------------------------------------
   694                              <1> int_16_fn11:
   695 00001458 8B1E1A00            <1> 	mov	bx,word [kbd_buffer_head]
   696 0000145C 8B07                <1> 	mov	ax,word [bx]
   697 0000145E 3B1E1C00            <1> 	cmp	bx,word [kbd_buffer_tail]
   698 00001462 7408                <1> 	jz	.exit			; no keystroke, exit
   699 00001464 3CF0                <1> 	cmp	al,0F0h			; an extended key?
   700 00001466 7502                <1> 	jne	.clear_zf		; not a extended key
   701 00001468 B000                <1> 	mov	al,00h			; set scancode to zero
   702                              <1> .clear_zf:
   703 0000146A 09C0                <1> 	or	ax,ax			; clear ZF (AX is always non-zero)
   704                              <1> .exit:
   705 0000146C E9FF13              <1> 	jmp	int_16_exitf
   275                                  %include	"serial1.inc"		; serial port services & detection
   276                              <1> ;========================================================================
   277                              <1> ; serial1.inc -  BIOS Serial Port Communication Services (part 1 of 2)
   278                              <1> ;       INT 14h, function AH=01h
   279                              <1> ;	INT 14h, function AH=02h
   280                              <1> ;	detect_serial
   281                              <1> ;	serial port related definitions and tables
   282                              <1> ;	- see serial2.inc for other INT 14h functions
   283                              <1> ;-------------------------------------------------------------------------
   284                              <1> ;
   285                              <1> ; Compiles with NASM 2.13.02, might work with other versions
   286                              <1> ;
   287                              <1> ; Copyright (C) 2010 - 2023 Sergey Kiselev.
   288                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
   289                              <1> ;
   290                              <1> ; This program is free software: you can redistribute it and/or modify
   291                              <1> ; it under the terms of the GNU General Public License as published by
   292                              <1> ; the Free Software Foundation, either version 3 of the License, or
   293                              <1> ; (at your option) any later version.
   294                              <1> ;
   295                              <1> ; This program is distributed in the hope that it will be useful,
   296                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   297                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   298                              <1> ; GNU General Public License for more details.
   299                              <1> ;
   300                              <1> ; You should have received a copy of the GNU General Public License
   301                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   302                              <1> ;
   303                              <1> ;=========================================================================
   304                              <1> 
   305                              <1> uart_osc	equ	1843200		; 1.8432 MHz is the default UART clock
   306                              <1> one_sec_timeout equ	33135		; 30.18 us intervals in one second
   307                              <1> 
   308                              <1> uart_ier_reg	equ	1		; UART Interrupt Enable Register
   309                              <1> 
   310                              <1> uart_lcr_reg	equ	3		; UART Line Control Register
   311                              <1> uart_lcr_ldiv	equ	80h		; LCR - load divisor bit
   312                              <1> uart_lcr_wlen	equ	03h		; LCR - word length bits
   313                              <1> uart_lcr_stop	equ	04h		; LCR - number of stop bits bit
   314                              <1> uart_lcr_pen	equ	08h		; LCR - parity enable bit
   315                              <1> uart_lcr_peven	equ	10h		; LCR - parity even bit
   316                              <1> 
   317                              <1> uart_mcr_reg	equ	4		; UART Modem Control Register
   318                              <1> uart_mcr_dtr	equ	1		; MCR - data terminal ready (DTR)
   319                              <1> uart_mcr_rts	equ	2		; MCR - request to send (RTS)
   320                              <1> 
   321                              <1> uart_lsr_reg	equ	5		; UART Line Status Register
   322                              <1> uart_lsr_dr	equ	1		; LSR - data ready (DR)
   323                              <1> uart_lsr_thre	equ	20h		; LSR - THR empty (THRE)
   324                              <1> 
   325                              <1> uart_msr_reg	equ	6		; UART Modem Status Register
   326                              <1> uart_msr_cts	equ	10h		; MSR - clear to send (CTS)
   327                              <1> uart_msr_dsr	equ	20h		; MSR - data set ready (DSR)
   328                              <1> 
   329                              <1> uart_err_timeout equ	80h		; timeout error
   330                              <1> 
   331                              <1> num_serial	equ	4		; number of serial ports
   332                              <1> 
   333                              <1> ;=========================================================================
   334                              <1> ; int_14_fn01 - Send character
   335                              <1> ; Input:
   336                              <1> ;	AH = 01h - function 01h - send character
   337                              <1> ;	AL = character to send
   338                              <1> ;	DX = serial port number (0-3)
   339                              <1> ; Output:
   340                              <1> ;	AH = line status (see int_14_fn00 for complete description)
   341                              <1> ;-------------------------------------------------------------------------
   342                              <1> int_14_fn01:
   343 0000146F 50                  <1> 	push	ax
   344 00001470 B003                <1> 	mov	al,(uart_mcr_dtr | uart_mcr_rts) ; set DTR and RTS in MCR:
   345                              <1> 					; ready to communicate, request to send
   346 00001472 B730                <1> 	mov	bh,(uart_msr_dsr | uart_msr_cts) ; wait for DSR and CTS in MSR:
   347                              <1> 					; ready to communicate, clear to send
   348 00001474 B320                <1> 	mov	bl,uart_lsr_thre	; and for THRE in LSR:
   349                              <1> 					; UART is ready to accept new character
   350 00001476 E82200              <1> 	call	uart_wait_status
   351 00001479 59                  <1> 	pop	cx
   352 0000147A 7506                <1> 	jnz	int_14_timeout		; timeout, original AL is in CL
   353 0000147C 88C8                <1> 	mov	al,cl
   354 0000147E EE                  <1> 	out	dx,al			; sent the character
   355 0000147F E9E412              <1> 	jmp	int_14_exit
   356                              <1> 
   357                              <1> int_14_timeout:
   358 00001482 88C8                <1> 	mov	al,cl			; original AL saved in CL, restore it
   359 00001484 80CC80              <1> 	or	ah,uart_err_timeout	; set timeout bit
   360 00001487 E9DC12              <1> 	jmp	int_14_exit
   361                              <1> 
   362                              <1> ;=========================================================================
   363                              <1> ; int_14_fn02 - Receive character
   364                              <1> ; Input:
   365                              <1> ;	AH = 02h - function 02h - receive character
   366                              <1> ;	DX = serial port number (0-3)
   367                              <1> ; Output:
   368                              <1> ;	AL = character received
   369                              <1> ;	AH = line status (see int_14_fn00 for complete description)
   370                              <1> ;-------------------------------------------------------------------------
   371                              <1> int_14_fn02:
   372 0000148A 50                  <1> 	push	ax
   373 0000148B B001                <1> 	mov	al,uart_mcr_dtr		; set DTR in MCR:
   374                              <1> 					; ready to communicate
   375 0000148D B720                <1> 	mov	bh,uart_msr_dsr		; wait for DSR in MSR:
   376                              <1> 					; ready to communicate
   377 0000148F B301                <1> 	mov	bl,uart_lsr_dr		; and for DT in LSR:
   378                              <1> 					; UART has received a character
   379 00001491 E80700              <1> 	call	uart_wait_status
   380 00001494 59                  <1> 	pop	cx
   381 00001495 75EB                <1> 	jnz	int_14_timeout
   382 00001497 EC                  <1> 	in	al,dx			; receive the character
   383 00001498 E9CB12              <1> 	jmp	int_14_exit
   384                              <1> 
   385                              <1> ;=========================================================================
   386                              <1> ; uart_wait_status - wait for modem and line status
   387                              <1> ; Input:
   388                              <1> ;	AL = value to write to MCR (Modem Control Register)
   389                              <1> ;	BH = mask to wait for in MSR (Modem Status Register)
   390                              <1> ;	BL = mask to wait for in LSR (Line Status Register)
   391                              <1> ;	DX = UART base address
   392                              <1> ;	SI = address of the timeout value (in seconds)
   393                              <1> ; Output:
   394                              <1> ;	AH = line status
   395                              <1> ;	ZF = 0 - timeout
   396                              <1> ;	CX,BX - destroyed
   397                              <1> ;-------------------------------------------------------------------------
   398                              <1> uart_wait_status:
   399 0000149B 52                  <1> 	push	dx
   400 0000149C 83C204              <1> 	add	dx,uart_mcr_reg		; DX = UART MCR address
   401 0000149F EE                  <1> 	out	dx,al			; output MCR value
   402 000014A0 42                  <1> 	inc	dx
   403 000014A1 42                  <1> 	inc	dx			; DX = UART MSR address
   404                              <1> 					; OPTIMIZATION:
   405                              <1> 					; uart_msr_reg = uart_mcr_reg + 2
   406 000014A2 E80A00              <1> 	call	wait_for_port		; wait for MSR status
   407 000014A5 7506                <1> 	jnz	.wait_exit
   408 000014A7 4A                  <1> 	dec	dx			; DX = UART LSR address
   409                              <1> 					; OPTIMIZATION:
   410                              <1> 					; uart_lsr_reg = uart_msr_reg - 1
   411 000014A8 88DF                <1> 	mov	bh,bl			; BH = LSR mask
   412 000014AA E80200              <1> 	call	wait_for_port		; wait for LSR status
   413                              <1> .wait_exit:
   414 000014AD 5A                  <1> 	pop	dx
   415 000014AE C3                  <1> 	ret
   416                              <1> 
   417                              <1> ;=========================================================================
   418                              <1> ; wait_for_port - wait for set bits in a register
   419                              <1> ;
   420                              <1> ; Input:
   421                              <1> ;	BH = mask to wait for (bits that need to be 1)
   422                              <1> ;	DX = register address
   423                              <1> ;	SI = address of the timeout value (in seconds)
   424                              <1> ; Output:
   425                              <1> ;	AH = last port reading
   426                              <1> ;	ZF clear on timeout
   427                              <1> ;	ZF set on success
   428                              <1> ;	AL - trashed
   429                              <1> ;	CX - trashed
   430                              <1> ;-------------------------------------------------------------------------
   431                              <1> wait_for_port:
   432                              <1> 
   433 000014AF 53                  <1> 	push	bx
   434 000014B0 8A1C                <1> 	mov	bl,byte [SI]		; get the timeout value in seconds
   435                              <1> 
   436                              <1> .loop_outer:
   437 000014B2 B96F81              <1> 	mov	cx,one_sec_timeout	; 30.18 us intervals in one second
   438                              <1> 
   439                              <1> .loop_inner:
   440 000014B5 EC                  <1> 	in	al,dx			; read the register
   441 000014B6 88C4                <1> 	mov	ah,al			; save register in AH
   442 000014B8 20F8                <1> 	and	al,bh
   443 000014BA 38F8                <1> 	cmp	al,bh			; required bits are set?
   444 000014BC 740E                <1> 	je	.exit
   445                              <1> 
   446                              <1> %ifdef AT_DELAY
   447                              <1> 
   448                              <1> .zero_loop:
   449                              <1> 	in	al,ppi_pb_reg
   450                              <1> 	test	al,refresh_flag
   451                              <1> 	jz	.zero_loop		; wait 15.09 us
   452                              <1> 
   453                              <1> .one_loop:
   454                              <1> 	in	al,ppi_pb_reg
   455                              <1> 	test	al,refresh_flag
   456                              <1> 	jnz	.one_loop		; wait 15.09 us
   457                              <1> 
   458                              <1> %else ; AT_DELAY
   459                              <1> 
   460                              <1> 	; wait 30.17 us (Intel 8088 CPU running on 4.77 MHz)
   461 000014BE B008                <1>         mov     al,8
   462                              <1> .delay_loop:
   463 000014C0 FEC8                <1>         dec     al
   464 000014C2 75FC                <1>         jnz     .delay_loop
   465                              <1> 
   466                              <1> %endif ; AT_DELAY
   467                              <1> 
   468 000014C4 E2EF                <1> 	loop	.loop_inner
   469                              <1> 
   470 000014C6 FECB                <1> 	dec	bl
   471 000014C8 75E8                <1> 	jnz	.loop_outer
   472 000014CA 08FF                <1> 	or	bh,bh			; timeout set ZF = 0 (BH != 0)
   473                              <1> 
   474                              <1> .exit:
   475 000014CC 5B                  <1> 	pop	bx
   476 000014CD C3                  <1> 	ret
   477                              <1> 
   478                              <1> ;=========================================================================
   479                              <1> ; detect_serial - detect and print serial ports
   480                              <1> ; Input:
   481                              <1> ;	none
   482                              <1> ; Output:
   483                              <1> ;	none (updates BIOS data area)
   484                              <1> ;-------------------------------------------------------------------------
   485                              <1> detect_serial:
   486 000014CE 50                  <1> 	push	ax
   487 000014CF 53                  <1> 	push	bx
   488 000014D0 52                  <1> 	push	dx
   489 000014D1 56                  <1> 	push	si
   490 000014D2 B024                <1> 	mov	al,e_serial_scan
   491 000014D4 E680                <1> 	out	post_reg,al
   492                              <1> 
   493 000014D6 BE[CE02]            <1> 	mov	si,msg_serial
   494 000014D9 E8B702              <1> 	call	print
   495 000014DC BB0101              <1> 	mov	bx,0101h		; the default timeout is 1 sec
   496 000014DF 891E7C00            <1> 	mov	word [serial_timeout],bx   ; initialize timeout values
   497 000014E3 891E7E00            <1> 	mov	word [serial_timeout+2],bx ; for all 4 ports
   498 000014E7 31DB                <1> 	xor	bx,bx			; BX = 0
   499                              <1> .detect_loop:
   500 000014E9 BE[EB02]            <1> 	mov	si,msg_serial_com
   501 000014EC E8A402              <1> 	call	print
   502 000014EF 88D8                <1> 	mov	al,bl
   503 000014F1 D0E8                <1> 	shr	al,1
   504 000014F3 FEC0                <1> 	inc	al			; AL = COM port number (1..4)
   505 000014F5 E8F902              <1> 	call	print_digit
   506 000014F8 BE[9100]            <1> 	mov	si,msg_colon
   507 000014FB E89502              <1> 	call	print
   508 000014FE 2E8B97[5015]        <1>     cs	mov	dx,word [uart_ier_regs+bx] ; DX = UART IER address
   509 00001503 EC                  <1> 	in	al,dx
   510 00001504 B00F                <1> 	mov	al,0Fh
   511 00001506 EE                  <1> 	out	dx,al			; enable interrupts
   512 00001507 B000                <1> 	mov	al,00h
   513 00001509 E6C0                <1> 	out	unused_reg,al		; clear ISA data bus floating signals
   514 0000150B EC                  <1> 	in	al,dx			; get interrupt enable register to AL
   515 0000150C 3C0F                <1> 	cmp	al,0Fh
   516 0000150E 751C                <1> 	jne	.no_port		; no port at this address
   517 00001510 B000                <1> 	mov	al,00h
   518 00001512 EE                  <1> 	out	dx,al			; disable interrupts
   519 00001513 B0FF                <1> 	mov	al,0FFh
   520 00001515 E6C0                <1> 	out	unused_reg,al		; set ISA data bus floating signals
   521 00001517 EC                  <1> 	in	al,dx			; get interrupt enable register to AL
   522 00001518 3C00                <1> 	cmp	al,00h
   523 0000151A 7510                <1> 	jne	.no_port		; no port at this address
   524 0000151C 4A                  <1> 	dec	dx			; DX = UART base address
   525                              <1> 					; OPTIMIZATION:
   526                              <1> 					; uart_base = uart_ier_reg - 1
   527 0000151D 8917                <1> 	mov	word [equip_serial+bx],dx ; store port address to the BIOS
   528                              <1> 					; data area
   529 0000151F 810610000002        <1> 	add	word [equipment_list],0200h ; increment number of serial ports
   530 00001525 89D0                <1> 	mov	ax,dx
   531 00001527 E88402              <1> 	call	print_hex
   532 0000152A EB0A                <1> 	jmp	.next
   533                              <1> 
   534                              <1> .no_port:
   535 0000152C C7070000            <1> 	mov	word [equip_serial+bx],0 ; no port
   536 00001530 BE[8C00]            <1> 	mov	si,msg_none
   537 00001533 E85D02              <1> 	call	print
   538                              <1> 	
   539                              <1> .next:
   540 00001536 43                  <1> 	inc	bx
   541 00001537 43                  <1> 	inc	bx
   542 00001538 83FB08              <1> 	cmp	bx,(num_serial << 1)	; all serial ports have been scanned?
   543 0000153B 7408                <1> 	je	.done
   544 0000153D BE[9400]            <1> 	mov	si,msg_semicolon
   545 00001540 E85002              <1> 	call	print
   546 00001543 EBA4                <1> 	jmp	.detect_loop
   547                              <1> 
   548                              <1> .done:
   549 00001545 BE[8900]            <1> 	mov	si,msg_crlf
   550 00001548 E84802              <1> 	call	print
   551                              <1> 
   552 0000154B 5E                  <1> 	pop	si
   553 0000154C 5A                  <1> 	pop	dx
   554 0000154D 5B                  <1> 	pop	bx
   555 0000154E 58                  <1> 	pop	ax
   556 0000154F C3                  <1> 	ret
   557                              <1> 
   558                              <1> ;-------------------------------------------------------------------------
   559                              <1> ; serial port Interrupt Enable Register addresses - used for port detection
   560 00001550 F903F902            <1> uart_ier_regs	dw	(3F8h + uart_ier_reg), (2F8h + uart_ier_reg)
   561 00001554 E903E902            <1> 		dw	(3E8h + uart_ier_reg), (2E8h + uart_ier_reg)
   562                              <1> 
   563                              <1> ;-------------------------------------------------------------------------
   564                              <1> ; UART divisor values table
   565 00001558 1704                <1> uart_divisors	dw	uart_osc/16/110		; 110 bps
   566 0000155A 0003                <1> 		dw	uart_osc/16/150		; 150 bps
   567 0000155C 8001                <1> 		dw	uart_osc/16/300		; 300 bps
   568 0000155E C000                <1> 		dw	uart_osc/16/600		; 600 bps
   569 00001560 6000                <1> 		dw	uart_osc/16/1200	; 1200 bps
   570 00001562 3000                <1> 		dw	uart_osc/16/2400	; 2400 bps
   571 00001564 1800                <1> 		dw	uart_osc/16/4800	; 4800 bps
   572 00001566 0C00                <1> 		dw	uart_osc/16/9600	; 9600 bps
   573 00001568 0600                <1> 		dw	uart_osc/16/19200	; 19200 bps
   574 0000156A 0300                <1> 		dw	uart_osc/16/38400	; 38400 bps
   575 0000156C 0200                <1> 		dw	uart_osc/16/57600	; 57600 bps
   576 0000156E 0100                <1> 		dw	uart_osc/16/115200	; 115200 bps
   577                              <1> num_divisors	equ ($-uart_divisors)/2
   276                                  %include	"printer1.inc"		; parallel printer services & detection
   277                              <1> ;========================================================================
   278                              <1> ; printer2.inc - Parallel printer support (part 1 of 2)
   279                              <1> ;	INT 17h, function AH=01h 
   280                              <1> ;	detect_parallel
   281                              <1> ;	- see printer2.inc for other INT 17h functions
   282                              <1> ;-------------------------------------------------------------------------
   283                              <1> ;
   284                              <1> ; Compiles with NASM 2.13.02, might work with other versions
   285                              <1> ;
   286                              <1> ; Copyright (C) 2010 - 2023 Sergey Kiselev.
   287                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
   288                              <1> ;
   289                              <1> ; This program is free software: you can redistribute it and/or modify
   290                              <1> ; it under the terms of the GNU General Public License as published by
   291                              <1> ; the Free Software Foundation, either version 3 of the License, or
   292                              <1> ; (at your option) any later version.
   293                              <1> ;
   294                              <1> ; This program is distributed in the hope that it will be useful,
   295                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   296                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   297                              <1> ; GNU General Public License for more details.
   298                              <1> ;
   299                              <1> ; You should have received a copy of the GNU General Public License
   300                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   301                              <1> ;
   302                              <1> ;=========================================================================
   303                              <1> 
   304                              <1> num_parallel	equ	3		; number of parallel ports
   305                              <1> 
   306                              <1> prn_data_reg	equ	0		; printer data register (out)
   307                              <1> 
   308                              <1> prn_stat_reg	equ	1		; printer status register (in)
   309                              <1> prn_stat_bits	equ	0F8h		; used bits in status register
   310                              <1> prn_stat_invert	equ	048h		; bits 6 and 3 need to be inverted
   311                              <1> prn_stat_busy	equ	80h		; 0 = printer is busy (1 = ready)
   312                              <1> prn_stat_tmout	equ	01h		; 1 = timeout (software error)
   313                              <1> 
   314                              <1> prn_ctrl_reg	equ	2		; printer control register (out)
   315                              <1> prn_ctrl_sel	equ	08h		; 1 = select printer
   316                              <1> prn_ctrl_init	equ	04h		; 0 = initialize printer (1 = normal)
   317                              <1> prn_ctrl_autolf	equ	02h		; 1 = auto linefeed
   318                              <1> prn_ctrl_strobe	equ	01h		; 1 = strobe active
   319                              <1> 
   320                              <1> prn_init_delay	equ	2485		; printer initialization delay, 75 ms
   321                              <1> 
   322                              <1> ;=========================================================================
   323                              <1> ; int_17_fn01 - Initialize printer port
   324                              <1> ; Input:
   325                              <1> ;	AH = 1 - function 01h - initialize printer port
   326                              <1> ;	DX = printer port number (0-2)
   327                              <1> ; Output:
   328                              <1> ;	AH = printer status (see int_17_fn00 for complete description)
   329                              <1> ;-------------------------------------------------------------------------
   330                              <1> int_17_fn01:
   331 00001570 42                  <1> 	inc	dx
   332 00001571 42                  <1> 	inc	dx			; DX = prn_ctrl_reg
   333                              <1> 					; OPTIMIZATION:
   334                              <1> 					; prn_ctrl_reg = prn_data_reg + 2
   335 00001572 B008                <1> 	mov	al,prn_ctrl_sel		; init bit = 0, initialize printer
   336 00001574 EE                  <1> 	out	dx,al
   337 00001575 51                  <1> 	push	cx
   338 00001576 B9B509              <1> 	mov	cx,prn_init_delay
   339 00001579 E888F2              <1> 	call	delay_15us
   340 0000157C 59                  <1> 	pop	cx
   341 0000157D B00C                <1> 	mov	al,(prn_ctrl_sel | prn_ctrl_init)
   342 0000157F EE                  <1> 	out	dx,al			; deactivate init bit
   343 00001580 4A                  <1> 	dec	dx			; OPTIMIZATION:
   344                              <1> 					; prn_stat_reg = prn_ctrl_reg - 1
   345 00001581 E9B51A              <1> 	jmp	int_17_status		; exit returning status
   346                              <1> 
   347                              <1> ;=========================================================================
   348                              <1> ; detect_parallel - detect and print parallel ports
   349                              <1> ; Input:
   350                              <1> ;	none
   351                              <1> ; Output:
   352                              <1> ;	none (updates BIOS data area)
   353                              <1> ; Notes:
   354                              <1> ; 	- If parallel port is found at 3BCh the following parallel port
   355                              <1> ;	  enumeration is used:
   356                              <1> ;	  LPT1 - 3BCh, LPT2 - 378h, LPT3 - 278h
   357                              <1> ;	- If parallel port is not found at 3BCh, the enumeration is:
   358                              <1> ;	  LPT1 - 378h, LPT2 - 278h, LPT3 - none
   359                              <1> ;-------------------------------------------------------------------------
   360                              <1> detect_parallel:
   361 00001584 50                  <1> 	push	ax
   362 00001585 53                  <1> 	push	bx
   363 00001586 52                  <1> 	push	dx
   364 00001587 56                  <1> 	push	si
   365 00001588 B025                <1> 	mov	al,e_parallel_scan
   366 0000158A E680                <1> 	out	post_reg,al
   367                              <1> 
   368 0000158C BB1414              <1> 	mov	bx,1414h		; default timeout is 20 seconds
   369 0000158F 891E7800            <1> 	mov	word [printer_timeout],bx   ; initialize timeout values
   370 00001593 891E7A00            <1> 	mov	word [printer_timeout+2],bx ; for all 4 ports
   371 00001597 31DB                <1> 	xor	bx,bx			; BX = 0
   372 00001599 31FF                <1> 	xor	di,di			; DI = 0
   373                              <1> .detect_loop:
   374 0000159B 2E8B95[1416]        <1>     cs	mov	dx,word [parallel_base+di] ; DX = parallel port address
   375 000015A0 B05A                <1> 	mov	al,05Ah			; just some test value
   376 000015A2 EE                  <1> 	out	dx,al			; write it to the printer data register
   377 000015A3 B0FF                <1> 	mov	al,0FFh
   378 000015A5 E6C0                <1> 	out	unused_reg,al		; set ISA data bus floating signals
   379 000015A7 EC                  <1> 	in	al,dx
   380 000015A8 3C5A                <1> 	cmp	al,05Ah			; compare with the test value
   381 000015AA 750B                <1> 	jne	.no_port		; no port at this address
   382 000015AC 895708              <1> 	mov	word [equip_parallel+bx],dx ; store port address to the BIOS
   383                              <1> 					; data area
   384 000015AF 810610000040        <1> 	add	word [equipment_list],4000h ; increment number of printer ports
   385 000015B5 EB09                <1> 	jmp	.next
   386                              <1> 
   387                              <1> .no_port:
   388 000015B7 C747080000          <1> 	mov	word [equip_parallel+bx],0 ; no port
   389 000015BC 09FF                <1> 	or	di,di			; no printer port at 3BCh?
   390 000015BE 7402                <1> 	jz	.next_skip_3BC		; don't increment LPTx number
   391                              <1> .next:
   392 000015C0 43                  <1> 	inc	bx
   393 000015C1 43                  <1> 	inc	bx
   394                              <1> 
   395                              <1> .next_skip_3BC:
   396 000015C2 47                  <1> 	inc	di
   397 000015C3 47                  <1> 	inc	di
   398 000015C4 83FF06              <1> 	cmp	di,(num_parallel << 1)	; all parallel ports have been scanned?
   399 000015C7 7402                <1> 	je	.print			; done with detection, print findings
   400 000015C9 EBD0                <1> 	jmp	.detect_loop
   401                              <1> 
   402                              <1> .print:
   403 000015CB BE[EF02]            <1> 	mov	si,msg_parallel
   404 000015CE E8C201              <1> 	call	print
   405 000015D1 31DB                <1> 	xor	bx,bx
   406                              <1> 
   407                              <1> .print_loop:
   408 000015D3 BE[0C03]            <1> 	mov	si,msg_parallel_lpt
   409 000015D6 E8BA01              <1> 	call	print
   410 000015D9 88D8                <1> 	mov	al,bl
   411 000015DB D0E8                <1> 	shr	al,1
   412 000015DD FEC0                <1> 	inc	al			; AL = LPT port number (1..3)
   413 000015DF E80F02              <1> 	call	print_digit
   414 000015E2 BE[9100]            <1> 	mov	si,msg_colon
   415 000015E5 E8AB01              <1> 	call	print
   416 000015E8 8B4708              <1> 	mov	ax,word [equip_parallel+bx] ; get parallel port address
   417 000015EB 09C0                <1> 	or	ax,ax			; parallel interface installed?
   418 000015ED 7405                <1> 	jz	.print_no_port
   419 000015EF E8BC01              <1> 	call	print_hex
   420 000015F2 EB06                <1> 	jmp	.print_next
   421                              <1> 
   422                              <1> .print_no_port:
   423 000015F4 BE[8C00]            <1> 	mov	si,msg_none
   424 000015F7 E89901              <1> 	call	print
   425                              <1> 
   426                              <1> .print_next:
   427 000015FA 43                  <1> 	inc	bx
   428 000015FB 43                  <1> 	inc	bx
   429 000015FC 83FB06              <1> 	cmp	bx,(num_parallel << 1)	; all parallel ports have been printed?
   430 000015FF 7408                <1> 	je	.done
   431 00001601 BE[9400]            <1> 	mov	si,msg_semicolon
   432 00001604 E88C01              <1> 	call	print
   433 00001607 EBCA                <1> 	jmp	.print_loop
   434                              <1> 
   435                              <1> .done:
   436 00001609 BE[8900]            <1> 	mov	si,msg_crlf
   437 0000160C E88401              <1> 	call	print
   438                              <1> 
   439 0000160F 5E                  <1> 	pop	si
   440 00001610 5A                  <1> 	pop	dx
   441 00001611 5B                  <1> 	pop	bx
   442 00001612 58                  <1> 	pop	ax
   443 00001613 C3                  <1> 	ret
   444                              <1> 
   445                              <1> ;-------------------------------------------------------------------------
   446                              <1> ; parallel port base addresses - used for port detection
   447 00001614 BC0378037802        <1> parallel_base	dw	3BCh, 378h, 278h
   277                                  %ifdef PS2_MOUSE
   278                                  %ifndef SECOND_PIC
   279                                  %error "PS2_MOUSE depends on SECOND_PIC. Please fix config.inc."
   280                                  %endif ; SECOND_PIC
   281                                  %include	"ps2aux.inc"
   282                                  %endif
   283                                  %include	"sound.inc"		; sound test
   284                              <1> ;=========================================================================
   285                              <1> ; sound.inc - Play power-on sound. This also tests PIT and PORT B functionality
   286                              <1> ;-------------------------------------------------------------------------
   287                              <1> ;
   288                              <1> ; Compiles with NASM 2.13.02, might work with other versions
   289                              <1> ;
   290                              <1> ; Copyright (C) 2010 - 2023 Sergey Kiselev.
   291                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
   292                              <1> ;
   293                              <1> ; This program is free software: you can redistribute it and/or modify
   294                              <1> ; it under the terms of the GNU General Public License as published by
   295                              <1> ; the Free Software Foundation, either version 3 of the License, or
   296                              <1> ; (at your option) any later version.
   297                              <1> ;
   298                              <1> ; This program is distributed in the hope that it will be useful,
   299                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   300                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   301                              <1> ; GNU General Public License for more details.
   302                              <1> ;
   303                              <1> ; You should have received a copy of the GNU General Public License
   304                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   305                              <1> ;
   306                              <1> ;=========================================================================
   307                              <1> 
   308 0000161A 6908                <1> notes	dw	pic_freq/554		; D flat
   309 0000161C FFFF                <1> 	dw	-1			; silent
   310 0000161E D310                <1> 	dw	pic_freq/277		; D flat
   311 00001620 980C                <1> 	dw	pic_freq/370		; G flat
   312 00001622 D310                <1> 	dw	pic_freq/277		; D flat
   313 00001624 3B0B                <1> 	dw	pic_freq/415		; A flat
   314 00001626 0000                <1> 	dw	0
   315                              <1> 
   316                              <1> ;=========================================================================
   317                              <1> ; sound - Play power-on sound.
   318                              <1> ; Input:
   319                              <1> ;	none
   320                              <1> ; Output:
   321                              <1> ;	none, destroys some registers
   322                              <1> ;-------------------------------------------------------------------------
   323                              <1> sound:
   324 00001628 FC                  <1> 	cld
   325 00001629 BE[1A16]            <1> 	mov	si,notes		; set SI to notes table
   326                              <1> 
   327 0000162C B0B6                <1> 	mov	al,0B6h			; set PIC channel 2 to mode 3
   328 0000162E E643                <1> 	out	pit_ctl_reg,al
   329                              <1> 
   330                              <1> .loop:
   331 00001630 2EAD                <1>     cs	lodsw				; load next note to AX
   332 00001632 83F800              <1> 	cmp	ax,0
   333 00001635 741E                <1> 	jz	.exit
   334 00001637 7C0A                <1> 	jl	.silent			; don't turn on speaker if silent note
   335 00001639 E642                <1> 	out	pit_ch2_reg,al		; load divisor's low byte to PIC
   336 0000163B 88E0                <1> 	mov	al,ah
   337 0000163D E642                <1> 	out	pit_ch2_reg,al		; load divisor's high byte to PIC
   338                              <1> 
   339                              <1> %ifndef MACHINE_BOOK8088
   340                              <1> 	in	al,ppi_pb_reg		; read current value of PORT B
   341                              <1>         or      al,03h			; turn on the speaker
   342                              <1> %else ; MACHINE_BOOK8088
   343 0000163F B003                <1>         mov      al,03h			; turn on the speaker
   344                              <1> %endif ; MACHINE_BOOK8088
   345 00001641 E661                <1>         out     ppi_pb_reg,al		; write the new value
   346                              <1> 
   347                              <1> .silent:
   348 00001643 B90030              <1> 	mov	cx,3000h
   349 00001646 E8BBF1              <1> 	call	delay_15us		; delay while note is playing
   350                              <1> 
   351                              <1> %ifndef MACHINE_BOOK8088
   352                              <1> 	in	al,ppi_pb_reg		; read current value of PORT B
   353                              <1> 	and	al,0FCh			; turn off the speaker
   354                              <1> %else ; MACHINE_BOOK8088
   355 00001649 B000                <1> 	mov	al,0			; turn off the speaker
   356                              <1> %endif ; MACHINE_BOOK8088
   357 0000164B E661                <1>         out     ppi_pb_reg,al		; write the new value
   358                              <1> 
   359 0000164D B90001              <1>         mov     cx,0100h
   360 00001650 E8B1F1              <1> 	call	delay_15us		; delay after the note
   361                              <1>         
   362 00001653 EBDB                <1>         jmp     .loop			; play the next note
   363                              <1> .exit:
   364 00001655 C3                  <1> 	ret
   365                              <1> 
   366                              <1> ;=========================================================================
   367                              <1> ; beep - Play a beep sound
   368                              <1> ; Input:
   369                              <1> ;	BL - duration in 0.1 second
   370                              <1> ; Output:
   371                              <1> ;	BL = 0
   372                              <1> ;-------------------------------------------------------------------------
   373                              <1> beep:
   374 00001656 50                  <1> 	push	ax
   375 00001657 B0B6                <1> 	mov	al,0B6h			; set PIC channel 2 to mode 3
   376 00001659 E643                <1> 	out	pit_ctl_reg,al
   377 0000165B B8A904              <1> 	mov	ax,1193			; approximately 1000 Hz
   378 0000165E E642                <1> 	out	pit_ch2_reg,al		; load divisor's low byte to PIC
   379 00001660 88E0                <1> 	mov	al,ah
   380 00001662 E642                <1> 	out	pit_ch2_reg,al		; load divisor's high byte to PIC
   381                              <1> %ifndef MACHINE_BOOK8088
   382                              <1> 	in	al,ppi_pb_reg		; read current value of PORT B
   383                              <1> 	or	al,03h			; turn on the speaker
   384                              <1> %else ; MACHINE_BOOK8088
   385 00001664 B003                <1> 	mov	al,03h			; turn on the speaker
   386                              <1> %endif ; MACHINE_BOOK8088
   387 00001666 E661                <1> 	out	ppi_pb_reg,al		; write the new value
   388                              <1> .loop:
   389 00001668 B90A1A              <1> 	mov	cx,6666			; 0.1 second delay
   390 0000166B E896F1              <1> 	call	delay_15us
   391 0000166E FECB                <1> 	dec	bl
   392 00001670 75F6                <1> 	jnz	.loop
   393                              <1> %ifndef MACHINE_BOOK8088
   394                              <1> 	xor	al,03h			; turn off the speaker
   395                              <1> %else ; MACHINE_BOOK8088
   396 00001672 B000                <1> 	mov	al,0			; turn off the speaker
   397                              <1> %endif ; MACHINE_BOOK8088
   398 00001674 E661                <1> 	out	ppi_pb_reg,al		; write the new value
   399 00001676 58                  <1> 	pop	ax
   400 00001677 C3                  <1> 	ret
   284                                  %include	"cpu.inc"		; CPU and FPU detection
   285                              <1> ;=========================================================================
   286                              <1> ; cpu.inc - Detect and print CPU type and FPU presence
   287                              <1> ;-------------------------------------------------------------------------
   288                              <1> ;
   289                              <1> ; Compiles with NASM 2.13.02, might work with other versions
   290                              <1> ;
   291                              <1> ; Copyright (C) 2010 - 2023 Sergey Kiselev.
   292                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
   293                              <1> ;
   294                              <1> ; This program is free software: you can redistribute it and/or modify
   295                              <1> ; it under the terms of the GNU General Public License as published by
   296                              <1> ; the Free Software Foundation, either version 3 of the License, or
   297                              <1> ; (at your option) any later version.
   298                              <1> ;
   299                              <1> ; This program is distributed in the hope that it will be useful,
   300                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   301                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   302                              <1> ; GNU General Public License for more details.
   303                              <1> ;
   304                              <1> ; You should have received a copy of the GNU General Public License
   305                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   306                              <1> ;
   307                              <1> ;=========================================================================
   308                              <1> 
   309                              <1> flags_tf	equ	0100h		; TF flag - enables single-step
   310                              <1> 
   311                              <1> ;=========================================================================
   312                              <1> ; detect_cpu - detect and print CPU type
   313                              <1> ; Note:
   314                              <1> ;	- Designed to detect 8088, 80C88, and V20 CPU. Likely will return
   315                              <1> ;	  incorrect results if used on other CPU types.
   316                              <1> ;-------------------------------------------------------------------------
   317                              <1> detect_cpu:
   318 00001678 50                  <1> 	push	ax
   319 00001679 56                  <1> 	push	si
   320 0000167A B021                <1> 	mov	al,e_cpu_detect
   321 0000167C E680                <1> 	out	post_reg,al
   322                              <1> 
   323 0000167E BE[C900]            <1> 	mov	si,msg_cpu
   324 00001681 E80F01              <1> 	call	print
   325                              <1> 
   326                              <1> ; test for NEC V20
   327 00001684 B80101              <1> 	mov	ax,0101h
   328 00001687 D510                <1> 	aad	10h			; NEC V20 ignores the argument
   329 00001689 3C0B                <1> 	cmp	al,0Bh			; and always does AL = AL * 0Ah + AH
   330 0000168B 7452                <1> 	je	.nec_v20
   331                              <1> 
   332                              <1> ; not NEC V20, test for various 8088 versions
   333                              <1> .i8088:					; 8088 - NMOS version of 8088
   334 0000168D FA                  <1> 	cli				; disable interrupts
   335 0000168E 1E                  <1> 	push	ds
   336 0000168F 31C0                <1> 	xor	ax,ax
   337 00001691 8ED8                <1> 	mov	ds,ax			; interrupt table segment
   338 00001693 B8[F916]            <1> 	mov	ax,.int_01		; new int 01h offset
   339 00001696 87060400            <1> 	xchg	ax,word [4]		; switch with original int 1 offset
   340 0000169A 50                  <1> 	push	ax			; save to stack
   341 0000169B 8CC8                <1> 	mov	ax,cs			; new int 01h segment
   342 0000169D 87060600            <1> 	xchg	ax,word [6]		; switch with original int 1 segment
   343 000016A1 50                  <1> 	push	ax			; save to stack
   344 000016A2 9C                  <1> 	pushf				; push flags to stack (save)
   345 000016A3 9C                  <1> 	pushf				; push flags to stack (modify)
   346 000016A4 58                  <1> 	pop	ax			; and move them to AX
   347 000016A5 0D0001              <1> 	or	ax,flags_tf		; set TF
   348 000016A8 50                  <1> 	push	ax
   349 000016A9 31C0                <1> 	xor	ax,ax			; AX = 0
   350 000016AB 9D                  <1> 	popf				; load modified value to FLAGS register
   351                              <1> 					; enable single-step
   352 000016AC 90                  <1> 	nop
   353 000016AD 1E                  <1> 	push	ds			; Harris 80C88 disables interrupts
   354                              <1> 					; after PUSH SREG instructions
   355                              <1> .push_sreg:				; and will not single-step to here
   356 000016AE 1F                  <1> 	pop	ds			; 1981 and newer 8088 disable interrupts
   357                              <1> 					; after modifying segment registers
   358                              <1> .pop_sreg:				; and will not single-step to here
   359 000016AF 90                  <1> 	nop
   360 000016B0 9D                  <1> 	popf				; restore original FLAGS, disable
   361                              <1> 					; single-step
   362                              <1> 
   363 000016B1 5E                  <1> 	pop	si			; get original int 01h segment
   364 000016B2 89360600            <1> 	mov	word [6],si		; save it to interrupt table
   365 000016B6 5E                  <1> 	pop	si			; get original int 01h offset
   366 000016B7 89360400            <1> 	mov	word [4],si		; save it to interrupt table
   367 000016BB 1F                  <1> 	pop	ds
   368 000016BC FB                  <1> 	sti				; enable interrupts
   369 000016BD 83F801              <1> 	cmp	ax,0001h		; if AX = 0001h - we have INTEL (C) 1978
   370 000016C0 740D                <1> 	jz	.i8088_78
   371                              <1> 
   372 000016C2 83F802              <1> 	cmp	ax,0002h
   373 000016C5 7410                <1> 	jz	.i8088_81
   374                              <1> 
   375                              <1> .harris:				; Harris / Intersil 80C88
   376 000016C7 BE[9201]            <1> 	mov	si,msg_cpu_harris
   377 000016CA E8C600              <1> 	call	print
   378 000016CD EB16                <1> 	jmp	.cpu_freq
   379                              <1> 
   380                              <1> .i8088_78:
   381 000016CF BE[0301]            <1> 	mov	si,msg_cpu_8088_78
   382 000016D2 E8BE00              <1> 	call	print
   383 000016D5 EB0E                <1> 	jmp	.cpu_freq
   384                              <1> 
   385                              <1> .i8088_81:
   386 000016D7 BE[6301]            <1> 	mov	si,msg_cpu_8088_81
   387 000016DA E8B600              <1> 	call	print
   388 000016DD EB06                <1> 	jmp	.cpu_freq
   389                              <1> 
   390                              <1> .nec_v20:
   391 000016DF BE[A801]            <1> 	mov	si,msg_cpu_nec_v20
   392 000016E2 E8AE00              <1> 	call	print
   393                              <1> 
   394                              <1> .cpu_freq:
   395                              <1> 
   396                              <1> %ifdef TURBO_MODE
   397                              <1> %ifdef BIOS_SETUP
   398                              <1> ; print CPU clock frequency
   399                              <1> 
   400                              <1> 	mov	si,msg_at
   401                              <1> 	call	print
   402                              <1> 
   403                              <1> 	push	ax
   404                              <1> 	call	get_config_a		; read BIOS configuration byte A
   405                              <1> 	call	print_cpu_clk
   406                              <1> 	pop	ax
   407                              <1> 
   408                              <1> %endif ; BIOS_SETUP
   409                              <1> %endif ; TURBO_MODE
   410                              <1> 
   411 000016E5 BE[8900]            <1> 	mov	si,msg_crlf
   412 000016E8 E8A800              <1> 	call	print
   413                              <1> 
   414 000016EB 83F801              <1> 	cmp	ax,0001h		; if AX = 0001h - we have INTEL (C) 1978
   415 000016EE 7506                <1> 	jnz	.exit
   416 000016F0 BE[1201]            <1> 	mov	si,msg_cpu_bug
   417 000016F3 E89D00              <1> 	call	print
   418                              <1> 
   419                              <1> .exit:
   420 000016F6 5E                  <1> 	pop	si
   421 000016F7 58                  <1> 	pop	ax
   422 000016F8 C3                  <1> 	ret
   423                              <1> 
   424                              <1> ; stack frame after "push bp"
   425                              <1> ; BP - word [BP]
   426                              <1> ; IP - word [BP+2]
   427                              <1> ; CS - word [BP+4]
   428                              <1> ; FLAGS - word [BP+6]
   429                              <1> .int_01:
   430 000016F9 55                  <1> 	push	bp
   431 000016FA 89E5                <1> 	mov	bp,sp
   432 000016FC 817E02[AF16]        <1> 	cmp	word [bp+2],.pop_sreg	; if IP = .pop_sreg we have '78 CPU
   433 00001701 7504                <1> 	jne	.1
   434 00001703 B001                <1> 	mov	al,01h			; (C) INTEL '79
   435 00001705 EB09                <1> 	jmp	.int_01_exit
   436                              <1> .1:
   437 00001707 817E02[AE16]        <1> 	cmp	word [bp+2],.push_sreg	; if IP = .push_sreg it is not Harris
   438 0000170C 7502                <1> 	jne	.int_01_exit
   439 0000170E B002                <1> 	mov	al,02h			; not Harris / Intersil 80C88
   440                              <1> .int_01_exit:
   441 00001710 5D                  <1> 	pop	bp
   442 00001711 CF                  <1> 	iret
   443                              <1> 
   444                              <1> ;=========================================================================
   445                              <1> ; detect_fpu - detect and print FPU (mathematics coprocessor) presence
   446                              <1> ;-------------------------------------------------------------------------
   447                              <1> test_word	equ	03FEh		; right at the end of interrupt table
   448                              <1> detect_fpu:
   449 00001712 50                  <1> 	push	ax
   450 00001713 51                  <1> 	push	cx
   451 00001714 56                  <1> 	push	si
   452 00001715 B022                <1> 	mov	al,e_fpu_detect
   453 00001717 E680                <1> 	out	post_reg,al
   454                              <1> 
   455 00001719 BE[E600]            <1> 	mov	si,msg_fpu
   456 0000171C E87400              <1> 	call	print
   457 0000171F DBE3                <1> 	fninit				; initialize coprocessor
   458 00001721 B90300              <1> 	mov	cx,3
   459                              <1> .wait:
   460 00001724 E2FE                <1> 	loop	.wait			; wait for coprocessor to initialize
   461                              <1> 					;   (can't use fwait, since it could
   462                              <1> 					;   be no coprocessor at all)
   463 00001726 8B0EFE03            <1> 	mov	cx,word [test_word]	; save test_word to CX
   464 0000172A C706FE030000        <1> 	mov	word [test_word],0000h	; clear space for control word
   465 00001730 D93EFE03            <1> 	fnstcw	word [test_word]	; store control word
   466 00001734 813EFE03FF03        <1> 	cmp	word [test_word],03FFh	; 8087 sets control word to 03FFh
   467 0000173A 750D                <1> 	jne	.no_fpu			;   after finit
   468                              <1> 
   469                              <1> .fpu:
   470 0000173C BE[B001]            <1> 	mov	si,msg_fpu_present
   471 0000173F E85100              <1> 	call	print
   472 00001742 830E100002          <1> 	or	word [equipment_list],equip_fpu ; update equipment word
   473 00001747 EB06                <1> 	jmp	.exit
   474                              <1> 
   475                              <1> .no_fpu:
   476                              <1> 
   477 00001749 BE[C502]            <1> 	mov	si,msg_absent
   478 0000174C E84400              <1> 	call	print
   479                              <1> 
   480                              <1> .exit:
   481 0000174F 890EFE03            <1> 	mov	word [test_word],cx	; restore initial value of test_word
   482                              <1> 
   483 00001753 5E                  <1> 	pop	si
   484 00001754 59                  <1> 	pop	cx
   485 00001755 58                  <1> 	pop	ax
   486 00001756 C3                  <1> 	ret
   487                              <1> 
   488                              <1> %ifdef MACHINE_FE2010A
   489                              <1> ;=========================================================================
   490                              <1> ; detect_chipset - detect and print chipset type
   491                              <1> ; Input:
   492                              <1> ;	none
   493                              <1> ; Output:
   494                              <1> ;	none
   495                              <1> ; Note: This subroutine also disables DRAM refresh on both FE2010A and PT8010AF
   496                              <1> ;-------------------------------------------------------------------------
   497                              <1> detect_chipset:
   498                              <1> 	push	ax
   499                              <1> 	push	si
   500                              <1> 	mov	si,msg_chipset
   501                              <1> 	call	print
   502                              <1> 	mov	si,msg_fe2010a
   503                              <1> 	mov	al,54h			; channel 1, LSB only, mode 2, binary
   504                              <1> 	out	pit_ctl_reg,al		; used for DRAM refresh on IBM PC/XT/AT
   505                              <1> 	mov	al,12h			; or for delays (using port_b, bit 4)
   506                              <1>         out     pit_ch1_reg,al		; pulse every 15ms
   507                              <1> 	mov	al,40h			; this disables refresh on FE2010A
   508                              <1> 	out	pit_ctl_reg,al		; but not on PT8010AF
   509                              <1> 	in	al,pit_ch1_reg
   510                              <1> 	cmp	al,12h			; should be 12h on FE2010A
   511                              <1> 	je	.print_chipset
   512                              <1> 	mov	si,msg_pt8010af
   513                              <1> 
   514                              <1> .print_chipset:
   515                              <1> 	call	print
   516                              <1> 	mov	al,54h			; channel 1, LSB only, mode 2, binary
   517                              <1> 	out	pit_ctl_reg,al		; this disables memory refresh
   518                              <1> 	pop	ax
   519                              <1> 	pop	si
   520                              <1> 	ret
   521                              <1> 
   522                              <1> %endif ; MACHINE_FE2010A
   523                              <1> 
   524                              <1> %ifdef TURBO_MODE
   525                              <1> %ifdef BIOS_SETUP
   526                              <1> ;=========================================================================
   527                              <1> ; print_cpu_clk - Print CPU clock frequency
   528                              <1> ; Input:
   529                              <1> ;	AL - NVRAM CPU clock frequency configuration (bits 1:0)
   530                              <1> ;		0 - 4.77 MHz / Normal
   531                              <1> ;		1 - 7.16 MHz / Turbo
   532                              <1> ;		2 - 9.55 MHz (FE2010A)
   533                              <1> ; Output:
   534                              <1> ;	none
   535                              <1> ;-------------------------------------------------------------------------
   536                              <1> print_cpu_clk:
   537                              <1> 	push	ax
   538                              <1> 	push	si
   539                              <1> 	and	al,nvram_trbo_mask	; get turbo bits
   540                              <1> %ifdef MACHINE_FE2010A
   541                              <1> 	mov	si,msg_clk_7_16mhz
   542                              <1> 	cmp	al,1
   543                              <1> 	je	.print
   544                              <1> 	mov	si,msg_clk_9_55mhz
   545                              <1> 	cmp	al,2
   546                              <1> 	je	.print
   547                              <1> %endif ; MACHINE_FE2010A
   548                              <1> %ifdef MACHINE_XI8088
   549                              <1> 	mov	si,msg_clk_turbo
   550                              <1> 	cmp	al,1
   551                              <1> 	je	.print
   552                              <1> %endif ; MACHINE_XI8088
   553                              <1> 	mov	si,msg_clk_4_77mhz
   554                              <1> 
   555                              <1> .print:
   556                              <1> 	call    print
   557                              <1> 	pop	si
   558                              <1> 	pop	ax
   559                              <1> 	ret
   560                              <1> %endif ; BIOS_SETUP
   561                              <1> 
   562                              <1> ;=========================================================================
   563                              <1> ; set_cpu_clk - Set CPU clock frequency
   564                              <1> ; Input:
   565                              <1> ;	AL - NVRAM CPU clock frequency configuration
   566                              <1> ;		0 - 4.77 MHz / Normal
   567                              <1> ;		1 - 7.16 MHz / Turbo
   568                              <1> ;		2 - 9.55 MHz (FE2010A)
   569                              <1> ; Output:
   570                              <1> ;	none
   571                              <1> ;-------------------------------------------------------------------------
   572                              <1> set_cpu_clk:
   573                              <1> %ifdef MACHINE_FE2010A
   574                              <1> 	cmp	al, 1 
   575                              <1> 	je	set_cpu_clk_7_16mhz
   576                              <1> 	cmp	al, 2
   577                              <1> 	je	set_cpu_clk_9_55mhz
   578                              <1> 	jmp	set_cpu_clk_4_77mhz   
   579                              <1> %endif ; MACHINE_FE2010A
   580                              <1> %ifdef MACHINE_XI8088 or MACHINE_BOOK8088
   581 00001757 3C01                <1> 	cmp	al,1
   582 00001759 740A                <1> 	je	set_cpu_clk_turbo
   583 0000175B EB01                <1> 	jmp	set_cpu_clk_4_77mhz   
   584                              <1> %endif ; MACHINE_XI8088 or MACHINE_BOOK8088
   585 0000175D C3                  <1> 	ret
   586                              <1> 
   587                              <1> ;=========================================================================
   588                              <1> ; set_cpu_clk_4_77mhz - Set CPU clock at 4.77 MHz
   589                              <1> ; set_cpu_clk_7_16mhz - Set CPU clock at 7.16 MHz
   590                              <1> ; set_cpu_clk_9_55mhz - Set CPU clock at 9.55 MHz
   591                              <1> ; set_cpu_clk_turbo - Set CPU clock at turbo frequency (system dependent)
   592                              <1> ; Input:
   593                              <1> ;	none
   594                              <1> ; Output:
   595                              <1> ;	none
   596                              <1> ;-------------------------------------------------------------------------
   597                              <1> %ifdef MACHINE_FE2010A
   598                              <1> set_cpu_clk_4_77mhz:
   599                              <1> 	push ax
   600                              <1> 	mov	al,byte [equipment_list] ; get lower byte of the equipment list
   601                              <1> 	and	al,equip_fpu		; isolate FPU installed bit
   602                              <1> 	or	al,fe_par_disable	; disable memory parity checking
   603                              <1> 	out	fe_config_reg,al	; clear bits 7-5 - 4.77 MHz CPU clock
   604                              <1> 	pop ax
   605                              <1> 	ret
   606                              <1> 
   607                              <1> set_cpu_clk_7_16mhz:
   608                              <1> 	push ax
   609                              <1> 	call	get_config_a
   610                              <1> 	mov	ah,al
   611                              <1> 	mov	al,byte [equipment_list] ; get lower byte of the equipment list
   612                              <1> 	and	al,equip_fpu		; isolate FPU installed bit
   613                              <1> 	or	al,fe_par_disable	; disable memory parity checking
   614                              <1> 	or	al,fe_clk_7_norm	; set bit 6 - 7.15 MHz CPU clock
   615                              <1> 	test	ah,nvram_fast_ws	; nvram_fast_ws = 1 - Normal wait states
   616                              <1> 	jnz	.set_config
   617                              <1> 	or	al,fe_clk_7_fast
   618                              <1> 
   619                              <1> .set_config:
   620                              <1> 	out	fe_config_reg,al
   621                              <1> 	pop ax
   622                              <1> 	ret
   623                              <1> 
   624                              <1> set_cpu_clk_9_55mhz:
   625                              <1> 	push ax
   626                              <1> 	call	get_config_a
   627                              <1> 	mov	ah,al
   628                              <1> 	mov	al,byte [equipment_list] ; get lower byte of the equipment list
   629                              <1> 	and	al,equip_fpu		; isolate FPU installed bit
   630                              <1> 	or	al,fe_par_disable	; disable memory parity checking
   631                              <1> 	or	al,fe_clk_9_norm	; set bit 7 - 9.54 MHz CPU clock
   632                              <1> 	test	ah,nvram_fast_ws
   633                              <1> 	jnz	.set_config		; nvram_fast_ws = 1 - Normal wait states
   634                              <1> 	or	al,fe_clk_9_fast
   635                              <1> 
   636                              <1> .set_config:
   637                              <1> 	out	fe_config_reg,al
   638                              <1> 	pop ax
   639                              <1> 	ret
   640                              <1> %endif ; MACHINE_FE2010A
   641                              <1> %ifdef MACHINE_XI8088
   642                              <1> set_cpu_clk_4_77mhz:
   643                              <1> 	push	ax
   644                              <1> 	in	al,ppi_pb_reg
   645                              <1> 	and	al,0FBh			; clear bit 2 (turbo enable bit)
   646                              <1> 	out	ppi_pb_reg,al
   647                              <1> 	pop	ax
   648                              <1> 	ret
   649                              <1> 
   650                              <1> set_cpu_clk_turbo:
   651                              <1> 	push	ax
   652                              <1> 	in	al,ppi_pb_reg
   653                              <1> 	or	al,04h			; set bit 2 (turbo enable bit)
   654                              <1> 	out	ppi_pb_reg,al
   655                              <1> 	pop	ax
   656                              <1> 	ret
   657                              <1> %endif ; MACHINE_XI8088
   658                              <1> %ifdef MACHINE_BOOK8088
   659                              <1> set_cpu_clk_4_77mhz:
   660 0000175E 50                  <1> 	push	ax
   661 0000175F B000                <1> 	mov	al,0			; clear bit 2 (turbo enable bit)
   662 00001761 E661                <1> 	out	ppi_pb_reg,al
   663 00001763 58                  <1> 	pop	ax
   664 00001764 C3                  <1> 	ret
   665                              <1> 
   666                              <1> set_cpu_clk_turbo:
   667 00001765 50                  <1> 	push	ax
   668 00001766 B004                <1> 	mov	al,04h			; set bit 2 (turbo enable bit)
   669 00001768 E661                <1> 	out	ppi_pb_reg,al
   670 0000176A 58                  <1> 	pop	ax
   671 0000176B C3                  <1> 	ret
   672                              <1> %endif ; MACHINE_BOOK8088
   673                              <1> 
   674                              <1> %endif ; TURBO_MODE
   285                                  
   286                                  %ifdef SECOND_PIC
   287                                  
   288                                  ;=========================================================================
   289                                  ; int_ignore2 - signal end of interrupt to PIC if hardware interrupt, return
   290                                  ;-------------------------------------------------------------------------
   291                                  int_ignore2:
   292                                  	push	ax
   293                                  	mov	al,20h
   294                                  	out	pic2_reg0,al	; signal EOI to the slave PIC
   295                                  	out	pic1_reg0,al	; signal EOI to the master PIC
   296                                  	pop	ax
   297                                  	iret
   298                                  
   299                                  ;=========================================================================
   300                                  ; int_71 - IRQ9 ISR, emulate IRQ2
   301                                  ;-------------------------------------------------------------------------
   302                                  int_71:
   303                                  	push	ax
   304                                  	mov	al,20h
   305                                  	out	pic2_reg0,al	; signal EOI to the slave PIC
   306                                  	pop	ax
   307                                  	int	0Ah		; call IRQ2 ISR
   308                                  	iret
   309                                  
   310                                  ;=========================================================================
   311                                  ; int_75 - IRQ13 ISR, emulate NMI by FPU
   312                                  ;-------------------------------------------------------------------------
   313                                  int_75:
   314                                  	push	ax
   315                                  	mov	al,20h
   316                                  	out	pic2_reg0,al	; signal EOI to the slave PIC
   317                                  	out	pic1_reg0,al	; signal EOI to the master PIC
   318                                  	pop	ax
   319                                  	int	02h		; call NMI ISR
   320                                  	iret
   321                                  
   322                                  %endif ; SECOND_PIC
   323                                  
   324                                  ;=========================================================================
   325                                  ; boot_os -Boot the OS
   326                                  ;-------------------------------------------------------------------------
   327                                  boot_os:
   328                                  
   329                                  ;-------------------------------------------------------------------------
   330                                  ; Check for F1 (setup key), run setup utility if pressed
   331                                  
   332 0000176C B401                    	mov	ah,01h
   333 0000176E CD16                    	int	16h
   334 00001770 740E                    	jz	.no_key
   335 00001772 B400                    	mov	ah,00h
   336 00001774 CD16                    	int	16h			; read the keystroke
   337 00001776 3D003B                  	cmp	ax,3B00h		; F1?
   338 00001779 7505                    	jne	.no_key
   339 0000177B 800E120001              	or	byte [post_flags],post_setup
   340                                  .no_key:
   341                                  
   342 00001780 F606120001              	test	byte [post_flags],post_setup
   343 00001785 7400                    	jz	.no_setup
   344                                  
   345                                  %ifdef BIOS_SETUP
   346                                  	call	nvram_setup
   347                                  %endif ; BIOS_SETUP
   348                                  
   349                                  .no_setup:
   350                                  
   351                                  %ifdef TURBO_MODE
   352                                  %ifdef BIOS_SETUP
   353                                  	call	get_config_a		; read BIOS configuration byte A
   354                                  	and	al,nvram_trbo_mask
   355                                  	call	set_cpu_clk		; set CPU clock
   356                                  %endif ; BIOS_SETUP
   357                                  %endif ; TURBO_MODE
   358                                  
   359 00001787 B000                    	mov	al,e_boot		; boot the OS POST code
   360 00001789 E680                    	out	post_reg,al
   361                                  
   362 0000178B BE[E403]                	mov	si,msg_boot
   363 0000178E E80200                  	call	print
   364 00001791 CD19                    	int	19h			; boot the OS
   365                                  
   366                                  ;=========================================================================
   367                                  ; print - print ASCIIZ string to the console
   368                                  ; Input:
   369                                  ;	CS:SI - pointer to string to print
   370                                  ; Output:
   371                                  ;	none
   372                                  ;-------------------------------------------------------------------------
   373                                  print:
   374 00001793 9C                      	pushf
   375 00001794 50                      	push	ax
   376 00001795 53                      	push	bx
   377 00001796 56                      	push	si
   378 00001797 1E                      	push	ds
   379 00001798 0E                      	push	cs
   380 00001799 1F                      	pop	ds
   381 0000179A FC                      	cld
   382                                  .1:
   383 0000179B AC                      	lodsb
   384 0000179C 08C0                    	or	al,al
   385 0000179E 7408                    	jz	.exit
   386 000017A0 B40E                    	mov	ah,0Eh
   387 000017A2 B30F                    	mov	bl,0Fh
   388 000017A4 CD10                    	int	10h
   389 000017A6 EBF3                    	jmp	.1
   390                                  .exit:
   391 000017A8 1F                      	pop	ds
   392 000017A9 5E                      	pop	si
   393 000017AA 5B                      	pop	bx
   394 000017AB 58                      	pop	ax
   395 000017AC 9D                      	popf
   396 000017AD C3                      	ret
   397                                  
   398                                  ;=========================================================================
   399                                  ; print_hex - print 16-bit number in hexadecimal
   400                                  ; Input:
   401                                  ;	AX - number to print
   402                                  ; Output:
   403                                  ;	none
   404                                  ;-------------------------------------------------------------------------
   405                                  print_hex:
   406 000017AE 86C4                    	xchg	al,ah
   407 000017B0 E80600                  	call	print_byte		; print the upper byte
   408 000017B3 86C4                    	xchg	al,ah
   409 000017B5 E80100                  	call	print_byte		; print the lower byte
   410 000017B8 C3                      	ret
   411                                  
   412                                  ;=========================================================================
   413                                  ; print_byte - print a byte in hexadecimal
   414                                  ; Input:
   415                                  ;	AL - byte to print
   416                                  ; Output:
   417                                  ;	none
   418                                  ;-------------------------------------------------------------------------
   419                                  print_byte:
   420 000017B9 D0C0                    	rol	al,1
   421 000017BB D0C0                    	rol	al,1
   422 000017BD D0C0                    	rol	al,1
   423 000017BF D0C0                    	rol	al,1
   424 000017C1 E82D00                  	call	print_digit
   425 000017C4 D0C0                    	rol	al,1
   426 000017C6 D0C0                    	rol	al,1
   427 000017C8 D0C0                    	rol	al,1
   428 000017CA D0C0                    	rol	al,1
   429 000017CC E82200                  	call	print_digit
   430 000017CF C3                      	ret
   431                                  
   432                                  ;=========================================================================
   433                                  ; print_dec - print 16-bit number in decimal
   434                                  ; Input:
   435                                  ;	AX - number to print
   436                                  ; Output:
   437                                  ;	none
   438                                  ;-------------------------------------------------------------------------
   439                                  print_dec:
   440 000017D0 50                      	push	ax
   441 000017D1 51                      	push	cx
   442 000017D2 52                      	push	dx
   443 000017D3 B90A00                  	mov	cx,10		; base = 10
   444 000017D6 E80400                  	call	.print_rec
   445 000017D9 5A                      	pop	dx
   446 000017DA 59                      	pop	cx
   447 000017DB 58                      	pop	ax
   448 000017DC C3                      	ret
   449                                  
   450                                  .print_rec:			; print all digits recursively
   451 000017DD 52                      	push	dx
   452 000017DE 31D2                    	xor	dx,dx		; DX = 0
   453 000017E0 F7F1                    	div	cx		; AX = DX:AX / 10, DX = DX:AX % 10
   454 000017E2 83F800                  	cmp	ax,0
   455 000017E5 7403                    	je	.below10
   456 000017E7 E8F3FF                  	call	.print_rec	; print number / 10 recursively
   457                                  .below10:
   458 000017EA 89D0                    	mov	ax,dx		; reminder is in DX
   459 000017EC E80200                  	call	print_digit	; print reminder
   460 000017EF 5A                      	pop	dx
   461 000017F0 C3                      	ret
   462                                  
   463                                  ;=========================================================================
   464                                  ; print_digit - print hexadecimal digit
   465                                  ; Input:
   466                                  ;	AL - bits 3...0 - digit to print (0...F)
   467                                  ; Output:
   468                                  ;	none
   469                                  ;-------------------------------------------------------------------------
   470                                  print_digit:
   471 000017F1 50                      	push	ax
   472 000017F2 53                      	push	bx
   473 000017F3 240F                    	and	al,0Fh
   474 000017F5 0430                    	add	al,'0'			; convert to ASCII
   475 000017F7 3C39                    	cmp	al,'9'			; less or equal 9?
   476 000017F9 7602                    	jna	.1
   477 000017FB 0407                    	add	al,'A'-'9'-1		; a hex digit
   478                                  .1:
   479 000017FD B40E                    	mov	ah,0Eh			; Int 10 function 0Eh - teletype output
   480 000017FF B307                    	mov	bl,07h			; just in case we're in graphic mode
   481 00001801 CD10                    	int	10h
   482 00001803 5B                      	pop	bx
   483 00001804 58                      	pop	ax
   484 00001805 C3                      	ret
   485                                  
   486                                  %ifdef EBDA_SIZE
   487                                  ;=========================================================================
   488                                  ; reserve_ebda - reserve EBDA (Extended BIOS Data Area) if using PS2_MOUSE
   489                                  ; Input:
   490                                  ;	AX = memory size in KiB
   491                                  ; Notes:
   492                                  ;	- Assumes that EBDA memory was cleaned
   493                                  ;	- Does not reserve EBDA if PS/2 auxiliary device is not detected
   494                                  ;-------------------------------------------------------------------------
   495                                  reserve_ebda:
   496                                  	push	ax
   497                                  	push	cx
   498                                  	test	word [equipment_list],equip_mouse
   499                                  	jz	.no_mouse
   500                                  	mov	ax,word [memory_size]	; get conventional memory size
   501                                  	sub	ax,EBDA_SIZE		; substract EBDA size
   502                                  	mov	word [memory_size],ax	; store new conventional memory size
   503                                  	mov	cl,6
   504                                  	shl	ax,cl			; convert to segment
   505                                  	mov	word [ebda_segment],ax	; store EBDA segment to BIOS variable
   506                                  	push	ds
   507                                  	mov	ds,ax
   508                                  	mov	ax,EBDA_SIZE
   509                                      	mov	byte [ebda_size],al	; store EBDA size to EBDA
   510                                  	pop	ds
   511                                  	push	si
   512                                  	mov	si,msg_ebda
   513                                  	call	print
   514                                  	call	print_dec
   515                                  	mov	si,msg_kib
   516                                  	call	print
   517                                  	pop	si
   518                                  .no_mouse:
   519                                  	pop	cx
   520                                  	pop	ax
   521                                  	ret
   522                                  %endif ; EBDA_SIZE
   523                                  
   524                                  ;=========================================================================
   525                                  ; print display type
   526                                  ;-------------------------------------------------------------------------
   527                                  print_display:
   528 00001806 BE[BD01]                	mov	si,msg_disp
   529 00001809 E887FF                  	call	print
   530 0000180C BE[DA01]                	mov	si,msg_disp_ega		; assume EGA or later
   531 0000180F 833EA80000              	cmp	word [vga_table_ptr],0	; check if BIOS Video Save/Override
   532                                  					; Pointer Table address is initialized
   533 00001814 751D                    	jnz	.print_disp
   534 00001816 833EAA0000              	cmp	word [vga_table_ptr+2],0
   535 0000181B 7516                    	jnz	.print_disp
   536                                  					; Not an EGA/VGA - check equipment word
   537 0000181D A01000                  	mov	al,byte [equipment_list] ; get equipment - low byte
   538 00001820 2430                    	and	al,equip_video		; get video adapter type
   539 00001822 BE[1502]                	mov	si,msg_disp_mda
   540 00001825 3C30                    	cmp	al,equip_mono		; monochrome?
   541 00001827 740A                    	jz	.print_disp
   542 00001829 BE[F901]                	mov	si,msg_disp_cga_80
   543 0000182C 3C20                    	cmp	al,equip_color_80	; CGA 80x25?
   544 0000182E 7403                    	jz	.print_disp
   545 00001830 BE[0702]                	mov	si,msg_disp_cga_40	; Must be CGA 40x25
   546                                  .print_disp:
   547 00001833 E85DFF                  	call	print
   548 00001836 C3                      	ret
   549                                  
   550                                  %ifdef PS2_MOUSE
   551                                  
   552                                  ;=========================================================================
   553                                  ; print PS/2 mouse presence
   554                                  ;-------------------------------------------------------------------------
   555                                  
   556                                  print_mouse:
   557                                  	mov	si,msg_mouse
   558                                  	call	print
   559                                  	mov	si,msg_absent
   560                                  	test	byte [equipment_list],equip_mouse
   561                                  	jz	.print_mouse
   562                                  	mov	si,msg_present
   563                                  .print_mouse:
   564                                  	call	print
   565                                  	ret
   566                                  
   567                                  %endif ; PS2_MOUSE
   568                                  
   569                                  ;=========================================================================	
   570                                  ; interrupt_table - offsets only (BIOS segment is always 0F000h)
   571                                  ;-------------------------------------------------------------------------
   572                                  interrupt_table:
   573 00001837 [533F]                  	dw	int_dummy		; INT 00 - Divide by zero
   574 00001839 [533F]                  	dw	int_dummy		; INT 01 - Single step
   575 0000183B [C322]                  	dw	int_02			; INT 02 - Non-maskable interrupt
   576 0000183D [533F]                  	dw	int_dummy		; INT 03 - Debugger breakpoint
   577 0000183F [533F]                  	dw	int_dummy		; INT 04 - Integer overlow (into)
   578 00001841 [543F]                  	dw	int_05			; INT 05 - BIOS Print Screen
   579 00001843 [533F]                  	dw	int_dummy		; INT 06
   580 00001845 [533F]                  	dw	int_dummy		; INT 07
   581 00001847 [A53E]                  	dw	int_08			; INT 08 - IRQ0 - Timer Channel 0
   582 00001849 [8729]                  	dw	int_09			; INT 09 - IRQ1 - Keyboard
   583 0000184B [233F]                  	dw	int_ignore		; INT 0A - IRQ2
   584 0000184D [233F]                  	dw	int_ignore		; INT 0B - IRQ3
   585 0000184F [233F]                  	dw	int_ignore		; INT 0C - IRQ4
   586 00001851 [233F]                  	dw	int_ignore		; INT 0D - IRQ5
   587 00001853 [572F]                  	dw	int_0E			; INT 0E - IRQ6 - Floppy
   588 00001855 [233F]                  	dw	int_ignore		; INT 0F - IRQ7
   589 00001857 [6530]                  	dw	int_10			; INT 10 - BIOS Video Services
   590 00001859 [4D38]                  	dw	int_11			; INT 11 - BIOS Get Equipment List
   591 0000185B [4138]                  	dw	int_12			; INT 12 - BIOS Get Memory Size
   592 0000185D [592C]                  	dw	int_13			; INT 13 - BIOS Floppy Disk Services
   593 0000185F [2927]                  	dw	int_14			; INT 14 - BIOS Serial Communications
   594 00001861 [5938]                  	dw	int_15			; INT 15 - BIOS Misc. System Services
   595 00001863 [2E28]                  	dw	int_16			; INT 16 - BIOS Keyboard Services
   596 00001865 [D22F]                  	dw	int_17			; INT 17 - BIOS Parallel Printer svc.
   597 00001867 [2323]                  	dw	int_18			; INT 18 - BIOS Start ROM BASIC
   598 00001869 [F226]                  	dw	int_19			; INT 19 - BIOS Boot the OS
   599 0000186B [6E3E]                  	dw	int_1A			; INT 1A - BIOS Time Services
   600 0000186D [533F]                  	dw	int_dummy		; INT 1B - DOS Keyboard Break
   601 0000186F [533F]                  	dw	int_dummy		; INT 1C - User Timer Tick
   602 00001871 [A430]                  	dw	int_1D			; INT 1D - Video Parameters Table
   603 00001873 [C72F]                  	dw	int_1E			; INT 1E - Floppy Parameters Table
   604                                  %ifndef MACHINE_XT
   605 00001875 [0404]                  	dw	int_1F			; INT 1F - Font For Graphics Mode
   606                                  %else ; MACHINE_XT
   607                                  	dw	int_ignore
   608                                  %endif ; MACHINE_XT
   609                                  
   610                                  %ifdef SECOND_PIC
   611                                  interrupt_table2:
   612                                  	dw	int_70			; INT 70 - IRQ8 - RTC
   613                                  	dw	int_71			; INT 71 - IRQ9 - redirection
   614                                  	dw	int_ignore2		; INT 72 - IRQ10
   615                                  	dw	int_ignore2		; INT 73 - IRQ11
   616                                  %ifndef PS2_MOUSE
   617                                  	dw	int_ignore2		; INT 74 - IRQ12 - PS/2 mouse
   618                                  %else ; PS2_MOUSE
   619                                  	dw	int_74			; INT 74 - IRQ12 - PS/2 mouse
   620                                  %endif ; PS2_MOUSE
   621                                  	dw	int_75			; INT 75 - IRQ13 - FPU
   622                                  	dw	int_ignore2		; INT 76 - IRQ14
   623                                  	dw	int_ignore2		; INT 77 - IRQ15
   624                                  %endif ; SECOND_PIC
   625                                  
   626                                  ;=========================================================================
   627                                  ; cold_start, warm_start - BIOS POST (Power on Self Test) starts here
   628                                  ;-------------------------------------------------------------------------	
   629 00001877 FF<rep 7E4h>            	setloc	0E05Bh		; POST Entry Point
   629          ******************       warning: Inserting 2020 bytes [-w+user]
   630                                  cold_start:
   631 0000205B B84000                  	mov	ax,biosdseg
   632 0000205E 8ED8                    	mov	ds,ax
   633 00002060 C70672000000            	mov	word [warm_boot],0	; indicate cold boot
   634                                  
   635                                  warm_start:
   636 00002066 FA                      	cli				; disable interrupts
   637 00002067 FC                      	cld				; clear direction flag
   638 00002068 B001                    	mov	al,e_cpu_test
   639 0000206A E680                    	out	post_reg,al		; POST start code
   640                                  
   641                                  ;-------------------------------------------------------------------------
   642                                  ; test CPU's FLAG register
   643                                  
   644 0000206C 31C0                    	xor	ax,ax			; AX = 0
   645 0000206E 724A                    	jb	cpu_fail
   646 00002070 7048                    	jo	cpu_fail
   647 00002072 7846                    	js	cpu_fail
   648 00002074 7544                    	jnz	cpu_fail
   649 00002076 7B42                    	jpo	cpu_fail
   650 00002078 83C001                  	add	ax,1			; AX = 1
   651 0000207B 743D                    	jz	cpu_fail
   652 0000207D 7A3B                    	jpe	cpu_fail
   653 0000207F 2D0280                  	sub	ax,8002h
   654 00002082 7836                    	js	cpu_fail
   655 00002084 40                      	inc	ax
   656 00002085 7133                    	jno	cpu_fail
   657 00002087 D1E0                    	shl	ax,1
   658 00002089 732F                    	jnb	cpu_fail
   659 0000208B 752D                    	jnz	cpu_fail
   660 0000208D D1E0                    	shl	ax,1
   661 0000208F 7229                    	jb	cpu_fail
   662                                  
   663                                  ;-------------------------------------------------------------------------
   664                                  ; Test CPU registers
   665                                  
   666 00002091 B8AAAA                  	mov	ax,0AAAAh
   667                                  .1:
   668 00002094 8ED8                    	mov	ds,ax
   669 00002096 8CDB                    	mov	bx,ds
   670 00002098 8EC3                    	mov	es,bx
   671 0000209A 8CC1                    	mov	cx,es
   672 0000209C 8ED1                    	mov	ss,cx
   673 0000209E 8CD2                    	mov	dx,ss
   674 000020A0 89D5                    	mov	bp,dx
   675 000020A2 89EC                    	mov	sp,bp
   676 000020A4 89E6                    	mov	si,sp
   677 000020A6 89F7                    	mov	di,si
   678 000020A8 81FFAAAA                	cmp	di,0AAAAh
   679 000020AC 7506                    	jnz	.2
   680 000020AE 89F8                    	mov	ax,di
   681 000020B0 F7D0                    	not	ax
   682 000020B2 EBE0                    	jmp	.1
   683                                  .2:
   684 000020B4 81FF5555                	cmp	di,5555h
   685 000020B8 7418                    	jz	cpu_ok
   686                                  
   687                                  cpu_fail:
   688 000020BA B052                    	mov	al,e_cpu_fail
   689 000020BC E680                    	out	post_reg,al
   690                                  
   691                                  ;-------------------------------------------------------------------------
   692                                  ; CPU error: continious beep - 400 Hz
   693                                  
   694 000020BE B0B6                    	mov	al,0B6h
   695 000020C0 E643                    	out	pit_ctl_reg,al		; PIT - channel 2 mode 3
   696 000020C2 B8A60B                  	mov	ax,pic_freq/400		; 400 Hz signal
   697 000020C5 E642                    	out	pit_ch2_reg,al
   698 000020C7 88E0                    	mov	al,ah
   699 000020C9 E642                    	out	pit_ch2_reg,al
   700                                  %ifndef MACHINE_BOOK8088
   701                                  	in	al,ppi_pb_reg
   702                                  	or	al,3			; turn speaker on and enable
   703                                  					; PIT channel 2 to speaker
   704                                  %else ; MACHINE_BOOK8088
   705                                  ; It appears that Book 8088 implements PPI Port B as read-only port
   706 000020CB B003                    	mov	al,3			; turn speaker on and enable
   707                                  					; PIT channel 2 to speaker
   708                                  %endif ; MACHINE_BOOK8088
   709 000020CD E661                    	out	ppi_pb_reg,al
   710                                  
   711                                  .1:
   712 000020CF F4                      	hlt
   713 000020D0 EBFD                    	jmp	.1
   714                                  
   715                                  ;-------------------------------------------------------------------------
   716                                  ; CPU test passed
   717                                  
   718                                  cpu_ok:
   719                                  
   720                                  ;-------------------------------------------------------------------------
   721                                  ; disable NMI, turbo mode, and video output on CGA and MDA
   722                                  
   723 000020D2 B002                    	mov	al,e_init_cfg
   724 000020D4 E680                    	out	post_reg,al
   725                                  
   726                                  %ifdef AT_NMI
   727                                  	mov	al,0Dh & nmi_disa_mask
   728                                  	out	rtc_addr_reg,al		; disable NMI
   729                                  	jmp	$+2
   730                                  	in	al,rtc_data_reg		; dummy read to keep RTC happy
   731                                  %else ; AT_NMI
   732 000020D6 B000                    	mov	al,nmi_disable
   733 000020D8 E6A0                    	out	nmi_mask_reg,al		; disable NMI
   734                                  %endif ; AT_NMI
   735                                  
   736                                  %ifdef MACHINE_XI8088
   737                                  	mov	al,iochk_disable	; clear and disable ~IOCHK
   738                                  	out	ppi_pb_reg,al
   739                                  	mov	al,00h			; clear turbo bit
   740                                  	out	ppi_pb_reg,al		; and also turn off the speaker
   741                                  %endif ; MACHINE_XI8088
   742                                  
   743                                  %ifdef MACHINE_FE2010A
   744                                  	mov	al,fe_par_disable	; Disable parity checking
   745                                  	out	fe_config_reg,al	; FE2010A chipset configuration register
   746                                  	mov	al,10110000b		; Clear keyboard, disable keyboard clock
   747                                  					; disable IOCHCK NMI, disable MB DRAM NMI
   748                                  	out	ppi_pb_reg,al		; Disable parity and IOCHK
   749                                  %endif ; MACHINE_FE2010A
   750                                  
   751                                  %ifdef MACHINE_BOOK8088
   752 000020DA B000                    	mov	al,00h			; clear turbo bit
   753 000020DC E661                    	out	ppi_pb_reg,al		; and also turn off the speaker
   754                                  %endif ; MACHINE_BOOK8088
   755                                  
   756                                  %ifdef MACHINE_XT
   757                                  	mov	al,ppi_cwd_value	; PPI port A and port C inputs
   758                                  	out	ppi_cwd_reg,al		; PPI control word register
   759                                  	mov	al,10100101b		; Clear keyboard, disable keyboard clock
   760                                  					; disable IOCHCK NMI, enable MB DRAM NMI
   761                                  	out	ppi_pb_reg,al
   762                                  %endif ; MACHINE_XT
   763                                  
   764 000020DE B000                    	mov	al,00h
   765 000020E0 BAD803                  	mov	dx,cga_mode_reg
   766 000020E3 EE                      	out	dx,al			; disable video output on CGA
   767 000020E4 FEC0                    	inc	al
   768 000020E6 BAB803                  	mov	dx,mda_mode_reg		; disable video output on MDA
   769 000020E9 EE                      	out	dx,al			; and set MDA high-resolution mode bit
   770                                  
   771                                  ;-------------------------------------------------------------------------
   772                                  ; Initialize DMAC (8237)
   773                                   
   774 000020EA B003                    	mov	al,e_init_dmac
   775 000020EC E680                    	out	post_reg,al
   776 000020EE E60D                     	out	0Dh,al			; DMA Master Clear register - reset DMA
   777                                  %ifdef MACHINE_XT
   778                                  					; set up DRAM refresh on DMA channel 0
   779                                  	mov	al,0ffh			; 16-bit memory refresh counter = 0FFFFh
   780                                  	out	dmac_ch0_count_reg,al	; write low byte
   781                                  	nop
   782                                  	out	dmac_ch0_count_reg,al	; write high byte
   783                                  	inc	ax			; al = 0
   784                                  	out	dmac_mask_reg,al	; enable DMA channel 0
   785                                  	mov	al,58h			; single mode, auto-init, read, channel 0
   786                                  %else ; MACHINE_XT
   787 000020F0 B040                     	mov	al,40h			; single mode, verify, channel 0
   788                                  %endif ; MACHINE_XT
   789 000020F2 E60B                     	out	dmac_mode_reg,al	; DMA Mode register
   790 000020F4 B041                     	mov	al,41h			; single mode, verify, channel 1
   791 000020F6 E60B                     	out	dmac_mode_reg,al	; DMA Mode register
   792 000020F8 B042                     	mov	al,42h			; single mode, verify, channel 2
   793 000020FA E60B                     	out	dmac_mode_reg,al	; DMA Mode register
   794 000020FC B043                     	mov	al,43h			; single mode, verify, channel 3
   795 000020FE E60B                     	out	dmac_mode_reg,al	; DMA Mode register
   796 00002100 B000                     	mov	al,0			; DMA Command register bits:
   797                                   					; DACK active low, DREQ active high,
   798                                   					; late write, fixed priority,
   799                                   					; normal timing, controller enable
   800                                   					; channel 0 addr hold disable
   801                                   					; memory to memory disable
   802 00002102 E608                     	out	08h,al			; DMA Command register
   803 00002104 E681                     	out	81h,al			; DMA Page, channel 2
   804 00002106 E682                     	out	82h,al			; DMA Page, channel 3
   805 00002108 E683                     	out	83h,al			; DMA Page, channels 0,1
   806                                  
   807                                  ;-------------------------------------------------------------------------
   808                                  ; Test first 32 KiB (MIN_RAM_SIZE) of RAM
   809                                  
   810 0000210A B004                    	mov	al,e_low_ram_test
   811 0000210C E680                    	out	post_reg,al
   812 0000210E 31F6                    	xor	si,si
   813 00002110 31FF                    	xor	di,di
   814 00002112 8EDF                    	mov	ds,di
   815 00002114 8EC7                    	mov	es,di
   816 00002116 8B167204                	mov	dx,word [warm_boot+biosdseg*16] ; save soft reset flag to DX
   817 0000211A B8AA55                  	mov	ax,55AAh		; first test pattern
   818 0000211D B90040                  	mov	cx,MIN_RAM_SIZE*512	; RAM size to test in words
   819 00002120 F3AB                        rep	stosw				; store test pattern
   820 00002122 B90040                  	mov	cx,MIN_RAM_SIZE*512	; RAM size to test in words
   821                                  .1:
   822 00002125 AD                      	lodsw
   823 00002126 3DAA55                  	cmp	ax,55AAh		; compare to the test pattern
   824 00002129 7524                    	jne	low_ram_fail
   825 0000212B E2F8                    	loop	.1
   826 0000212D 31F6                    	xor	si,si
   827 0000212F 31FF                    	xor	di,di
   828 00002131 B855AA                  	mov	ax,0AA55h		; second test pattern
   829 00002134 B90040                  	mov	cx,MIN_RAM_SIZE*512	; RAM size to test in words
   830 00002137 F3AB                        rep stosw				; store test pattern
   831 00002139 B90040                  	mov	cx,MIN_RAM_SIZE*512	; RAM size to test in words
   832                                  .2:
   833 0000213C AD                      	lodsw
   834 0000213D 3D55AA                  	cmp	ax,0AA55h		; compare to the test pattern
   835 00002140 750D                    	jne	low_ram_fail
   836 00002142 E2F8                    	loop	.2
   837 00002144 31FF                    	xor	di,di
   838 00002146 31C0                    	xor	ax,ax			; zero
   839 00002148 B90040                  	mov	cx,MIN_RAM_SIZE*512	; RAM size to test in words
   840 0000214B F3AB                        rep stosw				; zero the memory
   841 0000214D EB27                    	jmp	low_ram_ok		; test passed
   842                                  
   843                                  low_ram_fail:
   844 0000214F B054                    	mov	al,e_low_ram_fail	; test failed
   845 00002151 E680                    	out	post_reg,al
   846                                  
   847                                  ;-------------------------------------------------------------------------
   848                                  ;  Low memory error: beep - pause - beep - pause ... - 400 Hz
   849                                  
   850 00002153 B0B6                    	mov	al,0B6h
   851 00002155 E643                    	out	pit_ctl_reg,al		; PIT - channel 2 mode 3
   852 00002157 B8A60B                  	mov	ax,pic_freq/400		; 400 Hz signal
   853 0000215A E642                    	out	pit_ch2_reg,al
   854 0000215C 88E0                    	mov	al,ah
   855 0000215E E642                    	out	pit_ch2_reg,al
   856                                  %ifndef MACHINE_BOOK8088
   857                                  	in	al,ppi_pb_reg
   858                                  %endif ; MACHINE_BOOK8088
   859                                  .1:
   860                                  %ifndef MACHINE_BOOK8088
   861                                  	or	al,3			; turn speaker on and enable
   862                                  					; PIT channel 2 to speaker
   863                                  %else ; MACHINE_BOOK8088
   864 00002160 B003                    	mov	al,3			; turn speaker on and enable
   865                                  					; PIT channel 2 to speaker
   866                                  %endif ; MACHINE_BOOK8088
   867 00002162 E661                    	out	ppi_pb_reg,al
   868 00002164 B90000                  	mov	cx,0
   869                                  .2:
   870 00002167 90                      	nop
   871 00002168 E2FD                    	loop	.2
   872                                  %ifndef MACHINE_BOOK8088
   873                                  	and	al,0FCh			; turn of speaker
   874                                  %else ; MACHINE_BOOK8088
   875 0000216A B000                    	mov	al,0			; turn of speaker
   876                                  %endif ; MACHINE_BOOK8088
   877 0000216C E661                    	out	ppi_pb_reg,al
   878 0000216E B90000                  	mov	cx,0
   879                                  .3:
   880 00002171 90                      	nop
   881 00002172 E2FD                    	loop	.3
   882 00002174 EBEA                    	jmp	.1
   883                                  
   884                                  ;-------------------------------------------------------------------------
   885                                  ; Low memory test passed
   886                                  
   887                                  low_ram_ok:
   888 00002176 89167204                	mov	word [warm_boot+biosdseg*16],dx ; restore soft reset flag
   889                                  
   890                                  ;-------------------------------------------------------------------------
   891                                  ; Set up stack - using upper 256 bytes of interrupt table
   892                                  
   893 0000217A B83000                  	mov	ax,0030h
   894 0000217D 8ED0                    	mov	ss,ax
   895 0000217F BC0001                  	mov	sp,0100h
   896                                  
   897                                  ;-------------------------------------------------------------------------
   898                                  ; Initialize interrupt table
   899                                  
   900 00002182 B005                    	mov     al,e_int_table
   901 00002184 E680                    	out	post_reg,al
   902 00002186 0E                      	push	cs
   903 00002187 1F                      	pop	ds
   904 00002188 31FF                    	xor	di,di
   905 0000218A 8EC7                    	mov	es,di
   906 0000218C BE[3718]                	mov	si,interrupt_table
   907 0000218F B92000                  	mov	cx,0020h		; 32 Interrupt vectors
   908 00002192 B800F0                  	mov	ax,bioscseg
   909                                  .1:
   910 00002195 A5                      	movsw				; copy ISR address (offset part)
   911 00002196 AB                      	stosw				; store segment part
   912 00002197 E2FC                    	loop	.1
   913                                  %ifdef SECOND_PIC
   914                                  	mov	di,70h*4		; starting from IRQ 70
   915                                  	mov	si,interrupt_table2
   916                                  	mov	cx,8			; 8 Interrupt vectors
   917                                  .2:
   918                                  	movsw				; copy ISR address (offset part)
   919                                  	stosw				; store segment part
   920                                  	loop	.2
   921                                  %endif ; SECOND_PIC
   922                                  
   923                                  ;-------------------------------------------------------------------------
   924                                  ; set DS to BIOS data area
   925                                  
   926 00002199 B84000                  	mov	ax,biosdseg		; DS = BIOS data area
   927 0000219C 8ED8                    	mov	ds,ax
   928                                  
   929                                  ;-------------------------------------------------------------------------
   930                                  ; Initialize PIT (8254 timer)
   931                                  
   932 0000219E B036                    	mov	al,36h			; channel 0, LSB & MSB, mode 3, binary
   933 000021A0 E643                    	out	pit_ctl_reg,al
   934 000021A2 B000                    	mov	al,0
   935 000021A4 E640                    	out	pit_ch0_reg,al
   936 000021A6 E640                    	out	pit_ch0_reg,al
   937 000021A8 B054                    	mov	al,54h			; channel 1, LSB only, mode 2, binary
   938 000021AA E643                    	out	pit_ctl_reg,al		; used for DRAM refresh on IBM PC/XT/AT
   939 000021AC B012                    	mov	al,12h			; or for delays (using port_b, bit 4)
   940 000021AE E641                    	out	pit_ch1_reg,al		; pulse every 15ms
   941                                  
   942                                  ;-------------------------------------------------------------------------
   943                                  ; Play "power on" sound - also tests PIT functionality
   944                                  
   945 000021B0 B006                    	mov     al,e_pit_init
   946 000021B2 E680                    	out	post_reg,al
   947 000021B4 E871F4                  	call	sound
   948                                  
   949                                  ;-------------------------------------------------------------------------
   950                                  ; Initialize PIC (8259)
   951                                  
   952 000021B7 B007                    	mov	al,e_pic_init
   953 000021B9 E680                    	out	post_reg,al
   954                                  %ifdef SECOND_PIC
   955                                  	mov	al,11h			; ICW1 - edge triggered, cascade, ICW4
   956                                  	out	pic1_reg0,al
   957                                  	out	pic2_reg0,al
   958                                  	mov	al,8			; ICW2 - interrupt vector offset = 8
   959                                  	out	pic1_reg1,al
   960                                  	mov	al,70h			; ICW2 - interrupt vector offset = 70h
   961                                  	out	pic2_reg1,al
   962                                  	mov	al,4			; ICW3 - slave is connected to IR2
   963                                  	out	pic1_reg1,al
   964                                  	mov	al,2			; ICW3 - slave ID = 2 (IR2)
   965                                  	out	pic2_reg1,al
   966                                  	mov	al,1			; ICW4 - 8086/8088
   967                                  	out	pic1_reg1,al
   968                                  	out	pic2_reg1,al
   969                                  %else
   970 000021BB B013                    	mov	al,13h			; ICW1 - edge triggered, single, ICW4
   971 000021BD E620                    	out	pic1_reg0,al
   972 000021BF B008                    	mov	al,8			; ICW2 - interrupt vector offset = 8
   973 000021C1 E621                    	out	pic1_reg1,al
   974 000021C3 B009                    	mov	al,9			; ICW4 - buffered mode, 8086/8088
   975 000021C5 E621                    	out	pic1_reg1,al
   976                                  %endif ; SECOND_PIC
   977                                  
   978                                  ;-------------------------------------------------------------------------
   979                                  ; initialize keyboard controller (8242), keyboard and PS/2 auxiliary device
   980                                  
   981 000021C7 B008                    	mov	al,e_kbd_init
   982 000021C9 E680                    	out	post_reg,al
   983                                  %ifdef AT_KEYBOARD
   984                                  	call	kbc_init
   985                                  %else ; AT_KEYBOARD
   986                                  %ifndef MACHINE_BOOK8088
   987                                  	in	al,ppi_pb_reg
   988                                  	and	al,00111111b		; set keyboard clock low
   989                                  	out	ppi_pb_reg,al
   990                                  	mov	cx,10582		; hold clock low for 20 ms
   991                                  .kbd_reset_wait:
   992                                  	loop	.kbd_reset_wait
   993                                  	or	al,11000000b		; set keyboard clear bit, enable clock
   994                                  	out	ppi_pb_reg,al
   995                                  	and	al,01111111b		; unset keyboard clear bit
   996                                  	out	ppi_pb_reg,al
   997                                  %endif ; MACHINE_BOOK8088
   998 000021CB B9E803                  	mov	cx,1000
   999                                  .kbd_flush:
  1000 000021CE B401                    	mov 	ah,01h
  1001 000021D0 CD16                    	int	16h
  1002 000021D2 7404                    	jz	.kbd_no_key
  1003 000021D4 B400                    	mov	ah,00h
  1004 000021D6 CD16                    	int	16h
  1005                                  .kbd_no_key:
  1006 000021D8 E2F4                    	loop	.kbd_flush
  1007                                  
  1008                                  %endif ; AT_KEYBOARD
  1009                                  
  1010 000021DA E8C609                  	call	kbd_buffer_init		; setup keyboard buffer
  1011                                  
  1012                                  ;-------------------------------------------------------------------------
  1013                                  ; enable interrupts
  1014                                  
  1015 000021DD B009                    	mov	al,e_int_ena
  1016 000021DF E680                    	out	post_reg,al
  1017                                  %ifdef SECOND_PIC
  1018                                  	mov	al,0B8h		; OSW1: unmask timer, keyboard, IRQ2 and FDC
  1019                                  	out	pic1_reg1,al
  1020                                  %ifndef PS2_MOUSE
  1021                                  	mov	al,0FDh		; OSW1: unmask IRQ9
  1022                                  %else
  1023                                  	mov	al,0EDh		; OSW1: unmask IRQ9 and IRQ12
  1024                                  %endif ; PS2_MOUSE
  1025                                  	out	pic2_reg1,al
  1026                                  %else
  1027 000021E1 B0BC                    	mov	al,0BCh		; OSW1: unmask timer, keyboard and FDC
  1028 000021E3 E621                    	out	pic1_reg1,al
  1029                                  %endif ; SECOND_PIC
  1030 000021E5 FB                      	sti
  1031                                  
  1032 000021E6 B080                    	mov	al,nmi_enable
  1033 000021E8 E6A0                    	out	nmi_mask_reg,al	; enable NMIs
  1034                                  
  1035                                  %ifdef MACHINE_FE2010A or MACHINE_XT
  1036                                  ;-------------------------------------------------------------------------
  1037                                  ; Read video mode switches into equipment_list
  1038                                  	in	al,ppi_pb_reg
  1039                                  %ifdef MACHINE_FE2010A
  1040                                  	and	al,0FDh		; clear switch select bit - select SW5-SW8
  1041                                  %endif ; MACHINE_FE2010A
  1042                                  %ifdef MACHINE_XT
  1043                                  	or	al,08h		; set switch select bit - select SW5-SW8
  1044                                  %endif ; MACHINE_XT
  1045                                  	out	ppi_pb_reg,al
  1046                                  	in	al,ppi_pc_reg	; read switches SW5-SW8
  1047                                  	and	al,03h		; video mode is in SW5 and SW6
  1048                                  	mov	cl,4
  1049                                  	shl	al,cl		; move video mode to bits 5-4
  1050                                  	or	[equipment_list],al
  1051                                  %endif ; MACHINE_FE2010A or MACHINE_XT
  1052                                  %ifdef MACHINE_BOOK8088
  1053 000021EA 800E100020              	or	byte [equipment_list],equip_color_80 ; built-in CGA
  1054                                  %endif ; MACHINE_BOOK8088
  1055                                  ; 
  1056                                  ;-------------------------------------------------------------------------
  1057                                  ; look for video BIOS, initialize it if present
  1058                                  
  1059 000021EF B010                    	mov	al,e_vid_bios_scan
  1060 000021F1 E680                    	out	post_reg,al
  1061 000021F3 BA00C0                  	mov	dx,0C000h
  1062 000021F6 BB00C8                  	mov	bx,0C800h
  1063 000021F9 E89A16                  	call	extension_scan
  1064 000021FC 833E670000              	cmp	word [67h],0
  1065 00002201 740F                    	jz	.no_video_bios
  1066 00002203 B011                    	mov	al,e_vid_bios_init
  1067 00002205 E680                    	out	post_reg,al
  1068 00002207 FF1E6700                	call	far [67h]
  1069 0000220B B84000                  	mov	ax,biosdseg		; DS = BIOS data area
  1070 0000220E 8ED8                    	mov	ds,ax
  1071                                  ; set video bits to 00 - EGA or later (Video adapter with BIOS)		
  1072                                  ;	and	word [equipment_list],~equip_video
  1073 00002210 EB1F                    	jmp	.video_initialized
  1074                                  
  1075                                  .no_video_bios:
  1076 00002212 B012                    	mov	al,e_vid_no_bios
  1077 00002214 E680                    	out	post_reg,al
  1078 00002216 8A261000                	mov	ah,byte [equipment_list] ; get equipment - low byte
  1079 0000221A 80E430                  	and	ah,equip_video		; get video adapter type
  1080 0000221D B007                    	mov	al,07h			; monochrome 80x25 mode
  1081 0000221F 80FC30                  	cmp	ah,equip_mono		; monochrome?
  1082 00002222 7409                    	jz	.set_mode
  1083 00002224 B003                    	mov	al,03h			; color 80x25 mode
  1084 00002226 80FC20                  	cmp	ah,equip_color_80	; 80x25 color?
  1085 00002229 7402                    	jz	.set_mode
  1086 0000222B B001                    	mov	al,01h			; color 40x24 mode
  1087                                  
  1088                                  .set_mode:
  1089 0000222D B400                    	mov	ah,00h			; INT 10, AH=00 - Set video mode
  1090 0000222F CD10                    	int	10h
  1091                                  
  1092                                  .video_initialized:
  1093                                  
  1094                                  ;-------------------------------------------------------------------------
  1095                                  ; print the copyright message
  1096                                  
  1097 00002231 BE[0000]                	mov	si,msg_copyright
  1098 00002234 E85CF5                  	call	print
  1099                                  
  1100                                  %ifdef AT_RTC
  1101                                  
  1102                                  ;-------------------------------------------------------------------------
  1103                                  ; Initialize RTC / NVRAM
  1104                                  ; Read equipment byte from CMOS and set it in BIOS data area
  1105                                  	call	rtc_init
  1106                                  
  1107                                  %endif ; AT_RTC
  1108                                  
  1109                                  %ifdef BIOS_SETUP
  1110                                  	mov	si,msg_setup		; print setup prompt
  1111                                  	call	print
  1112                                  %endif ; BIOS_SETUP
  1113                                  
  1114                                  
  1115                                  ;-------------------------------------------------------------------------
  1116                                  ; detect and print availability of various equipment
  1117                                  
  1118 00002237 E83EF4                  	call	detect_cpu		; detect and print CPU type
  1119 0000223A E8D5F4                  	call	detect_fpu		; detect and print FPU presence
  1120                                  %ifdef MACHINE_FE2010A
  1121                                  	call	detect_chipset		; detect and print chipset type
  1122                                  %endif ; MACHINE_FE2010A
  1123                                  %ifdef AT_RTC
  1124                                  	call	print_rtc		; print current RTC time
  1125                                  %endif ; AT_RTC
  1126 0000223D E8C6F5                  	call	print_display		; print display type
  1127                                  %ifdef PS2_MOUSE
  1128                                  	call	print_mouse		; print mouse presence
  1129                                  %endif ; PS2_MOUSE
  1130 00002240 E88BF2                  	call	detect_serial		; detect serial ports and print findings
  1131 00002243 E83EF3                  	call	detect_parallel		; detect parallel ports and print
  1132                                  					; findings
  1133 00002246 E843ED                  	call	detect_floppy		; detect floppy drive types
  1134 00002249 E875ED                  	call	print_floppy		; print floppy drive types
  1135                                  
  1136 0000224C E89315                  	call	detect_ram		; detect RAM, get RAM size in AX
  1137 0000224F E80817                  	call	test_ram		; test RAM, get tested RAM size in AX
  1138                                  
  1139 00002252 BE[5103]                	mov	si,msg_ram_total
  1140 00002255 E83BF5                  	call	print
  1141 00002258 E875F5                  	call	print_dec		; print RAM size
  1142 0000225B BE[6F03]                	mov	si,msg_kib
  1143 0000225E E832F5                  	call	print
  1144                                  
  1145                                  ; FE2010A - Configure chipset according to detected equipment
  1146                                  %ifdef MACHINE_FE2010A
  1147                                  ; Write settings for emulated DIP switches
  1148                                  	mov	al,byte [equipment_list] ; switches are in low byte of equipment
  1149                                  	and	al,0CEh			; keep floppy, memory size, and FPU bits
  1150                                  	out	fe_control_reg,al
  1151                                  ; Enable FPU NMI if needed, and lock chipset configuration
  1152                                  	and	al,equip_fpu		; enable NMI if the FPU is installed
  1153                                  	or	al,fe_config_lock	; set lock chipset configuration bit
  1154                                  	out	fe_config_reg,al
  1155                                  %endif ; MACHINE_FE2010A
  1156                                  
  1157                                  %ifdef EBDA_SIZE
  1158                                  	call	reserve_ebda		; reserve EBDA if needed
  1159                                  
  1160                                  	mov	si,msg_ram_avail
  1161                                  	call	print
  1162                                  	mov	ax,word [memory_size]
  1163                                  	call	print_dec		; print remaining RAM size
  1164                                  	mov	si,msg_kib
  1165                                  	call	print
  1166                                  %endif ; EBDA_SIZE
  1167                                  
  1168 00002261 E83615                  	call	detect_rom_ext		; detect and initialize extension ROMs
  1169                                  
  1170 00002264 E905F5                  	jmp boot_os
  1171                                  
  1172                                  ;=========================================================================
  1173                                  ; int_02 - NMI
  1174                                  ; Note: Xi 8088 only implements IOCHK NMI, system board parity is not
  1175                                  ;	implemented
  1176                                  ;-------------------------------------------------------------------------
  1177 00002267 FF<rep 5Ch>             	setloc	0E2C3h			; NMI Entry Point
  1177          ******************       warning: Inserting 92 bytes [-w+user]
  1178                                  int_02:
  1179 000022C3 50                      	push	ax
  1180                                  %ifdef AT_NMI
  1181                                  	mov	al,0Dh & nmi_disa_mask
  1182                                  	call	rtc_read		; disable NMI
  1183                                  %else
  1184 000022C4 B000                    	mov	al,nmi_disable
  1185 000022C6 E6A0                    	out	nmi_mask_reg,al
  1186                                  %endif ; AT_NMI
  1187                                  %ifndef MACHINE_BOOK8088
  1188                                  	in	al,ppi_pb_reg		; read Port B
  1189                                  	mov	ah,al
  1190                                  	or	al,iochk_disable	; clear and disable ~IOCHK
  1191                                  	out	ppi_pb_reg,al
  1192                                  	test	al,iochk_status
  1193                                  	jnz	.iochk_nmi
  1194                                  	mov	al,ah
  1195                                  	out	ppi_pb_reg,al		; restore original bits
  1196                                  	jmp	.exit
  1197                                  
  1198                                  .iochk_nmi:
  1199                                  	push	si
  1200                                  	mov	si,msg_iochk_nmi
  1201                                  	call	print
  1202                                  	pop	si
  1203                                  .1:
  1204                                  	mov	ah,0h
  1205                                  	int	16h
  1206                                  	or	al,20h			; convert to lower case
  1207                                  	cmp	al,'d'
  1208                                  	je	.exit			; leave NMIs disabled and exit
  1209                                  	cmp	al,'i'
  1210                                  	je	.ignore			; enable NMIs and exit
  1211                                  	cmp	al,'r'
  1212                                  	je	cold_start
  1213                                  	jmp	.1
  1214                                  .ignore:
  1215                                  %ifdef AT_NMI
  1216                                  	mov	al,0Dh | nmi_enable
  1217                                  	call	rtc_read		; enable NMI
  1218                                  %else
  1219                                  	mov	al,nmi_enable
  1220                                  	out	nmi_mask_reg,al
  1221                                  %endif ; AT_NMI
  1222                                  %else ; MACHINE_BOOK8088
  1223                                  ; It is not clear if BOOK8088 implements any I/O Channel Check logic all all
  1224                                  ; but since ppi_pb_reg is read-only, lets attempt to pulse the iochk_disable
  1225                                  ; to clear the I/O Channel Check flip-flop
  1226 000022C8 B008                    	mov	al,iochk_disable	; clear and disable ~IOCHK
  1227 000022CA E661                    	out	ppi_pb_reg,al
  1228 000022CC B000                    	mov	al,0			; clear all bits
  1229 000022CE E661                    	out	ppi_pb_reg,al
  1230                                  %endif ; MACHINE_BOOK8088
  1231                                  .exit:
  1232 000022D0 58                      	pop	ax
  1233 000022D1 CF                      	iret
  1234                                  
  1235                                  msg_iochk_nmi:
  1236 000022D2 494F43484B204E4D49-     	db	"IOCHK NMI detected. Type 'i' to ignore, 'd' to disable NMIs, or 'r' to reboot."
  1236 000022DB 206465746563746564-
  1236 000022E4 2E2054797065202769-
  1236 000022ED 2720746F2069676E6F-
  1236 000022F6 72652C202764272074-
  1236 000022FF 6F2064697361626C65-
  1236 00002308 204E4D49732C206F72-
  1236 00002311 2027722720746F2072-
  1236 0000231A 65626F6F742E       
  1237 00002320 0D0A00                  	db	0Dh, 0Ah, 00h
  1238                                  
  1239                                  ;=========================================================================
  1240                                  ; int_18 - execute ROM BASIC
  1241                                  ; Note:
  1242                                  ;	Prints an error message since we don't have ROM BASIC
  1243                                  ;-------------------------------------------------------------------------
  1244                                  int_18:
  1245 00002323 BE[A303]                	mov	si,msg_no_basic
  1246 00002326 E86AF4                  	call	print
  1247                                  .1:
  1248 00002329 F4                      	hlt
  1249 0000232A EBFD                    	jmp	.1
  1250                                  
  1251                                  ;=========================================================================
  1252                                  ; int_19 - load and execute the boot sector
  1253                                  ;-------------------------------------------------------------------------
  1254 0000232C FF<rep 3C6h>            	setloc	0E6F2h			; INT 19 Entry Point
  1254          ******************       warning: Inserting 966 bytes [-w+user]
  1255                                  int_19:
  1256 000026F2 E9F311                  	jmp	ipl
  1257                                  
  1258                                  ;=========================================================================
  1259                                  ; configuration data table
  1260                                  ;-------------------------------------------------------------------------
  1261                                  	setloc	0E6F5h
  1262                                  config_table:
  1263 000026F5 0800                    	dw	.size			; bytes 0 and 1: size of the table
  1264                                  .bytes:
  1265 000026F7 FE                      	db	MODEL_BYTE		; byte 2: model
  1266 000026F8 00                      	db	00h			; byte 3: submodel = 0
  1267 000026F9 00                      	db	00h			; byte 4: release = 0
  1268                                  %ifdef SECOND_PIC
  1269                                  %ifdef AT_RTC
  1270                                  	db	01110000b		; byte 5: feature byte 1
  1271                                  ;		|||||||`-- system has dual bus (ISA and MCA)
  1272                                  ;		||||||`-- bus is Micro Channel instead of ISA
  1273                                  ;		|||||`-- extended BIOS area allocated (usually on top of RAM)
  1274                                  ;		||||`-- wait for external event (INT 15h/AH=41h) supported
  1275                                  ;		|||`-- INT 15h/AH=4Fh called upon INT 09h
  1276                                  ;		||`-- real time clock installed
  1277                                  ;		|`-- 2nd interrupt controller installed
  1278                                  ;		`-- DMA channel 3 used by hard disk BIOS
  1279                                  %else ; AT_RTC
  1280                                  	db	01010000b		; byte 5: feature byte 1
  1281                                  ;		|||||||`-- system has dual bus (ISA and MCA)
  1282                                  ;		||||||`-- bus is Micro Channel instead of ISA
  1283                                  ;		|||||`-- extended BIOS area allocated (usually on top of RAM)
  1284                                  ;		||||`-- wait for external event (INT 15h/AH=41h) supported
  1285                                  ;		|||`-- INT 15h/AH=4Fh called upon INT 09h
  1286                                  ;		||`-- real time clock installed
  1287                                  ;		|`-- 2nd interrupt controller installed
  1288                                  ;		`-- DMA channel 3 used by hard disk BIOS
  1289                                  %endif ; AT_RTC
  1290                                  %else ; SECOND_PIC
  1291                                  %ifdef AT_RTC
  1292                                  	db	00100000b		; byte 5: feature byte 1
  1293                                  ;		|||||||`-- system has dual bus (ISA and MCA)
  1294                                  ;		||||||`-- bus is Micro Channel instead of ISA
  1295                                  ;		|||||`-- extended BIOS area allocated (usually on top of RAM)
  1296                                  ;		||||`-- wait for external event (INT 15h/AH=41h) supported
  1297                                  ;		|||`-- INT 15h/AH=4Fh called upon INT 09h
  1298                                  ;		||`-- real time clock installed
  1299                                  ;		|`-- 2nd interrupt controller installed
  1300                                  ;		`-- DMA channel 3 used by hard disk BIOS
  1301                                  %else ; AT_RTC
  1302 000026FA 00                      	db	00000000b		; byte 5: feature byte 1
  1303                                  ;		|||||||`-- system has dual bus (ISA and MCA)
  1304                                  ;		||||||`-- bus is Micro Channel instead of ISA
  1305                                  ;		|||||`-- extended BIOS area allocated (usually on top of RAM)
  1306                                  ;		||||`-- wait for external event (INT 15h/AH=41h) supported
  1307                                  ;		|||`-- INT 15h/AH=4Fh called upon INT 09h
  1308                                  ;		||`-- real time clock installed
  1309                                  ;		|`-- 2nd interrupt controller installed
  1310                                  ;		`-- DMA channel 3 used by hard disk BIOS
  1311                                  %endif ; AT_RTC
  1312                                  %endif ; SECOND_PIC
  1313 000026FB 00                      	db	00h			; byte 6: feature byte 2
  1314 000026FC 00                      	db	00h			; byte 7: feature byte 3
  1315 000026FD 00                      	db	00h			; byte 8: feature byte 4
  1316 000026FE 00                      	db	00h			; byte 9: feature byte 5
  1317                                  .size	equ	$-.bytes
  1318                                  
  1319                                  ;=========================================================================
  1320                                  ; Includes with fixed entry points (for IBM compatibility)
  1321                                  ;-------------------------------------------------------------------------
  1322                                  
  1323                                  %include	"serial2.inc"		; INT 14 - BIOS Serial Communications
  1324                              <1> ;========================================================================
  1325                              <1> ; serial2.inc -  BIOS Serial Port Communication Services (part 2 of 2)
  1326                              <1> ;       INT 14h, function AH=00h
  1327                              <1> ;       INT 14h, function AH=03h
  1328                              <1> ;       INT 14h, function AH=04h
  1329                              <1> ;       INT 14h, function AH=05h
  1330                              <1> ;	- see serial1.inc for other INT 14h functions
  1331                              <1> ;-------------------------------------------------------------------------
  1332                              <1> ;
  1333                              <1> ; Compiles with NASM 2.13.02, might work with other versions
  1334                              <1> ;
  1335                              <1> ; Copyright (C) 2010 - 2023 Sergey Kiselev.
  1336                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
  1337                              <1> ;
  1338                              <1> ; This program is free software: you can redistribute it and/or modify
  1339                              <1> ; it under the terms of the GNU General Public License as published by
  1340                              <1> ; the Free Software Foundation, either version 3 of the License, or
  1341                              <1> ; (at your option) any later version.
  1342                              <1> ;
  1343                              <1> ; This program is distributed in the hope that it will be useful,
  1344                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  1345                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  1346                              <1> ; GNU General Public License for more details.
  1347                              <1> ;
  1348                              <1> ; You should have received a copy of the GNU General Public License
  1349                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  1350                              <1> ;
  1351                              <1> ;=========================================================================
  1352                              <1> 
  1353                              <1> ;=========================================================================
  1354                              <1> ; int_14 - BIOS Serial Port Communication Services
  1355                              <1> ;-------------------------------------------------------------------------
  1356 000026FF FF<rep 2Ah>         <1> 	setloc	0E729h			; INT 14 Entry Point
  1356          ******************  <1>  warning: Inserting 42 bytes [-w+user]
  1357                              <1> int_14:
  1358 00002729 FB                  <1> 	sti
  1359 0000272A 51                  <1> 	push	cx
  1360 0000272B 52                  <1> 	push	dx
  1361 0000272C 56                  <1> 	push	si
  1362 0000272D 1E                  <1> 	push	ds
  1363 0000272E 53                  <1> 	push	bx
  1364 0000272F BB4000              <1> 	mov	bx,biosdseg
  1365 00002732 8EDB                <1> 	mov	ds,bx
  1366 00002734 80FC06              <1> 	cmp	ah,.max/2
  1367 00002737 732B                <1> 	jae	int_14_error		; invalid function number specified
  1368 00002739 83FA04              <1> 	cmp	dx,num_serial
  1369 0000273C 7326                <1> 	jae	int_14_error		; invalid port number specified
  1370 0000273E BE7C00              <1> 	mov	si,serial_timeout	; serial port timeout setting in BDA
  1371 00002741 01D6                <1> 	add	si,dx			; [SI] = timeout for the selected port
  1372 00002743 89D3                <1> 	mov	bx,dx
  1373 00002745 D1E3                <1> 	shl	bx,1
  1374 00002747 8B17                <1> 	mov	dx,word [equip_serial+bx] ; DX = serial port address
  1375 00002749 09D2                <1> 	or	dx,dx
  1376 0000274B 7417                <1> 	jz	int_14_error		; specified port is not installed
  1377 0000274D B700                <1> 	mov	bh,0
  1378 0000274F 88E3                <1> 	mov	bl,ah
  1379 00002751 D1E3                <1> 	shl	bx,1
  1380 00002753 2EFFA7[5827]        <1>     cs	jmp	near [.dispatch+bx]
  1381                              <1> .dispatch:
  1382 00002758 [6C27]              <1> 	dw	int_14_fn00
  1383 0000275A [6F14]              <1> 	dw	int_14_fn01
  1384 0000275C [8A14]              <1> 	dw	int_14_fn02
  1385 0000275E [A127]              <1> 	dw	int_14_fn03
  1386 00002760 [AB27]              <1> 	dw	int_14_fn04
  1387 00002762 [0528]              <1> 	dw	int_14_fn05
  1388                              <1> .max	equ	$-.dispatch
  1389                              <1> 
  1390                              <1> int_14_error:
  1391 00002764 31C0                <1> 	xor	ax,ax
  1392                              <1> 
  1393                              <1> int_14_exit:
  1394 00002766 5B                  <1> 	pop	bx
  1395 00002767 1F                  <1> 	pop	ds
  1396 00002768 5E                  <1> 	pop	si
  1397 00002769 5A                  <1> 	pop	dx
  1398 0000276A 59                  <1> 	pop	cx
  1399 0000276B CF                  <1> 	iret
  1400                              <1> 
  1401                              <1> ;=========================================================================
  1402                              <1> ; int_14_fn00 - Initialize serial port
  1403                              <1> ; Input:
  1404                              <1> ;	AH = 0 - function 00h - initialize serial port
  1405                              <1> ;	AL - initialization parameters
  1406                              <1> ;		bit 1,0	= 10	- 7 data bits
  1407                              <1> ;			= 11	- 8 data bits
  1408                              <1> ;		bit 2	= 0	- 1 stop bit
  1409                              <1> ;			= 1	- 2 stop bits
  1410                              <1> ;		bit 3	= 0	- parity disable
  1411                              <1> ;			= 1	- parity enable
  1412                              <1> ;		bit 4	= 0	- odd parity (if parity enabled)
  1413                              <1> ;			= 1	- even parity (if parity enabled)
  1414                              <1> ;		bit 7-5 = 000	- 110 bps
  1415                              <1> ;			= 001	- 150 bps
  1416                              <1> ;			= 010	- 300 bps
  1417                              <1> ;			= 011	- 600 bps
  1418                              <1> ;			= 100	- 1200 bps
  1419                              <1> ;			= 101	- 2400 bps
  1420                              <1> ;			= 110	- 4800 bps
  1421                              <1> ;			= 111	- 9600 bps
  1422                              <1> ;	DX = serial port number (0-3)
  1423                              <1> ; Output:
  1424                              <1> ;	AL = modem status
  1425                              <1> ;		bit 0	= 1	- delta clear to send
  1426                              <1> ;		bit 1	= 1	- delta data set ready
  1427                              <1> ;		bit 2	= 1	- trailing edge ring indicator
  1428                              <1> ;		bit 3	= 1	- delta data carrier detect
  1429                              <1> ;		bit 4	= 1	- clear to send
  1430                              <1> ;		bit 5	= 1	- data set ready
  1431                              <1> ;		bit 6	= 1	- ring indicator
  1432                              <1> ;		bit 7	= 1	- data carrier detect
  1433                              <1> ;	AH = line status
  1434                              <1> ;		bit 0	= 1	- data ready
  1435                              <1> ;		bit 1	= 1	- overrun error
  1436                              <1> ;		bit 2	= 1	- parity error
  1437                              <1> ;		bit 3	= 1	- framing error
  1438                              <1> ;		bit 4	= 1	- break interrupt
  1439                              <1> ;		bit 5	= 1	- transmitter holding register
  1440                              <1> ;		bit 6	= 1	- transmitter empty
  1441                              <1> ;		bit 7	= 1	- error in RCVR FIFO
  1442                              <1> ;-------------------------------------------------------------------------
  1443                              <1> int_14_fn00:
  1444 0000276C 88C4                <1> 	mov	ah,al			; save AL to AH
  1445 0000276E 83C203              <1> 	add	dx,uart_lcr_reg		; DX = UART LCR address
  1446 00002771 B080                <1> 	mov	al,uart_lcr_ldiv	; AL = LCR load divisor bit
  1447 00002773 EE                  <1> 	out	dx,al
  1448 00002774 31DB                <1> 	xor	bx,bx
  1449 00002776 88E3                <1> 	mov	bl,ah
  1450 00002778 80E3E0              <1> 	and	bl,0E0h			; get divisor bits from init params
  1451 0000277B D0EB                <1> 	shr	bl,1
  1452 0000277D D0EB                <1> 	shr	bl,1
  1453 0000277F D0EB                <1> 	shr	bl,1
  1454 00002781 D0EB                <1> 	shr	bl,1
  1455 00002783 2E8B9F[5815]        <1>     cs	mov	bx,word [uart_divisors+bx] ; get the divisor value
  1456 00002788 83EA03              <1> 	sub	dx,uart_lcr_reg		; DX = UART base address
  1457 0000278B 88D8                <1> 	mov	al,bl
  1458 0000278D EE                  <1> 	out	dx,al			; output divisor - low byte
  1459 0000278E 42                  <1> 	inc	dx			; DX = UART base address + 1
  1460 0000278F 88F8                <1> 	mov	al,bh
  1461 00002791 EE                  <1> 	out	dx,al			; output divisor - high byte
  1462 00002792 42                  <1> 	inc	dx
  1463 00002793 42                  <1> 	inc	dx			; DX = UART LCR address
  1464 00002794 88E0                <1> 	mov	al,ah			; AL = initialization parameters
  1465 00002796 241F                <1> 	and	al,(uart_lcr_wlen | uart_lcr_stop | uart_lcr_pen | uart_lcr_peven)
  1466                              <1> 					; get control bits
  1467 00002798 EE                  <1> 	out	dx,al			; set LCR
  1468 00002799 4A                  <1> 	dec	dx
  1469 0000279A 4A                  <1> 	dec	dx			; DX = UART IER address
  1470                              <1> 					; OPTIMIZATION:
  1471                              <1> 					; uart_ier_reg = uart_lcr_reg - 2
  1472 0000279B B000                <1> 	mov	al,0
  1473 0000279D EE                  <1> 	out	dx,al			; disable interrupts
  1474 0000279E 4A                  <1> 	dec	dx			; DX = UART base address
  1475                              <1> 					; OPTIMIZATION:
  1476                              <1> 					; uart_base = uart_ier_reg - 1
  1477 0000279F EB00                <1> 	jmp	int_14_fn03		; exit returning modem and line status
  1478                              <1> 
  1479                              <1> ;=========================================================================
  1480                              <1> ; int_14_fn03 - Return serial port status
  1481                              <1> ; Input:
  1482                              <1> ;	AH = 03h - function 03h - return serial port status
  1483                              <1> ;	DX = serial port number (0-3)
  1484                              <1> ; Output:
  1485                              <1> ;	AL = modem status (see int_14_fn00 for complete description)
  1486                              <1> ;	AH = line status (see int_14_fn00 for complete description)
  1487                              <1> ;-------------------------------------------------------------------------
  1488                              <1> int_14_fn03:
  1489 000027A1 83C205              <1> 	add	dx,uart_lsr_reg		; DX = UART LSR address
  1490 000027A4 EC                  <1> 	in	al,dx
  1491 000027A5 88C4                <1> 	mov	ah,al
  1492 000027A7 42                  <1> 	inc	dx			; DX = UART MSR address
  1493 000027A8 EC                  <1> 	in	al,dx
  1494 000027A9 EBBB                <1> 	jmp	int_14_exit
  1495                              <1> 
  1496                              <1> ;=========================================================================
  1497                              <1> ; int_14_fn04 - Extended initialize serial port
  1498                              <1> ; Input:
  1499                              <1> ;	AH = 04h - function 04h - extended initialize serial port
  1500                              <1> ;	AL - break status:
  1501                              <1> ;		00h = no break
  1502                              <1> ;		01h = break
  1503                              <1> ;	BH - parity:
  1504                              <1> ;		00h = no parity
  1505                              <1> ;		01h = odd parity
  1506                              <1> ;		02h = even parity
  1507                              <1> ;		03h = stick parity odd
  1508                              <1> ;		04h = stick parity even
  1509                              <1> ;	BL - stop bits:
  1510                              <1> ;		00h = 1 stop bit
  1511                              <1> ;		01h = 2 stop bits (or 1.5 stop bits for 5 bit word length)
  1512                              <1> ;	CH - word length:
  1513                              <1> ;		00h = 5 bits
  1514                              <1> ;		01h = 6 bits
  1515                              <1> ;		02h = 7 bits
  1516                              <1> ;		03h = 8 bits
  1517                              <1> ;	CL - bps rate:
  1518                              <1> ;		00h = 110 bps
  1519                              <1> ;		01h = 150 bps
  1520                              <1> ;		02h = 300 bps
  1521                              <1> ;		03h = 600 bps
  1522                              <1> ;		04h = 1200 bps
  1523                              <1> ;		05h = 2400 bps
  1524                              <1> ;		06h = 6000 bps
  1525                              <1> ;		07h = 9600 bps
  1526                              <1> ;		08h = 19200 bps
  1527                              <1> ;		09h = 38400 bps
  1528                              <1> ;		0Ah = 57600 bps
  1529                              <1> ;		0Bh = 115200 bps
  1530                              <1> ;	DX = serial port number (0-3)
  1531                              <1> ; Output:
  1532                              <1> ;	AL = modem status (see int_14_fn00 for complete description)
  1533                              <1> ;	AH = line status (see int_14_fn00 for complete description)
  1534                              <1> ;-------------------------------------------------------------------------
  1535                              <1> int_14_fn04:
  1536 000027AB 88C4                <1> 	mov	ah,al			; save AL to AH
  1537 000027AD 80F90C              <1> 	cmp	cl,num_divisors
  1538 000027B0 73EF                <1> 	jae	int_14_fn03		; invalid divisor value
  1539                              <1> 					; exit returning modem and line status
  1540 000027B2 83C203              <1> 	add	dx,uart_lcr_reg		; DX = UART LCR address
  1541 000027B5 B080                <1> 	mov	al,uart_lcr_ldiv	; AL = LCR load divisor bit
  1542 000027B7 EE                  <1> 	out	dx,al
  1543 000027B8 31DB                <1> 	xor	bx,bx
  1544 000027BA 88CB                <1> 	mov	bl,cl			; get divisor number from parameters
  1545 000027BC D0E3                <1> 	shl	bl,1			; index to the word table
  1546 000027BE 2E8B9F[5815]        <1>     cs	mov	bx,word [uart_divisors+bx] ; get the divisor value
  1547 000027C3 83EA03              <1> 	sub	dx,uart_lcr_reg		; DX = UART base address
  1548 000027C6 88D8                <1> 	mov	al,bl
  1549 000027C8 EE                  <1> 	out	dx,al			; output divisor - low byte
  1550 000027C9 42                  <1> 	inc	dx			; DX = UART base address + 1
  1551 000027CA 88F8                <1> 	mov	al,bh
  1552 000027CC EE                  <1> 	out	dx,al			; output divisor - high byte
  1553 000027CD 42                  <1> 	inc	dx
  1554 000027CE 42                  <1> 	inc	dx			; DX = UART LCR address
  1555                              <1> 
  1556 000027CF 80E401              <1> 	and	ah,01h			; break setting (mask defined bits)
  1557 000027D2 88E0                <1> 	mov	al,ah			; add it to AL (LCR setting)
  1558                              <1> 
  1559 000027D4 D0E0                <1> 	shl	al,1
  1560 000027D6 D0E0                <1> 	shl	al,1
  1561 000027D8 D0E0                <1> 	shl	al,1			; make place for parity settings
  1562                              <1> 	
  1563 000027DA 5B                  <1> 	pop	bx			; get original BX value from the stack
  1564 000027DB 53                  <1> 	push	bx			; push it back to the stack
  1565                              <1> 
  1566 000027DC 80FF01              <1> 	cmp	bh,1			; parity setting
  1567 000027DF 7609                <1> 	jbe	.set_parity		; no parity or odd parity
  1568 000027E1 FECF                <1> 	dec	bh
  1569 000027E3 80E703              <1> 	and	bh,03h			; get the valid bits only
  1570 000027E6 D0E7                <1> 	shl	bh,1
  1571 000027E8 FEC7                <1> 	inc	bh			; 010 -> 011, 011 -> 101, 100 -> 111
  1572                              <1> 
  1573                              <1> .set_parity:
  1574 000027EA 08F8                <1> 	or	al,bh			; add it to AL (LCR setting)
  1575                              <1> 
  1576 000027EC D0E0                <1> 	shl	al,1			; make place for stop bit setting
  1577                              <1> 	
  1578 000027EE 80E301              <1> 	and	bl,01h			; get stop bits (defined bit only)
  1579 000027F1 08D8                <1> 	or	al,bl			; add it to AL (LCR setting)
  1580                              <1> 
  1581 000027F3 D0E0                <1> 	shl	al,1
  1582 000027F5 D0E0                <1> 	shl	al,1			; make place for word length setting
  1583                              <1> 
  1584 000027F7 80E503              <1> 	and	ch,03h			; get word length (mask defined bits)
  1585 000027FA 08E8                <1> 	or	al,ch			; add it to AL (LCR setting)
  1586                              <1> 
  1587 000027FC EE                  <1> 	out	dx,al			; set LCR
  1588 000027FD 4A                  <1> 	dec	dx
  1589 000027FE 4A                  <1> 	dec	dx			; DX = UART IER address
  1590                              <1> 					; OPTIMIZATION:
  1591                              <1> 					; uart_ier_reg = uart_lcr_reg - 2
  1592 000027FF B000                <1> 	mov	al,0
  1593 00002801 EE                  <1> 	out	dx,al			; disable interrupts
  1594 00002802 4A                  <1> 	dec	dx			; DX = UART base address
  1595                              <1> 					; OPTIMIZATION:
  1596                              <1> 					; uart_base = uart_ier_reg - 1
  1597 00002803 EB9C                <1> 	jmp	int_14_fn03		; exit returning modem and line status
  1598                              <1> 
  1599                              <1> ;=========================================================================
  1600                              <1> ; int_14_fn05 - Extended serial port control
  1601                              <1> ; Input:
  1602                              <1> ;	AH = 05h - function 05h - extended serial port control
  1603                              <1> ;	AL - sub-function:
  1604                              <1> ;		00h = read modem control register
  1605                              <1> ;		01h = write modem control register
  1606                              <1> ;			BL = modem control register
  1607                              <1> ;	DX = serial port number (0-3)
  1608                              <1> ; Output:
  1609                              <1> ;	AX = status	
  1610                              <1> ;	sub-function AL = 00h:
  1611                              <1> ;		BL = modem control register
  1612                              <1> ;-------------------------------------------------------------------------
  1613                              <1> int_14_fn05:
  1614 00002805 2401                <1> 	and	al,01h			; sub-function (get the valid bit)
  1615 00002807 750D                <1> 	jnz	int_14_fn05_01
  1616                              <1> 
  1617                              <1> ;-------------------------------------------------------------------------
  1618                              <1> ; sub-function 00h - read modem control register
  1619                              <1> ; int_14_fn05_00:
  1620 00002809 83C203              <1> 	add	dx,uart_lcr_reg		; DX = UART MCR address
  1621 0000280C EC                  <1> 	in	al,dx
  1622 0000280D 5B                  <1> 	pop	bx			; get BX from the stack
  1623 0000280E 88C3                <1> 	mov	bl,al			; BL = MCR content
  1624 00002810 53                  <1> 	push	bx			; put BX back to the stack
  1625 00002811 83EA03              <1> 	sub	dx,uart_lcr_reg		; DX = UART base address
  1626 00002814 EB8B                <1> 	jmp	int_14_fn03		; exit returning modem and line status
  1627                              <1> 
  1628                              <1> ;-------------------------------------------------------------------------
  1629                              <1> ; sub-function 01h - write modem control register
  1630                              <1> int_14_fn05_01:
  1631 00002816 83C203              <1> 	add	dx,uart_lcr_reg		; DX = UART MCR address
  1632 00002819 5B                  <1> 	pop	bx			; get BX from the stack
  1633 0000281A 53                  <1> 	push	bx			; put BX back to the stack
  1634 0000281B 88D8                <1> 	mov	al,bl			; BL = new MCR content
  1635 0000281D EE                  <1> 	out	dx,al
  1636 0000281E 83EA03              <1> 	sub	dx,uart_lcr_reg		; DX = UART base address
  1637 00002821 E97DFF              <1> 	jmp	int_14_fn03		; exit returning modem and line status
  1324                                  %include	"keyboard.inc"		; INT 16, INT 09
  1325                              <1> ;=========================================================================
  1326                              <1> ; keyboard.inc - Keyboard support
  1327                              <1> ;       INT 16h - BIOS Keyboard Services
  1328                              <1> ;		- function AH=02h
  1329                              <1> ;		- function AH=03h
  1330                              <1> ;		- function AH=05h
  1331                              <1> ;		- function AH=12h
  1332                              <1> ;		- see scancode.inc for other (scancode related)
  1333                              <1> ;                 INT 16h functions
  1334                              <1> ;       INT 09h - IRQ1 interrupt handler
  1335                              <1> ;-------------------------------------------------------------------------
  1336                              <1> ;
  1337                              <1> ; Compiles with NASM 2.13.02, might work with other versions
  1338                              <1> ;
  1339                              <1> ; Copyright (C) 2010 - 2023 Sergey Kiselev.
  1340                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
  1341                              <1> ;
  1342                              <1> ; This program is free software: you can redistribute it and/or modify
  1343                              <1> ; it under the terms of the GNU General Public License as published by
  1344                              <1> ; the Free Software Foundation, either version 3 of the License, or
  1345                              <1> ; (at your option) any later version.
  1346                              <1> ;
  1347                              <1> ; This program is distributed in the hope that it will be useful,
  1348                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  1349                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  1350                              <1> ; GNU General Public License for more details.
  1351                              <1> ;
  1352                              <1> ; You should have received a copy of the GNU General Public License
  1353                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  1354                              <1> ;
  1355                              <1> ;=========================================================================
  1356                              <1> 
  1357                              <1> ;=========================================================================
  1358                              <1> ; Scan codes and keyboard flags
  1359                              <1> ;-------------------------------------------------------------------------
  1360                              <1> 
  1361                              <1> ; scancodes for special keys
  1362                              <1> 
  1363                              <1> kbd_num_code	equ	45h
  1364                              <1> kbd_scroll_code	equ	46h
  1365                              <1> kbd_caps_code	equ	3ah
  1366                              <1> kbd_ctrl_code	equ	1dh
  1367                              <1> kbd_alt_code	equ	38h
  1368                              <1> kbd_rshift_code	equ	36h
  1369                              <1> kbd_prtsc_code	equ	37h
  1370                              <1> kbd_lshift_code	equ	2ah
  1371                              <1> kbd_ins_code	equ	52h
  1372                              <1> kbd_del_code	equ	53h
  1373                              <1> 
  1374                              <1> ; Bits for the various modifier keys
  1375                              <1> 
  1376                              <1> kbd_rshft_bit	equ	1
  1377                              <1> kbd_lshft_bit	equ	2
  1378                              <1> kbd_ctrl_bit	equ	4
  1379                              <1> kbd_alt_bit	equ	8
  1380                              <1> kbd_scroll_bit	equ	10h
  1381                              <1> kbd_num_bit	equ	20h
  1382                              <1> kbd_caps_bit	equ	40h
  1383                              <1> kbd_ins_bit	equ	80h
  1384                              <1> 
  1385                              <1> ;=========================================================================
  1386                              <1> ; int_16 - BIOS keyboard functions
  1387                              <1> ;-------------------------------------------------------------------------
  1388 00002824 FF<rep Ah>          <1> 	setloc	0E82Eh
  1388          ******************  <1>  warning: Inserting 10 bytes [-w+user]
  1389                              <1> int_16:
  1390                              <1> ;	call	int_trace		; DEBUG
  1391 0000282E 53                  <1> 	push	bx
  1392 0000282F 1E                  <1> 	push	ds
  1393 00002830 BB4000              <1> 	mov	bx,biosdseg
  1394 00002833 8EDB                <1> 	mov	ds,bx
  1395 00002835 80FC13              <1> 	cmp	ah,.num_func
  1396 00002838 7331                <1> 	jae	int_16_exit
  1397 0000283A B700                <1> 	mov	bh,0
  1398 0000283C 88E3                <1> 	mov	bl,ah
  1399 0000283E D1E3                <1> 	shl	bx,1
  1400 00002840 2EFFA7[4528]        <1>     cs	jmp	near [.dispatch+bx]
  1401                              <1> 
  1402                              <1> .dispatch:
  1403 00002845 [7F13]              <1> 	dw	int_16_fn00		; read char from buffer, wait if empty
  1404 00002847 [D413]              <1> 	dw	int_16_fn01		; check buffer, do not clear
  1405 00002849 [7428]              <1> 	dw	int_16_fn02		; get shift status
  1406                              <1> %ifdef AT_KEYBOARD
  1407                              <1> 	dw	int_16_fn03		; set delays
  1408                              <1> %else ; AT_KEYBOARD
  1409 0000284B [6B28]              <1> 	dw	int_16_exit		; not implemented on XT
  1410                              <1> %endif ; AT_KEYBOARD
  1411 0000284D [6B28]              <1> 	dw	int_16_exit		; keyclick
  1412 0000284F [7928]              <1> 	dw	int_16_fn05		; write to keyboard buffer
  1413 00002851 [6B28]              <1> 	dw	int_16_exit		; 06
  1414 00002853 [6B28]              <1> 	dw	int_16_exit		; 07
  1415 00002855 [6B28]              <1> 	dw	int_16_exit		; 08
  1416 00002857 [6B28]              <1> 	dw	int_16_exit		; 09
  1417 00002859 [6B28]              <1> 	dw	int_16_exit		; 0A
  1418 0000285B [6B28]              <1> 	dw	int_16_exit		; 0B
  1419 0000285D [6B28]              <1> 	dw	int_16_exit		; 0C
  1420 0000285F [6B28]              <1> 	dw	int_16_exit		; 0D
  1421 00002861 [6B28]              <1> 	dw	int_16_exit		; 0E
  1422 00002863 [6B28]              <1> 	dw	int_16_exit		; 0F
  1423 00002865 [2C14]              <1> 	dw	int_16_fn10		; get enhanced keystroke
  1424 00002867 [5814]              <1> 	dw	int_16_fn11		; check enhanced keystroke
  1425 00002869 [A228]              <1> 	dw	int_16_fn12		; get enhanced shift flags
  1426                              <1> .num_func	equ	($-.dispatch)/2
  1427                              <1> 
  1428                              <1> int_16_exit:
  1429 0000286B 1F                  <1> 	pop	ds
  1430 0000286C 5B                  <1> 	pop	bx
  1431 0000286D CF                  <1> 	iret
  1432                              <1> 
  1433                              <1> int_16_exitf:
  1434 0000286E 1F                  <1> 	pop	ds
  1435 0000286F 5B                  <1> 	pop	bx
  1436 00002870 FB                  <1> 	sti
  1437 00002871 CA0200              <1> 	retf	2
  1438                              <1> 
  1439                              <1> ;=========================================================================
  1440                              <1> ; int_16_fn02 - get shift flags
  1441                              <1> ; Input:
  1442                              <1> ;	AH = 02h
  1443                              <1> ; Output:
  1444                              <1> ;	AL - shift flags
  1445                              <1> ;            AL bits:
  1446                              <1> ;		7 - Insert active
  1447                              <1> ;		6 - Caps Lock active
  1448                              <1> ;		5 - Num Lock active
  1449                              <1> ;		4 - Scroll Lock active
  1450                              <1> ;		3 - Alt key pressed (either Alt on 101/102-key keyboards)
  1451                              <1> ;		2 - Ctrl key pressed (either Ctrl on 101/102-key keyboards)
  1452                              <1> ;		1 - left shift key pressed
  1453                              <1> ;		0 - right shift key pressed
  1454                              <1> ;-------------------------------------------------------------------------
  1455                              <1> int_16_fn02:
  1456 00002874 A01700              <1> 	mov	al,byte [kbd_flags_1]
  1457 00002877 EBF2                <1> 	jmp	int_16_exit
  1458                              <1> 
  1459                              <1> %ifdef AT_KEYBOARD
  1460                              <1> 
  1461                              <1> ;=========================================================================
  1462                              <1> ; int_16_fn03 - set keyboard typematic rate
  1463                              <1> ; Input:
  1464                              <1> ;	AH = 03
  1465                              <1> ;	AL - subfunction
  1466                              <1> ;	     00 - set typematic rate to default
  1467                              <1> ;	     01 - increase initial delay
  1468                              <1> ;	     02 - slow typematic rate by 1/2
  1469                              <1> ;	     04 - turn off typematic chars
  1470                              <1> ;	     05 - set typematic rate/delay
  1471                              <1> ;	BH - repeat delay (AL=5)
  1472                              <1> ;		0 - 250ms	2 - 750ms
  1473                              <1> ;		1 - 500ms	3 - 1000ms
  1474                              <1> ;	BL - typematic rate, one of the following  (AL=5)
  1475                              <1> ;		00 - 30.0	01 - 26.7	02 - 24.0	03 - 21.8
  1476                              <1> ;		04 - 20.0	05 - 18.5	06 - 17.1	07 - 16.0
  1477                              <1> ;		08 - 15.0	09 - 13.3	0A - 12.0	0B - 10.9
  1478                              <1> ;		0C - 10.0	0D - 9.2	0E - 8.6	0F - 8.0
  1479                              <1> ;		10 - 7.5	11 - 6.7	12 - 6.0	13 - 5.5
  1480                              <1> ;		14 - 5.0	15 - 4.6	16 - 4.3	17 - 4.0
  1481                              <1> ;		18 - 3.7	19 - 3.3	1A - 3.0	1B - 2.7
  1482                              <1> ;		1C - 2.5	1D - 2.3	1E - 2.1	1F - 2.0
  1483                              <1> ; Output:
  1484                              <1> ;	none
  1485                              <1> ;-------------------------------------------------------------------------
  1486                              <1> int_16_fn03:
  1487                              <1> 	cmp	al,05
  1488                              <1> 	jne	.exit			; only AL = 5 implemented
  1489                              <1> 	push	bx
  1490                              <1> 	push	cx
  1491                              <1> 	mov	al,kbc_cmd_kbd_dis	; disable keyboard interface
  1492                              <1> 	call	kbc_write_command
  1493                              <1> 	and	bh,3			; legal BH values from 0 to 3
  1494                              <1> 	mov	cl,5
  1495                              <1> 	shl	bh,cl
  1496                              <1> 	and	bl,1Fh			; legal BL values from 0 to 1F
  1497                              <1> 	mov	al,dev_cmd_rate
  1498                              <1> 	call	kbc_kb_send
  1499                              <1> 	mov	al,bh
  1500                              <1> 	call	kbc_kb_send
  1501                              <1> 	mov	al,kbc_cmd_kbd_ena	; enable keyboard interface
  1502                              <1> 	call	kbc_write_command
  1503                              <1> 	mov	al,04h			; FIXME: Use dev_cmd_enable instead?
  1504                              <1> 	call	kbc_kb_send
  1505                              <1> 	pop	cx
  1506                              <1> 	pop	bx
  1507                              <1> .exit:
  1508                              <1> 	jmp	int_16_exit
  1509                              <1> 
  1510                              <1> %endif ; AT_KEYBOARD
  1511                              <1> 
  1512                              <1> ;=========================================================================
  1513                              <1> ; int_16_fn05 - store keystroke in keyboard buffer
  1514                              <1> ; Input:
  1515                              <1> ;	AH = 05h
  1516                              <1> ;	CH = BIOS scan code
  1517                              <1> ;	CL = ACII character
  1518                              <1> ; Output:
  1519                              <1> ;	AL - status
  1520                              <1> ;	     00h - success
  1521                              <1> ;	     01h - keyboard buffer full
  1522                              <1> ;-------------------------------------------------------------------------
  1523                              <1> int_16_fn05:
  1524 00002879 56                  <1> 	push	si
  1525 0000287A B001                <1> 	mov	al,1			; assume no space
  1526 0000287C FA                  <1> 	cli				; critical section
  1527 0000287D 8B1E1C00            <1> 	mov	bx,word [kbd_buffer_tail]
  1528 00002881 89DE                <1> 	mov	si,bx
  1529 00002883 83C302              <1> 	add	bx,2
  1530 00002886 3B1E8200            <1> 	cmp	bx,word [kbd_buffer_end]
  1531 0000288A 7504                <1> 	jne	.1
  1532 0000288C 8B1E8000            <1> 	mov	bx,word [kbd_buffer_start]
  1533                              <1> .1:
  1534 00002890 3B1E1A00            <1> 	cmp	bx,word [kbd_buffer_head]
  1535 00002894 7408                <1> 	je	.no_space		; no space in buffer
  1536 00002896 890C                <1> 	mov	word [si],cx
  1537 00002898 891E1C00            <1> 	mov	word [kbd_buffer_tail],bx
  1538 0000289C B000                <1> 	mov	al,0			; stored successfully
  1539                              <1> .no_space:
  1540 0000289E FB                  <1> 	sti
  1541 0000289F 5E                  <1> 	pop	si
  1542 000028A0 EBC9                <1> 	jmp	int_16_exit
  1543                              <1> 
  1544                              <1> ;=========================================================================
  1545                              <1> ; int_16_fn12 - get extended shift flags
  1546                              <1> ; Input:
  1547                              <1> ;	AH = 12h
  1548                              <1> ; Output:
  1549                              <1> ;	AL - shift flags 1 (same as returned by function AH=02)
  1550                              <1> ;	AH - shift flags 2
  1551                              <1> ;            AH bits:
  1552                              <1> ;		7 - SysRq key pressed
  1553                              <1> ;		6 - Caps Lock pressed
  1554                              <1> ;		5 - Num Lock pressed
  1555                              <1> ;		4 - Scroll Lock pressed
  1556                              <1> ;		3 - right Alt key pressed
  1557                              <1> ;		2 - right Ctrl key pressed
  1558                              <1> ;		1 - left Alt key pressed
  1559                              <1> ;		0 - left Ctrl key pressed
  1560                              <1> ;-------------------------------------------------------------------------
  1561                              <1> int_16_fn12:
  1562 000028A2 8A261800            <1> 	mov	ah,byte [kbd_flags_2]
  1563 000028A6 80E47F              <1> 	and	ah,7Fh			; clear final SysRq bit
  1564 000028A9 F6C404              <1> 	test	ah,00000100b		; test current SysRq bit
  1565 000028AC 7403                <1> 	je	.1
  1566 000028AE 80CC80              <1> 	or	ah,80h			; set final SysRq bit
  1567                              <1> .1:
  1568 000028B1 80E4F3              <1> 	and	ah,11110011b		; clear right Alt/Ctrl bits
  1569 000028B4 A09600              <1> 	mov	al,byte [kbd_flags_3]
  1570 000028B7 240C                <1> 	and	al,00001100b		; get right Alt/Ctrl bits
  1571 000028B9 08C4                <1> 	or	ah,al			; copy to AH
  1572 000028BB A01700              <1> 	mov	al,byte [kbd_flags_1]
  1573 000028BE EBAB                <1> 	jmp	int_16_exit
  1574                              <1> 
  1575                              <1> ;=========================================================================
  1576                              <1> ; int_09 - Keyboard hardware interrupt (IRQ1) handler
  1577                              <1> ;-------------------------------------------------------------------------
  1578 000028C0 FF<rep C7h>         <1> 	setloc	0E987h			; INT 09 Entry Point
  1578          ******************  <1>  warning: Inserting 199 bytes [-w+user]
  1579                              <1> int_09:
  1580 00002987 50                  <1> 	push	ax
  1581 00002988 53                  <1> 	push	bx
  1582 00002989 1E                  <1> 	push	ds
  1583                              <1> 
  1584 0000298A B84000              <1> 	mov	ax,biosdseg
  1585 0000298D 8ED8                <1> 	mov	ds,ax
  1586                              <1> 
  1587                              <1> %ifdef AT_KEYBOARD
  1588                              <1> %ifndef DISABLE_KBD_DURING_INTERRUPTS
  1589                              <1> 	mov	al,kbc_cmd_kbd_dis	; disable keyboard interface
  1590                              <1> 	call    kbc_write_command
  1591                              <1> %endif
  1592                              <1> %endif ; AT_KEYBOARD
  1593 0000298F E460                <1> 	in	al,ppi_pa_reg		; get keyboard data / scancode
  1594                              <1> %ifndef MACHINE_BOOK8088
  1595                              <1> 	mov	ah,al			; save it in AH
  1596                              <1> 	in	al,ppi_pb_reg		; read PPI port B, control
  1597                              <1> 	or	al,10000000b		; set keyboard clear bit
  1598                              <1> 	out	ppi_pb_reg,al		; write it back to PPI port B
  1599                              <1> 	and	al,01111111b		; unset keyboard clear bit
  1600                              <1> 	out	ppi_pb_reg,al		; write it back to PPI port B
  1601                              <1> 	mov	al,ah			; restore AL / scancode
  1602                              <1> %endif ; MACHINE_BOOK8088
  1603 00002991 FB                  <1> 	sti
  1604                              <1> %ifdef AT_KEYBOARD
  1605                              <1> 	mov	ah,4Fh
  1606                              <1> 	stc
  1607                              <1> 	int	15h			; keyboard intercept
  1608                              <1> 	jnc	keyboard_int_exit	; CF = 0, ignore scan code
  1609                              <1> %else ; AT_KEYBOARD
  1610 00002992 3CFF                <1> 	cmp	al,0FFh			; check for overrun
  1611 00002994 7503E9C501          <1> 	jz	keyboard_int_exit
  1612                              <1> %endif ; AT_KEYBOARD
  1613                              <1> ; check for KBC response codes
  1614                              <1> 
  1615 00002999 3CEE                <1> 	cmp	al,0EEh			; echo response?
  1616 0000299B 7503E9BE01          <1> 	je      keyboard_int_exit
  1617 000029A0 3CFA                <1> 	cmp	al,0FAh			; acknowledge?
  1618 000029A2 7508                <1> 	jne     .2
  1619 000029A4 800E970010          <1> 	or	byte [kbd_flags_4],10h	; set ack bit
  1620 000029A9 E9B201              <1> 	jmp	keyboard_int_exit
  1621                              <1> .2:
  1622 000029AC 3CFE                <1> 	cmp	al,0FEh			; resend command?
  1623 000029AE 7508                <1> 	jne	.3
  1624 000029B0 800E970020          <1> 	or	byte [kbd_flags_4],20h	; set resend bit
  1625 000029B5 E9A601              <1> 	jmp	keyboard_int_exit
  1626                              <1> 
  1627                              <1> ; Note: other KBC response codes have their MSB bit set and will be ignored
  1628                              <1> 
  1629                              <1> .3:
  1630                              <1> 
  1631                              <1> ; check for 0E0h and 0E1h scancodes, set flags in kbd_flags_3
  1632                              <1> 
  1633 000029B8 3CE0                <1> 	cmp	al,0E0h
  1634 000029BA 750D                <1> 	jne	.4
  1635 000029BC 800E960002          <1> 	or	byte [kbd_flags_3],10b	; set E0 flag
  1636 000029C1 80269600FE          <1> 	and	byte [kbd_flags_3],0FEh	; clear E1 flag
  1637 000029C6 E99501              <1> 	jmp	keyboard_int_exit
  1638                              <1> .4:
  1639 000029C9 3CE1                <1> 	cmp	al,0E1h
  1640 000029CB 750D                <1> 	jne	.5
  1641 000029CD 800E960001          <1> 	or	byte [kbd_flags_3],1	; set E1 flag
  1642 000029D2 80269600FD          <1> 	and	byte [kbd_flags_3],0FDh	; clear E0 Flag
  1643 000029D7 E98401              <1> 	jmp	keyboard_int_exit
  1644                              <1> 
  1645                              <1> ; check for various <Ctrl>+<Alt>+<Key> combinations:
  1646                              <1> 
  1647                              <1> .5:
  1648 000029DA 8A1E1700            <1> 	mov	bl,byte [kbd_flags_1]
  1649 000029DE 80E30C              <1> 	and	bl,kbd_alt_bit|kbd_ctrl_bit
  1650 000029E1 80FB0C              <1> 	cmp	bl,kbd_alt_bit|kbd_ctrl_bit
  1651 000029E4 7523                <1> 	jne	.6
  1652 000029E6 3C53                <1> 	cmp	al,kbd_del_code		; <Ctrl>+<Alt>+<Del>?
  1653 000029E8 750B                <1> 	jne	.check_turbo_off
  1654 000029EA C70672003412        <1> 	mov	word [warm_boot],1234h ; warm boot flag
  1655 000029F0 EA[6620]00F0        <1> 	jmp	0F000h:warm_start	; reboot
  1656                              <1> 
  1657                              <1> ; handle turbo mode switch combinations
  1658                              <1> .check_turbo_off:
  1659                              <1> 
  1660                              <1> %ifdef TURBO_MODE
  1661 000029F5 3C4A                <1> 	cmp	al,4Ah			; gray - scancode
  1662 000029F7 7506                <1> 	jne	.check_turbo_mid
  1663                              <1> 
  1664 000029F9 E862ED              <1> 	call	set_cpu_clk_4_77mhz
  1665 000029FC E95F01              <1> 	jmp	keyboard_int_exit
  1666                              <1> 
  1667                              <1> .check_turbo_mid:
  1668                              <1> %ifdef MACHINE_FE2010A
  1669                              <1> 	cmp	al,37h			; * scancode
  1670                              <1> 	jne	.check_turbo_hi
  1671                              <1> 
  1672                              <1> 	call	set_cpu_clk_7_16mhz
  1673                              <1> 	jmp	keyboard_int_exit
  1674                              <1> %endif ; MACHINE_FE2010A
  1675                              <1> 
  1676                              <1> .check_turbo_hi:
  1677 000029FF 3C4E                <1> 	cmp	al,4Eh			; gray + scancode
  1678 00002A01 7506                <1> 	jne	.6
  1679                              <1> 
  1680                              <1> %ifdef MACHINE_FE2010A
  1681                              <1> 	call	set_cpu_clk_9_55mhz
  1682                              <1> %else ; MACHINE_FE2010A
  1683 00002A03 E85FED              <1> 	call	set_cpu_clk_turbo
  1684                              <1> %endif ; MACHINE_FE2010A
  1685 00002A06 E95501              <1> 	jmp	keyboard_int_exit
  1686                              <1> 
  1687                              <1> %endif ; TURBO_MODE
  1688                              <1> 
  1689                              <1> ; Check for the INS key here. This one needs to toggle the ins bit
  1690                              <1> ; in the keyboard flags variables.
  1691                              <1> 
  1692                              <1> .6:
  1693 00002A09 3C52                <1> 	cmp	al,kbd_ins_code
  1694 00002A0B 7508                <1> 	jne	.7
  1695 00002A0D 800E180080          <1> 	or	byte [kbd_flags_2],kbd_ins_bit ; set INS bit
  1696 00002A12 E90A01              <1> 	jmp	.translate	   	; pass on INS key
  1697                              <1> 
  1698                              <1> .7:
  1699 00002A15 3CD2                <1> 	cmp	al,kbd_ins_code+80h	; INS "break" scan code
  1700 00002A17 750D                <1> 	jne     .8
  1701 00002A19 802618007F          <1> 	and	byte [kbd_flags_2],~kbd_ins_bit ; clear INS bit
  1702 00002A1E 8036170080          <1> 	xor     byte [kbd_flags_1],kbd_ins_bit ; toggle INS bit
  1703 00002A23 E93301              <1> 	jmp     .no_buffer
  1704                              <1> 
  1705                              <1> ; handle the left and right Shift keys
  1706                              <1> 
  1707                              <1> .8:
  1708 00002A26 3C2A                <1> 	cmp	al,kbd_lshift_code
  1709 00002A28 7508                <1> 	jne	.9
  1710 00002A2A 800E170002          <1> 	or	byte [kbd_flags_1],kbd_lshft_bit ; set left Shift bit
  1711 00002A2F E92701              <1> 	jmp	.no_buffer
  1712                              <1> .9:
  1713 00002A32 3CAA                <1> 	cmp	al,kbd_lshift_code+80h
  1714 00002A34 7508                <1> 	jne     .10
  1715 00002A36 80261700FD          <1> 	and     byte [kbd_flags_1],~kbd_lshft_bit ; clear left Shift bit
  1716 00002A3B E91B01              <1> 	jmp     .no_buffer
  1717                              <1> .10:
  1718 00002A3E 3C36                <1> 	cmp	al,kbd_rshift_code
  1719 00002A40 7508                <1> 	jne	.11
  1720 00002A42 800E170001          <1> 	or	byte [kbd_flags_1],kbd_rshft_bit ; set right Shift bit
  1721 00002A47 E90F01              <1> 	jmp	.no_buffer
  1722                              <1> .11:
  1723 00002A4A 3CB6                <1> 	cmp	al,kbd_rshift_code+80h
  1724 00002A4C 7508                <1> 	jne     .12
  1725 00002A4E 80261700FE          <1> 	and	byte [kbd_flags_1],~kbd_rshft_bit ; clear right Shift bit
  1726 00002A53 E90301              <1> 	jmp	.no_buffer
  1727                              <1> 
  1728                              <1> ; handle the Alt key
  1729                              <1> 
  1730                              <1> .12:
  1731 00002A56 3C38                <1> 	cmp	al,kbd_alt_code
  1732 00002A58 7508                <1> 	jne	.13
  1733 00002A5A 800E170008          <1> 	or	byte [kbd_flags_1],kbd_alt_bit ; set Alt bit
  1734 00002A5F E9F700              <1> 	jmp	.no_buffer
  1735                              <1> .13:
  1736 00002A62 3CB8                <1> 	cmp	al,kbd_alt_code+80h
  1737 00002A64 751C                <1> 	jne	.14
  1738 00002A66 80261700F7          <1> 	and	byte [kbd_flags_1],~kbd_alt_bit ; clear Alt bit
  1739 00002A6B 803E190000          <1> 	cmp	byte [kbd_alt_keypad],0		; anything in Alt + Keypad area
  1740 00002A70 7503E9E400          <1> 	je	.no_buffer				; nothing there - exit
  1741 00002A75 A01900              <1> 	mov	al,byte [kbd_alt_keypad]	; put it in the buffer
  1742 00002A78 C606190000          <1> 	mov	byte [kbd_alt_keypad],0		; zero the buffer
  1743 00002A7D B400                <1> 	mov	ah,0
  1744 00002A7F E9B600              <1> 	jmp	.put_in_buffer
  1745                              <1> 
  1746                              <1> ; handle the Ctrl key
  1747                              <1> 
  1748                              <1> .14:
  1749 00002A82 3C1D                <1> 	cmp	al,kbd_ctrl_code
  1750 00002A84 7508                <1> 	jne	.15
  1751 00002A86 800E170004          <1> 	or	byte [kbd_flags_1],kbd_ctrl_bit ; set Ctrl bit
  1752 00002A8B E9CB00              <1> 	jmp	.no_buffer
  1753                              <1> .15:
  1754 00002A8E 3C9D                <1> 	cmp	al,kbd_ctrl_code+80h
  1755 00002A90 7508                <1> 	jne	.16
  1756 00002A92 80261700FB          <1> 	and	byte [kbd_flags_1],~kbd_ctrl_bit ; clear Ctrl bit
  1757 00002A97 E9BF00              <1> 	jmp	.no_buffer
  1758                              <1> 
  1759                              <1> ; handle the Caps Lock key
  1760                              <1> 
  1761                              <1> .16:
  1762 00002A9A 3C3A                <1> 	cmp	al,kbd_caps_code
  1763 00002A9C 750D                <1> 	jne	.17
  1764 00002A9E 800E180040          <1> 	or	byte [kbd_flags_2],kbd_caps_bit ; set Caps Lock bit
  1765 00002AA3 8036170040          <1> 	xor	byte [kbd_flags_1],kbd_caps_bit ; toggle Caps Lock bit
  1766 00002AA8 E9AE00              <1> 	jmp	.no_buffer
  1767                              <1> .17:
  1768 00002AAB 3CBA                <1> 	cmp	al,kbd_caps_code+80h
  1769 00002AAD 7508                <1> 	jne	.18
  1770 00002AAF 80261800BF          <1> 	and	byte [kbd_flags_2],~kbd_caps_bit ; clear Caps Lock bit
  1771 00002AB4 E9D000              <1> 	jmp	set_LEDs
  1772                              <1> 
  1773                              <1> ; check if print screen key was pressed
  1774                              <1> 
  1775                              <1> .18:
  1776 00002AB7 3C37                <1> 	cmp	al,kbd_prtsc_code
  1777 00002AB9 750A                <1> 	jne	.test_scroll_loc
  1778 00002ABB F606960002          <1> 	test	byte [kbd_flags_3],10b	; test E0 flag
  1779 00002AC0 7403                <1> 	jz	.test_scroll_loc	; jump if no 0E0h flag (Keypad *)
  1780 00002AC2 E9B500              <1> 	jmp	print_screen
  1781                              <1> 
  1782                              <1> ; handle the Scroll Lock (046h) key and Ctrl-Break combination (0E0h, 046h)
  1783                              <1> 
  1784                              <1> .test_scroll_loc:
  1785 00002AC5 3C46                <1> 	cmp	al,kbd_scroll_code
  1786 00002AC7 7528                <1> 	jne	.19
  1787 00002AC9 F606960002          <1> 	test	byte [kbd_flags_3],10b	; test E0 flag
  1788 00002ACE 7415                <1> 	jz	.scroll_lock		; jump if no 0E0h flag (Scroll Lock)
  1789                              <1> 
  1790                              <1> ; handle Ctrl-Break
  1791                              <1> 
  1792 00002AD0 8B1E8000            <1> 	mov	bx,word [kbd_buffer_start] ; empty keyboard buffer
  1793 00002AD4 891E1A00            <1> 	mov	word [kbd_buffer_head],bx
  1794 00002AD8 891E1C00            <1> 	mov	word [kbd_buffer_tail],bx
  1795 00002ADC 800E710080          <1> 	or	byte [break_flag],80h	; set Ctrl-Break flag
  1796 00002AE1 CD1B                <1> 	int	1Bh			; call INT 1Bh - Ctrl-Break handler
  1797 00002AE3 EB74                <1> 	jmp	.no_buffer
  1798                              <1> 
  1799                              <1> ; handle Scroll Lock
  1800                              <1> 
  1801                              <1> .scroll_lock:
  1802 00002AE5 800E180010          <1> 	or	byte [kbd_flags_2],kbd_scroll_bit ; set Scroll Lock bit
  1803 00002AEA 8036170010          <1> 	xor	byte [kbd_flags_1],kbd_scroll_bit ; toggle Scroll Lock bit
  1804 00002AEF EB68                <1> 	jmp	.no_buffer
  1805                              <1> .19:
  1806 00002AF1 3CC6                <1> 	cmp	al,kbd_scroll_code+80h
  1807 00002AF3 7508                <1> 	jne	.20
  1808 00002AF5 80261800EF          <1> 	and	byte [kbd_flags_2],~kbd_scroll_bit ; clear Scroll Lock bit
  1809 00002AFA E98A00              <1> 	jmp	set_LEDs
  1810                              <1> 
  1811                              <1> ; handle the Num Lock
  1812                              <1> 
  1813                              <1> .20:
  1814 00002AFD 3C45                <1> 	cmp	al,kbd_num_code
  1815 00002AFF 7513                <1> 	jne	.21
  1816 00002B01 F606170004          <1> 	test	byte [kbd_flags_1],kbd_ctrl_bit	; Ctrl+Num Lock (Pause)?
  1817 00002B06 755E                <1> 	jnz	pause			; jump if pause
  1818 00002B08 800E180020          <1> 	or	byte [kbd_flags_2],kbd_num_bit ; set Num Lock bit
  1819 00002B0D 8036170020          <1> 	xor	byte [kbd_flags_1],kbd_num_bit ; toggle Num Lock bit
  1820 00002B12 EB45                <1> 	jmp	.no_buffer
  1821                              <1> .21:
  1822 00002B14 3CC5                <1> 	cmp	al,kbd_num_code+80h
  1823 00002B16 7507                <1> 	jne	.translate
  1824 00002B18 80261800DF          <1> 	and	byte [kbd_flags_2],~kbd_num_bit ; clear Num Lock bit
  1825 00002B1D EB68                <1> 	jmp	set_LEDs
  1826                              <1> 
  1827                              <1> ; translate keyboard scan code to ASCII and BIOS scan code
  1828                              <1> 
  1829                              <1> .translate:
  1830 00002B1F F606180008          <1> 	test	byte [kbd_flags_2],08h	; check pause flag
  1831 00002B24 7407                <1> 	jz	.check_release
  1832 00002B26 80261800F7          <1> 	and	byte [kbd_flags_2],~08h	; clear pause flag
  1833 00002B2B EB2C                <1> 	jmp	.no_buffer		; don't put key in buffer
  1834                              <1> .check_release:
  1835 00002B2D A880                <1> 	test	al,80h			; ignore key release and KBC responses
  1836 00002B2F 7528                <1> 	jnz	.no_buffer
  1837                              <1> 
  1838 00002B31 E892E7              <1> 	call	scan_xlat
  1839 00002B34 85C0                <1> 	test	ax,ax		 	; check for bad code
  1840 00002B36 7421                <1> 	je	.no_buffer
  1841                              <1> 
  1842                              <1> .put_in_buffer:
  1843 00002B38 56                  <1> 	push	si			; FIXME: Use Int 16h/05 instead?
  1844 00002B39 8B1E1C00            <1> 	mov	bx,word [kbd_buffer_tail]
  1845 00002B3D 89DE                <1> 	mov	si,bx
  1846 00002B3F 83C302              <1> 	add	bx,2
  1847 00002B42 3B1E8200            <1> 	cmp	bx,word [kbd_buffer_end]
  1848 00002B46 7504                <1> 	jne	.1
  1849 00002B48 8B1E8000            <1> 	mov	bx,word [kbd_buffer_start]
  1850                              <1> .1:
  1851 00002B4C 3B1E1A00            <1> 	cmp	bx,word [kbd_buffer_head]
  1852 00002B50 7406                <1> 	je	.no_space		; no space in buffer
  1853 00002B52 8904                <1> 	mov	word [si],ax
  1854 00002B54 891E1C00            <1> 	mov	word [kbd_buffer_tail],bx
  1855                              <1> 
  1856                              <1> .no_space:
  1857 00002B58 5E                  <1> 	pop	si
  1858                              <1> 
  1859                              <1> .no_buffer:
  1860 00002B59 80269600FC          <1> 	and     byte [kbd_flags_3],0FCh	; E0, E1 not last code
  1861                              <1> 
  1862                              <1> keyboard_int_exit:
  1863                              <1> %ifdef AT_KEYBOARD
  1864                              <1> %ifndef DISABLE_KBD_DURING_INTERRUPTS
  1865                              <1> 	mov	al,kbc_cmd_kbd_ena	; enable keyboard interface
  1866                              <1> 	call	kbc_write_command
  1867                              <1> %endif
  1868                              <1> %endif ; AT_KEYBOARD
  1869 00002B5E B020                <1> 	mov	al,20h			; send EOI (end of interrupt)
  1870 00002B60 E620                <1> 	out	pic1_reg0,al		; to the 8259A PIC.
  1871                              <1> 
  1872                              <1> keyboard_int_exit1:
  1873 00002B62 1F                  <1> 	pop	ds
  1874 00002B63 5B                  <1> 	pop	bx
  1875 00002B64 58                  <1> 	pop	ax
  1876 00002B65 CF                  <1> 	iret
  1877                              <1> 
  1878                              <1> pause:
  1879 00002B66 8036180008          <1> 	xor	byte [kbd_flags_2],08h	; toggle pause flag
  1880 00002B6B 74F1                <1> 	jz	keyboard_int_exit	; jump if pause flag is unset now
  1881                              <1> 
  1882 00002B6D B020                <1> 	mov	al,20h			; send EOI (end of interrupt)
  1883 00002B6F E620                <1> 	out	pic1_reg0,al		; to the 8259A PIC
  1884                              <1> 
  1885                              <1> .pause_loop:
  1886 00002B71 F606180008          <1> 	test	byte [kbd_flags_2],08h
  1887 00002B76 75F9                <1> 	jnz	.pause_loop		; wait if pause flag is set
  1888 00002B78 EBE8                <1> 	jmp	keyboard_int_exit1
  1889                              <1> 
  1890                              <1> print_screen:
  1891 00002B7A B020                <1> 	mov	al,20h			; send EOI (end of interrupt)
  1892 00002B7C E620                <1> 	out	pic1_reg0,al		; to the 8259A PIC
  1893 00002B7E CD05                <1> 	int	5h			; INT 5 - print screen
  1894 00002B80 80269600FD          <1> 	and     byte [kbd_flags_3],0FDh	; clear E0 flag
  1895 00002B85 EBDB                <1> 	jmp	keyboard_int_exit1
  1896                              <1> 
  1897                              <1> ;=========================================================================
  1898                              <1> ; set_LEDs - Update the kbd_flags_4 LED bits from the kbd_flags_1
  1899                              <1> ; 	     variable and update LEDs on the keyboard
  1900                              <1> ;-------------------------------------------------------------------------
  1901                              <1> set_LEDs:
  1902 00002B87 B020                <1> 	mov	al,20h			; send EOI (end of interrupt)
  1903 00002B89 E620                <1> 	out	pic1_reg0,al		; to the 8259A PIC
  1904                              <1> 
  1905 00002B8B A01700              <1> 	mov	al,byte [kbd_flags_1]
  1906 00002B8E D0E8                <1> 	shr	al,1
  1907 00002B90 D0E8                <1> 	shr	al,1
  1908 00002B92 D0E8                <1> 	shr	al,1
  1909 00002B94 D0E8                <1> 	shr	al,1
  1910 00002B96 2407                <1> 	and	al,111b
  1911 00002B98 80269700F8          <1> 	and	byte [kbd_flags_4],0F8h	; clear LED bits.
  1912 00002B9D 08069700            <1> 	or	byte [kbd_flags_4],al	; mask in new bits.
  1913                              <1> %ifdef AT_KEYBOARD
  1914                              <1> %ifndef DISABLE_KBD_DURING_INTERRUPTS
  1915                              <1> 	mov	al,kbc_cmd_kbd_ena	; enable keyboard interface
  1916                              <1> 	call	kbc_write_command
  1917                              <1> %endif
  1918                              <1> 	mov	ah,al			; save LED bits
  1919                              <1> 
  1920                              <1> 	mov	al,kbc_cmd_kbd_dis	; disable keyboard interface
  1921                              <1> 	call	kbc_write_command
  1922                              <1> 
  1923                              <1> 	mov	al,kbd_cmd_leds		; set LEDs command
  1924                              <1> 	call	kbc_kb_send		; send the command to the keyboard
  1925                              <1> 	mov	al,ah			; get parameter byte
  1926                              <1> 	call	kbc_kb_send		; send parameter to the keyboard
  1927                              <1> 
  1928                              <1> 	mov	al,kbc_cmd_kbd_ena	; enable keyboard interface
  1929                              <1> 	call	kbc_write_command
  1930                              <1> 	mov	al,dev_cmd_enable	; restart keyboard scanning
  1931                              <1> 	call	kbc_kb_send
  1932                              <1> %endif ; AT_KEYBOARD
  1933 00002BA1 EBBF                <1> 	jmp	keyboard_int_exit1
  1934                              <1> 
  1935                              <1> ;=========================================================================
  1936                              <1> ; kbd_buffer_init - Setup keyboard buffer
  1937                              <1> ;-------------------------------------------------------------------------
  1938                              <1> kbd_buffer_init:
  1939 00002BA3 B81E00              <1> 	mov	ax,kbd_buffer		; setup keyboard buffer
  1940 00002BA6 A38000              <1> 	mov	word [kbd_buffer_start],ax
  1941 00002BA9 A31A00              <1> 	mov	word [kbd_buffer_head],ax
  1942 00002BAC A31C00              <1> 	mov	word [kbd_buffer_tail],ax
  1943 00002BAF 83C020              <1> 	add	ax,20h			; size of the keyboard buffer
  1944 00002BB2 A38200              <1> 	mov	word [kbd_buffer_end],ax
  1945 00002BB5 31C0                <1> 	xor	ax,ax			; clear keyboard flags
  1946 00002BB7 A31700              <1> 	mov	word [kbd_flags_1],ax
  1947 00002BBA A31800              <1> 	mov	word [kbd_flags_2],ax
  1948 00002BBD A39600              <1> 	mov	word [kbd_flags_3],ax
  1949 00002BC0 A39700              <1> 	mov	word [kbd_flags_4],ax
  1950 00002BC3 C3                  <1> 	ret
  1325                                  %include	"floppy2.inc"		; INT 13
  1326                              <1> ;=========================================================================
  1327                              <1> ; floppy2.inc - BIOS floppy disk services (part 2 of 2)
  1328                              <1> ;	INT 13h, function AH=02h
  1329                              <1> ;	INT 13h, function AH=03h
  1330                              <1> ;	INT 13h, function AH=04h
  1331                              <1> ;	INT 13h, function AH=05h
  1332                              <1> ;	- see floppy1.inc for other INT 13h functions
  1333                              <1> ;-------------------------------------------------------------------------
  1334                              <1> ;
  1335                              <1> ; Compiles with NASM 2.13.02, might work with other versions
  1336                              <1> ;
  1337                              <1> ; Copyright (C) 2010 - 2023 Sergey Kiselev.
  1338                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
  1339                              <1> ;
  1340                              <1> ; This program is free software: you can redistribute it and/or modify
  1341                              <1> ; it under the terms of the GNU General Public License as published by
  1342                              <1> ; the Free Software Foundation, either version 3 of the License, or
  1343                              <1> ; (at your option) any later version.
  1344                              <1> ;
  1345                              <1> ; This program is distributed in the hope that it will be useful,
  1346                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  1347                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  1348                              <1> ; GNU General Public License for more details.
  1349                              <1> ;
  1350                              <1> ; You should have received a copy of the GNU General Public License
  1351                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  1352                              <1> ;
  1353                              <1> ;=========================================================================
  1354                              <1> 
  1355                              <1> ;-------------------------------------------------------------------------
  1356                              <1> ; offsets for registers on stack
  1357                              <1> int_13_bp	equ	0
  1358                              <1> int_13_ds	equ	int_13_bp+2
  1359                              <1> int_13_di	equ	int_13_ds+2
  1360                              <1> int_13_si	equ	int_13_di+2
  1361                              <1> int_13_dx	equ	int_13_si+2
  1362                              <1> int_13_dl	equ	int_13_dx
  1363                              <1> int_13_dh	equ	int_13_dx+1
  1364                              <1> int_13_cx	equ	int_13_dx+2
  1365                              <1> int_13_cl	equ	int_13_cx
  1366                              <1> int_13_ch	equ	int_13_cx+1
  1367                              <1> int_13_bx	equ	int_13_cx+2
  1368                              <1> int_13_bl	equ	int_13_bx
  1369                              <1> int_13_bh	equ	int_13_bx+1
  1370                              <1> int_13_ax	equ	int_13_bx+2
  1371                              <1> int_13_al	equ	int_13_ax
  1372                              <1> int_13_ah	equ	int_13_ax+1
  1373                              <1> int_13_ip	equ	int_13_ax+2
  1374                              <1> int_13_cs	equ	int_13_ip+2
  1375                              <1> int_13_flags	equ	int_13_cs+2
  1376                              <1> int_13_flags_l	equ	int_13_flags
  1377                              <1> 
  1378                              <1> ;=========================================================================
  1379                              <1> ; int_13 - BIOS floppy disk services
  1380                              <1> ; Input:
  1381                              <1> ;	AH = function
  1382                              <1> ;		00h - Reset disk system
  1383                              <1> ;		01h - Get status of last operation
  1384                              <1> ;		02h - Read disk sectors
  1385                              <1> ;		03h - Write disk sectors
  1386                              <1> ;		04h - Verify disk sectors
  1387                              <1> ;		05h - Format track
  1388                              <1> ;		08h - Get drive parameters
  1389                              <1> ;		15h - Get disk type
  1390                              <1> ;		16h - Detect disk change
  1391                              <1> ;		17h - Set disk type for format
  1392                              <1> ;		18h - Set media type for format
  1393                              <1> ; Output:
  1394                              <1> ;	- depends on function
  1395                              <1> ;	- for most functions:
  1396                              <1> ;		CF clear if successful
  1397                              <1> ;			AH = 00h - successful completion
  1398                              <1> ;		CF set on error
  1399                              <1> ;			AH = error code
  1400                              <1> ;-------------------------------------------------------------------------
  1401 00002BC4 FF<rep 95h>         <1> 	setloc	0EC59h			; INT 13 (Floppy) Entry Point
  1401          ******************  <1>  warning: Inserting 149 bytes [-w+user]
  1402                              <1> int_13:
  1403 00002C59 FB                  <1> 	sti
  1404 00002C5A 50                  <1> 	push	ax
  1405 00002C5B 53                  <1> 	push	bx
  1406 00002C5C 51                  <1> 	push	cx
  1407 00002C5D 52                  <1> 	push	dx
  1408 00002C5E 56                  <1> 	push	si
  1409 00002C5F 57                  <1> 	push	di
  1410 00002C60 1E                  <1> 	push	ds
  1411 00002C61 55                  <1> 	push	bp
  1412 00002C62 89E5                <1> 	mov	bp,sp
  1413                              <1> 
  1414 00002C64 BB4000              <1> 	mov	bx,biosdseg
  1415 00002C67 8EDB                <1> 	mov	ds,bx
  1416                              <1> 
  1417                              <1> ; fn01 doesn't need drive type
  1418                              <1> 
  1419 00002C69 80FC01              <1> 	cmp	ah,01h
  1420 00002C6C 7503E931DC          <1> 	je	int_13_fn01		; Get status of last operation
  1421                              <1> 
  1422                              <1> 
  1423 00002C71 80FA01              <1> 	cmp	dl,1
  1424 00002C74 7703                <1> 	ja	.try_fn08		; invalid drive number, but try fn08
  1425                              <1> 
  1426                              <1> ; get drive type
  1427                              <1> 
  1428 00002C76 E828E3              <1> 	call	get_drive_type		; AL = drive type
  1429                              <1> 
  1430                              <1> ; fn08 needs physical drive information, but can accept drive numbers 0 - 7Fh
  1431                              <1> 
  1432                              <1> .try_fn08:
  1433 00002C79 80FC08              <1> 	cmp	ah,08h
  1434 00002C7C 7503E92DDC          <1> 	je	int_13_fn08		; Get drive parameters
  1435                              <1> 
  1436 00002C81 80FA01              <1> 	cmp	dl,1
  1437 00002C84 7743                <1> 	ja	.invalid_parameters	; invalid drive number (> 1)
  1438                              <1> 
  1439                              <1> ; fn15 accepts not existing drive numbers (and returns status 00h for them)
  1440                              <1> 
  1441 00002C86 80FC15              <1> 	cmp	ah,15h
  1442 00002C89 7503E9CCDC          <1> 	je	int_13_fn15		; Get disk type
  1443                              <1> 
  1444                              <1> ; all other functions require an existing drive number
  1445                              <1> 
  1446 00002C8E 3C00                <1> 	cmp	al,type_none
  1447 00002C90 7437                <1> 	je	.invalid_parameters	; drive not present or not configured
  1448                              <1> 
  1449                              <1> ; dispatch
  1450                              <1> 
  1451 00002C92 80FC00              <1> 	cmp	ah,00h
  1452 00002C95 7503E999DB          <1> 	je	int_13_fn00		; Reset disk system
  1453 00002C9A 80FC02              <1> 	cmp	ah,02h
  1454 00002C9D 746B                <1> 	je	int_13_fn02		; Read disk sectors
  1455 00002C9F 80FC03              <1> 	cmp	ah,03h
  1456 00002CA2 7466                <1> 	je	int_13_fn03		; Write disk sectors
  1457 00002CA4 80FC04              <1> 	cmp	ah,04h
  1458 00002CA7 7461                <1> 	je	int_13_fn04		; Verify disk sectors
  1459 00002CA9 80FC05              <1> 	cmp	ah,05h
  1460 00002CAC 7503E9C401          <1> 	je	int_13_fn05		; Format track
  1461 00002CB1 80FC16              <1> 	cmp	ah,16h
  1462 00002CB4 7503E9BCDC          <1> 	je	int_13_fn16		; Detect disk change
  1463 00002CB9 80FC17              <1> 	cmp	ah,17h
  1464 00002CBC 7503E9F6DC          <1> 	je	int_13_fn17		; Set disk type for format
  1465 00002CC1 80FC18              <1> 	cmp	ah,18h
  1466 00002CC4 7503E949DD          <1> 	je	int_13_fn18		; Set media type for format
  1467                              <1> 
  1468                              <1> .invalid_parameters:
  1469 00002CC9 B401                <1> 	mov	ah,fdc_e_invalid
  1470 00002CCB 88264100            <1> 	mov	byte [fdc_last_error],ah
  1471 00002CCF F9                  <1> 	stc				; error condition
  1472 00002CD0 EB1F                <1> 	jmp	int_13_exit
  1473                              <1> 
  1474                              <1> ;-------------------------------------------------------------------------
  1475                              <1> ; int_13_upd_exit - Update diskette change flag and exit
  1476                              <1> ; FIXME: what uses this (fdc_info) flag?
  1477                              <1> 
  1478                              <1> int_13_upd_exit:
  1479 00002CD2 9C                  <1> 	pushf
  1480 00002CD3 50                  <1> 	push	ax
  1481 00002CD4 8A4608              <1> 	mov	al,byte [bp+int_13_dl]	; AL = drive number
  1482 00002CD7 3C01                <1> 	cmp	al,1
  1483 00002CD9 7714                <1> 	ja	.no_update		; skip if drive number > 1
  1484 00002CDB E864E2              <1> 	call	get_media_state		; BL = drive media state
  1485 00002CDE F6C310              <1> 	test	bl,fdc_m_established
  1486 00002CE1 740C                <1> 	jz	.no_update		; skip if media type not established
  1487 00002CE3 B404                <1> 	mov	ah,04h			; set bit 2 (drive 0 type determined)
  1488 00002CE5 08C0                <1> 	or	al,al
  1489 00002CE7 7402                <1> 	jz	.drive_0
  1490 00002CE9 B440                <1> 	mov	ah,40h			; set bit 6 (drive 1 type determined)
  1491                              <1> 
  1492                              <1> .drive_0:
  1493 00002CEB 08268F00            <1> 	or	byte [fdc_info],ah	; set media detected bit
  1494                              <1> 
  1495                              <1> .no_update:
  1496 00002CEF 58                  <1> 	pop	ax
  1497 00002CF0 9D                  <1> 	popf
  1498                              <1> 
  1499                              <1> int_13_exit:
  1500 00002CF1 88660F              <1> 	mov	byte [bp+int_13_ah],ah	; pass AH to the caller
  1501 00002CF4 B80102              <1> 	mov	ax,201h			; set IF and CF
  1502 00002CF7 7205                <1> 	jc	.set_error		; there is an error
  1503 00002CF9 806614FE            <1> 	and	byte [bp+int_13_flags_l],0FEh ; no errors - clear CF
  1504 00002CFD 48                  <1> 	dec	ax			; clear CF in AX too
  1505                              <1> 
  1506                              <1> .set_error:
  1507 00002CFE 094614              <1> 	or	word [bp+int_13_flags],ax
  1508 00002D01 5D                  <1> 	pop	bp
  1509 00002D02 1F                  <1> 	pop	ds
  1510 00002D03 5F                  <1> 	pop	di
  1511 00002D04 5E                  <1> 	pop	si
  1512 00002D05 5A                  <1> 	pop	dx
  1513 00002D06 59                  <1> 	pop	cx
  1514 00002D07 5B                  <1> 	pop	bx
  1515 00002D08 58                  <1> 	pop	ax
  1516 00002D09 CF                  <1> 	iret
  1517                              <1> 
  1518                              <1> ;=========================================================================
  1519                              <1> ; int_13_fn02 - Read disk sectors
  1520                              <1> ; int_13_fn03 - Write disk sectors
  1521                              <1> ; int_13_fn04 - Verify disk sectors
  1522                              <1> ; Input:
  1523                              <1> ;	AH = function
  1524                              <1> ;		02h - read
  1525                              <1> ;		03h - write
  1526                              <1> ;		04h - verify
  1527                              <1> ;	AL = number of sectors to read / write / verify (must be nonzero)
  1528                              <1> ;	CH = cylinder number
  1529                              <1> ;	CL = sector number
  1530                              <1> ;	DH = head number (0 or 1)
  1531                              <1> ;	DL = drive number (0 or 1)
  1532                              <1> ;	ES:BX -> data buffer
  1533                              <1> ; Output:
  1534                              <1> ;	CF clear if successful
  1535                              <1> ;		AH = 00h - successful completion
  1536                              <1> ;		AL = number of sectors transferred or verified
  1537                              <1> ;	CF set on error
  1538                              <1> ;		AH = error code
  1539                              <1> ;-------------------------------------------------------------------------
  1540                              <1> int_13_fn02:
  1541                              <1> int_13_fn03:
  1542                              <1> int_13_fn04:
  1543 00002D0A 807E0E00            <1> 	cmp	byte [bp+int_13_al],0	; number of sectors must be non zero
  1544 00002D0E 7503E95D01          <1> 	je	.invalid_request
  1545                              <1> 
  1546 00002D13 E82CE2              <1> 	call	get_media_state		; BL = media state
  1547                              <1> 
  1548 00002D16 80FC03              <1> 	cmp	ah,03h			; write function
  1549 00002D19 7407                <1> 	je	.set_write
  1550 00002D1B 80263F007F          <1> 	and	byte [fdc_motor_state],~fdc_write_flag ; clear the write bit
  1551 00002D20 EB05                <1> 	jmp	.motor_on
  1552                              <1> 
  1553                              <1> .set_write:
  1554 00002D22 800E3F0080          <1> 	or	byte [fdc_motor_state],fdc_write_flag ; set the write bit
  1555                              <1> 
  1556                              <1> .motor_on:
  1557 00002D27 E86CDE              <1> 	call	fdc_motor_on
  1558                              <1> 
  1559 00002D2A 3C01                <1> 	cmp	al,type_360
  1560 00002D2C 7420                <1> 	je	.set_media_360		; set media type for 360K drive
  1561 00002D2E 3C03                <1> 	cmp	al,type_720
  1562 00002D30 7420                <1> 	je	.set_media_720		; set media type for 720K drive
  1563                              <1> 
  1564 00002D32 E806DF              <1> 	call	fdc_disk_change
  1565 00002D35 80FC06              <1> 	cmp	ah,fdc_e_changed
  1566 00002D38 7425                <1> 	je	.establish_media	; disk changed - establish media
  1567 00002D3A 80FC00              <1> 	cmp	ah,fdc_e_success
  1568 00002D3D 7403E92101          <1> 	jne	.error_end_io		; fdc_disk_change failed
  1569                              <1> 
  1570 00002D42 F6C310              <1> 	test	bl,fdc_m_established
  1571 00002D45 7418                <1> 	jz	.establish_media	; jump if media type is not established
  1572                              <1> 
  1573 00002D47 88D8                <1> 	mov	al,bl			; media type to AL (transfer rate)
  1574 00002D49 E8A6E1              <1> 	call	fdc_set_rate		; select transfer rate
  1575 00002D4C EB19                <1> 	jmp	.fdc_send_specify
  1576                              <1> 
  1577                              <1> ; 360K and 720K drives don't support change line, and only support
  1578                              <1> ; one media type - set it here
  1579                              <1> 
  1580                              <1> .set_media_360:
  1581 00002D4E B093                <1> 	mov	al,fdc_m_360in360	; 250Kbps, media established, 360K/360K
  1582 00002D50 EB02                <1> 	jmp	.set_media
  1583                              <1> 
  1584                              <1> .set_media_720:
  1585 00002D52 B097                <1> 	mov	al,fdc_m_720		; 250Kbps, media established, 720K/720K
  1586                              <1> 
  1587                              <1> .set_media:
  1588 00002D54 E8F5E1              <1> 	call	set_media_state		; save media state (AL) to the data area
  1589 00002D57 E898E1              <1> 	call	fdc_set_rate		; send transfer rate (in AL) to FDC
  1590 00002D5A 8B5608              <1> 	mov	dx,word [bp+int_13_dx]	; restore DX (trashed by fdc_set_rate)
  1591 00002D5D EB08                <1> 	jmp	.fdc_send_specify
  1592                              <1> 
  1593                              <1> .establish_media:
  1594 00002D5F E8CBE0              <1> 	call	fdc_detect_media	; detect media type
  1595 00002D62 7303E9FC00          <1> 	jc	.error_end_io
  1596                              <1> 	
  1597                              <1> .fdc_send_specify:
  1598 00002D67 B803BF              <1> 	mov	ax,0BF03h		; FDC Specify command +
  1599                              <1> 					; 0BFh - specify byte 0 for 1.44M
  1600 00002D6A 80FB17              <1> 	cmp	bl,fdc_m_1440		; 1.44M?
  1601 00002D6D 7409                <1> 	je	.fdc_send_specify_cmd	; jump if 1.44M
  1602 00002D6F B4DF                <1> 	mov	ah,0DFh			; 0DFh - specify byte 0 for 360/1.2/720
  1603 00002D71 80FBD7              <1> 	cmp	bl,fdc_m_2880		; 2.88M?
  1604 00002D74 7502                <1> 	jne	.fdc_send_specify_cmd	; jump if not 2.88M
  1605 00002D76 B4AF                <1> 	mov	ah,0AFh			; 0AFh - specify byte 0 for 2.88M
  1606                              <1> 
  1607                              <1> .fdc_send_specify_cmd:
  1608 00002D78 BE0200              <1> 	mov	si,2			; specify byte 1
  1609 00002D7B B103                <1> 	mov	cl,3			; 3 bytes command
  1610 00002D7D E874DF              <1> 	call	fdc_send_cmd
  1611 00002D80 7303E9DE00          <1> 	jc	.error_end_io		; jump if failed to send command
  1612 00002D85 1E                  <1> 	push	ds
  1613 00002D86 31F6                <1> 	xor	si,si
  1614 00002D88 8EDE                <1> 	mov	ds,si
  1615 00002D8A C5367800            <1> 	lds	si,[1Eh*4]		; DS:SI -> INT 1Eh
  1616 00002D8E 8A4E0E              <1> 	mov	cl,byte [bp+int_13_al]	; number of sectors to transfer
  1617 00002D91 B400                <1> 	mov	ah,00h
  1618 00002D93 88C8                <1> 	mov	al,cl			; AX =  number of sectors to transfer
  1619 00002D95 024E0A              <1> 	add	cl,byte [bp+int_13_cl]	; number of the first sector to access
  1620 00002D98 FEC9                <1> 	dec	cl			; minus 1 - last sector to access
  1621 00002D9A 3A4C04              <1> 	cmp	cl,byte [si+4]		; compare with sectors per track
  1622 00002D9D 7603                <1> 	jbe	.calc_dma_count		; jump if last sector <= sectors/track
  1623 00002D9F 884C04              <1> 	mov	byte [si+4],cl		; update it in disk parameter table
  1624                              <1> 
  1625                              <1> .calc_dma_count:
  1626 00002DA2 8A4C03              <1> 	mov	cl,byte [si+3]		; bytes per sector (02h = 512 bytes...)
  1627 00002DA5 80C107              <1> 	add	cl,7			; CL = log2 (bytes per sector)
  1628 00002DA8 D3E0                <1> 	shl	ax,cl			; AX = AL * 2 ^ CL = AX * bytes/sector
  1629 00002DAA 1F                  <1> 	pop	ds
  1630 00002DAB 48                  <1> 	dec	ax			; minus one byte
  1631 00002DAC 89C1                <1> 	mov	cx,ax			; ...count for DMA
  1632                              <1> 
  1633 00002DAE 8A660F              <1> 	mov	ah,byte [bp+int_13_ah]	; AH = function
  1634 00002DB1 B046                <1> 	mov	al,46h			; DMA mode byte for read, channel 2
  1635 00002DB3 80FC02              <1> 	cmp	ah,02h			; read function?
  1636 00002DB6 7409                <1> 	je	.configure_dma		; jump if read function
  1637 00002DB8 B04A                <1> 	mov	al,4Ah			; DMA mode byte for write, channel 2
  1638 00002DBA 80FC03              <1> 	cmp	ah,03h			; write function?
  1639 00002DBD 7402                <1> 	je	.configure_dma		; jump if write function
  1640 00002DBF B042                <1> 	mov	al,42h			; DMA mode byte for verify, channel 2
  1641                              <1> 
  1642                              <1> .configure_dma:
  1643 00002DC1 E8C8DE              <1> 	call	fdc_configure_dma
  1644 00002DC4 8B4E0A              <1> 	mov	cx,word [bp+int_13_cx]	; restore parameters
  1645 00002DC7 7303E99700          <1> 	jc	.error_end_io		; jump if DMA boundry crossed
  1646                              <1> 
  1647 00002DCC E818DD              <1> 	call 	fdc_seek		; seek drive DL to cylinder CH, head DH
  1648 00002DCF 7303E98800          <1> 	jc	.error_fdc_get_result	; jump if seek failed
  1649                              <1> 
  1650 00002DD4 1E                  <1> 	push	ds
  1651 00002DD5 31F6                <1> 	xor	si,si
  1652 00002DD7 8EDE                <1> 	mov	ds,si
  1653 00002DD9 C5367800            <1> 	lds	si,[1Eh*4]		; DS:SI -> INT 1Eh
  1654 00002DDD 8A6403              <1> 	mov	ah,byte [si+3]		; AH = sector size (02h = 512)
  1655 00002DE0 88C8                <1> 	mov	al,cl			; AL = first sector number
  1656 00002DE2 89C7                <1> 	mov	di,ax			; DI = first sector, sector size
  1657 00002DE4 8A5C04              <1> 	mov	bl,byte [si+4]		; BL = sectors per track
  1658 00002DE7 8A6C06              <1> 	mov	ch,byte [si+6]		; CH = special sector size
  1659 00002DEA 1F                  <1> 	pop	ds
  1660                              <1> 
  1661 00002DEB 53                  <1> 	push	bx
  1662 00002DEC E853E1              <1> 	call	get_media_state
  1663 00002DEF 88DA                <1> 	mov	dl,bl			; DL = drive media state
  1664 00002DF1 5B                  <1> 	pop	bx
  1665 00002DF2 B71B                <1> 	mov	bh,1Bh			; read / write gap for 1.2M/1.44M/2.88M
  1666 00002DF4 80FA17              <1> 	cmp	dl,fdc_m_1440		; 1.44M media?
  1667 00002DF7 7413                <1> 	je	.gap_set		; jump if 1.44M media
  1668 00002DF9 80FA15              <1> 	cmp	dl,fdc_m_1200in1200	; 1.2M in 1.2M drive?
  1669 00002DFC 740E                <1> 	je	.gap_set		; jump if 1.2M media in 1.2M drive
  1670 00002DFE 80FAD7              <1> 	cmp	dl,fdc_m_2880		; 2.88 media?
  1671 00002E01 7409                <1> 	je	.gap_set		; jump if 2.88M media
  1672 00002E03 B723                <1> 	mov	bh,23h			; read / write gap for 360K in 1.2M drv
  1673 00002E05 80FA74              <1> 	cmp	dl,fdc_m_360in1200	; 360K in 1.2M drive
  1674 00002E08 7402                <1> 	je	.gap_set		; jump if 360K media in 1.2M drive
  1675 00002E0A B72A                <1> 	mov	bh,2Ah			; read / write gap for 360K and 720K drv
  1676                              <1> 	
  1677                              <1> .gap_set:
  1678 00002E0C 8A7609              <1> 	mov	dh,byte [bp+int_13_dh]	; restore DH
  1679 00002E0F 8A460B              <1> 	mov	al,byte [bp+int_13_ch]	; cylinder
  1680 00002E12 88F4                <1> 	mov	ah,dh			; head
  1681                              <1> 					; replace with mov ah,byte[bp+int_13_dh]
  1682 00002E14 89C6                <1> 	mov	si,ax			; head / cylinder (bytes 2-3)
  1683 00002E16 D0E4                <1> 	shl	ah,1
  1684 00002E18 D0E4                <1> 	shl	ah,1
  1685 00002E1A 0A6608              <1> 	or	ah,byte [bp+int_13_dl]	; FDC command byte 1 (head & drive)
  1686 00002E1D B0E6                <1> 	mov	al,0E6h			; FDC Read command
  1687 00002E1F 807E0F03            <1> 	cmp	byte [bp+int_13_ah],3	; write function?
  1688 00002E23 7502                <1> 	jne	.send_command		; jump if not write 
  1689 00002E25 B0C5                <1> 	mov	al,0C5h			; FDC Write command
  1690                              <1> 
  1691                              <1> .send_command:
  1692 00002E27 B109                <1> 	mov	cl,9			; 9 bytes command
  1693 00002E29 80263E007F          <1> 	and	byte [fdc_calib_state],~fdc_irq_flag ; wait for IRQ
  1694 00002E2E E8C3DE              <1> 	call	fdc_send_cmd
  1695 00002E31 7229                <1> 	jc	.error_fdc_get_result	; jump if failed to send command
  1696 00002E33 E8D5E0              <1> 	call	fdc_wait_irq
  1697 00002E36 7224                <1> 	jc	.error_fdc_get_result
  1698 00002E38 B107                <1> 	mov	cl,7
  1699 00002E3A E829DF              <1> 	call	fdc_get_result		; read result bytes
  1700 00002E3D 7224                <1> 	jc	.error_end_io
  1701                              <1> 
  1702 00002E3F E87EDF              <1> 	call	fdc_get_error
  1703                              <1> 
  1704 00002E42 8A6E0B              <1> 	mov	ch,byte [bp+int_13_ch]	; CH = cylinder
  1705                              <1> ;	mov	dh,byte [bp+int_13_dh]	; DH = head
  1706                              <1> 					; Optimization: DH is preserved
  1707 00002E45 E8C8DD              <1> 	call	fdc_end_io		; return number of last sector in BL
  1708 00002E48 88D8                <1> 	mov	al,bl			; AL = last transferred sector
  1709 00002E4A 2A460A              <1> 	sub	al,byte [bp+int_13_cl]	; minus the first sector
  1710                              <1> 
  1711                              <1> .zero_sectors:
  1712 00002E4D 08E4                <1> 	or	ah,ah
  1713 00002E4F 7401                <1> 	jz	.exit			; jump if no errors
  1714                              <1> 
  1715                              <1> .error:
  1716 00002E51 F9                  <1> 	stc				; indicate error
  1717                              <1> 
  1718                              <1> .exit:
  1719 00002E52 88264100            <1> 	mov	byte [fdc_last_error],ah
  1720 00002E56 88460E              <1> 	mov	byte [bp+int_13_al],al	; number of transferred sectors
  1721 00002E59 E976FE              <1> 	jmp	int_13_upd_exit
  1722                              <1> 
  1723                              <1> .error_fdc_get_result:
  1724 00002E5C B107                <1> 	mov	cl,7
  1725 00002E5E 50                  <1> 	push	ax
  1726 00002E5F E804DF              <1> 	call	fdc_get_result		; read result bytes
  1727 00002E62 58                  <1> 	pop	ax
  1728                              <1> 
  1729                              <1> .error_end_io:
  1730 00002E63 8A6E0B              <1> 	mov	ch,byte [bp+int_13_ch]	; CH = cylinder
  1731 00002E66 8A7609              <1> 	mov	dh,byte [bp+int_13_dh]	; DH = head
  1732 00002E69 E8A4DD              <1> 	call	fdc_end_io		; return number of last sector in BL
  1733 00002E6C B000                <1> 	mov	al,00h			; failure, no sectors transferred
  1734 00002E6E EBDD                <1> 	jmp	.zero_sectors
  1735                              <1> 
  1736                              <1> .invalid_request:
  1737 00002E70 B80001              <1> 	mov	ax,fdc_e_invalid << 8	; AH = 01h, AL = 00h (0 sectors trans)
  1738 00002E73 EBDC                <1> 	jmp	.error
  1739                              <1> 
  1740                              <1> ;=========================================================================
  1741                              <1> ; int_13_fn05 - Format track
  1742                              <1> ; Input:
  1743                              <1> ;	AH = 05h
  1744                              <1> ;	CH = track number
  1745                              <1> ;	DH = head number (0 or 1)
  1746                              <1> ;	DL = drive number (0 or 1)
  1747                              <1> ;	ES:BX -> address field buffer
  1748                              <1> ; Output:
  1749                              <1> ;	CF clear if successful
  1750                              <1> ;		AH = 00h - successful completion
  1751                              <1> ;	CF set on error
  1752                              <1> ;		AH = error code 
  1753                              <1> ;-------------------------------------------------------------------------
  1754                              <1> int_13_fn05:
  1755 00002E75 E8CAE0              <1> 	call	get_media_state		; BL = drive media state
  1756 00002E78 F6C310              <1> 	test	bl,fdc_m_established
  1757 00002E7B 7503E98100          <1> 	jz	.timeout		; jump if media type is not established
  1758 00002E80 800E3F0080          <1> 	or	byte [fdc_motor_state],fdc_write_flag ; set the write bit
  1759 00002E85 E80EDD              <1> 	call	fdc_motor_on
  1760 00002E88 E8B0DD              <1> 	call	fdc_disk_change		; read disk change line
  1761 00002E8B 726F                <1> 	jc	.error_end_io		; jump if disk change check failed
  1762 00002E8D 88D8                <1> 	mov	al,bl			; media type to AL (transfer rate)
  1763 00002E8F E860E0              <1> 	call	fdc_set_rate		; select transfer rate
  1764 00002E92 E8EED9              <1> 	call	fdc_send_specify	; send FDC Specify command
  1765                              <1> 
  1766 00002E95 8A6E0B              <1> 	mov	ch,byte [bp+int_13_ch]	; cylinder
  1767 00002E98 E84CDC              <1> 	call 	fdc_seek		; seek drive DL to cylinder CH, head DH
  1768 00002E9B 7256                <1> 	jc	.error_fdc_get_result	; jump if seek failed
  1769                              <1> 
  1770 00002E9D 1E                  <1> 	push	ds
  1771 00002E9E 31F6                <1> 	xor	si,si
  1772 00002EA0 8EDE                <1> 	mov	ds,si
  1773 00002EA2 C5367800            <1> 	lds	si,[1Eh*4]		; DS:SI -> INT 1Eh
  1774 00002EA6 8A4C04              <1> 	mov	cl,byte [si+4]		; sectors per track
  1775 00002EA9 8B7C07              <1> 	mov	di,word [si+7]		; format gap, sectors per track
  1776 00002EAC 8B7403              <1> 	mov	si,word [si+3]		; bytes per sector, sectors per track
  1777 00002EAF 1F                  <1> 	pop	ds
  1778                              <1> 
  1779 00002EB0 B500                <1> 	mov	ch,00h			; CX = sectors per track
  1780 00002EB2 D1E1                <1> 	shl	cx,1			; CX = CX * 4 (address field is 4 bytes)
  1781 00002EB4 D1E1                <1> 	shl	cx,1
  1782 00002EB6 49                  <1> 	dec	cx	 		; minus one byte...
  1783 00002EB7 B04A                <1> 	mov	al,4Ah			; DMA mode byte for write, channel 2
  1784 00002EB9 E8D0DD              <1> 	call	fdc_configure_dma
  1785 00002EBC 723E                <1> 	jc	.error_end_io		; DMA boundry crossed
  1786                              <1> 
  1787 00002EBE 88F4                <1> 	mov	ah,dh
  1788 00002EC0 D0E4                <1> 	shl	ah,1
  1789 00002EC2 D0E4                <1> 	shl	ah,1
  1790 00002EC4 0A6608              <1> 	or	ah,byte [bp+int_13_dl]	; FDC command byte 1 (head & drive)
  1791 00002EC7 B04D                <1> 	mov	al,4Dh			; FDC Format command
  1792 00002EC9 B106                <1> 	mov	cl,6			; 6 byte command
  1793 00002ECB 80263E007F          <1> 	and	byte [fdc_calib_state],~fdc_irq_flag ; wait for IRQ
  1794 00002ED0 E821DE              <1> 	call	fdc_send_cmd
  1795 00002ED3 720F                <1> 	jc	.exit_end_io		; jump if failed to send command
  1796 00002ED5 E833E0              <1> 	call	fdc_wait_irq
  1797 00002ED8 720A                <1> 	jc	.exit_end_io
  1798 00002EDA B107                <1> 	mov	cl,7
  1799 00002EDC E887DE              <1> 	call	fdc_get_result		; read result bytes
  1800 00002EDF 7203                <1> 	jc	.exit_end_io
  1801 00002EE1 E8DCDE              <1> 	call	fdc_get_error		; get error code
  1802                              <1> 
  1803                              <1> .exit_end_io:
  1804 00002EE4 E829DD              <1> 	call	fdc_end_io
  1805 00002EE7 08E4                <1> 	or	ah,ah
  1806 00002EE9 7401                <1> 	jz	.exit			; jump if no errors
  1807                              <1> 
  1808                              <1> .error:
  1809 00002EEB F9                  <1> 	stc				; indicate error
  1810                              <1> 
  1811                              <1> .exit:
  1812 00002EEC 88264100            <1> 	mov	byte [fdc_last_error],ah
  1813 00002EF0 E9DFFD              <1> 	jmp	int_13_upd_exit
  1814                              <1> 
  1815                              <1> .error_fdc_get_result:
  1816 00002EF3 B107                <1> 	mov	cl,7
  1817 00002EF5 50                  <1> 	push	ax
  1818 00002EF6 E86DDE              <1> 	call	fdc_get_result		; read result bytes
  1819 00002EF9 58                  <1> 	pop	ax
  1820 00002EFA EBE8                <1> 	jmp	.exit_end_io
  1821                              <1> 
  1822                              <1> .error_end_io:
  1823 00002EFC E811DD              <1> 	call	fdc_end_io
  1824 00002EFF EBEA                <1> 	jmp	.error
  1825                              <1> 
  1826                              <1> .timeout:
  1827 00002F01 B480                <1> 	mov	ah,fdc_e_timeout
  1828 00002F03 EBE6                <1> 	jmp	.error
  1829                              <1> 
  1830                              <1> .invalid_request:
  1831 00002F05 B401                <1> 	mov	ah,fdc_e_invalid
  1832 00002F07 EBE2                <1> 	jmp	.error
  1833                              <1> 
  1834                              <1> ;=========================================================================
  1835                              <1> ; int_0E - IRQ6 (FDC) service routine
  1836                              <1> ; Sets bit 7 in drive recalibration status byte (fdc_calib_state)
  1837                              <1> ;-------------------------------------------------------------------------
  1838 00002F09 FF<rep 4Eh>         <1> 	setloc	0EF57h
  1838          ******************  <1>  warning: Inserting 78 bytes [-w+user]
  1839                              <1> 
  1840                              <1> int_0E:
  1841 00002F57 50                  <1> 	push	ax
  1842 00002F58 1E                  <1> 	push	ds
  1843 00002F59 B84000              <1> 	mov	ax,biosdseg
  1844 00002F5C 8ED8                <1> 	mov	ds,ax
  1845 00002F5E 800E3E0080          <1> 	or	byte [fdc_calib_state],fdc_irq_flag ; set IRQ flag
  1846 00002F63 1F                  <1> 	pop	ds
  1847 00002F64 B020                <1> 	mov	al,20h			; send EOI to PIC
  1848 00002F66 E620                <1> 	out	pic1_reg0,al
  1849 00002F68 B80191              <1> 	mov	ax,9101h		; call "interrupt completed" OS hook
  1850 00002F6B CD15                <1> 	int	15h
  1851 00002F6D 58                  <1> 	pop	ax
  1852 00002F6E CF                  <1> 	iret
  1853                              <1> 
  1854                              <1> ;=========================================================================
  1855                              <1> ; Disk parameter tables in INT 1Eh format
  1856                              <1> ; Byte 0: First byte for specify command:
  1857                              <1> ;	bits 7-4: step rate ([32 ms - value * 2], e.g. 0D0h is 32-13*2 = 6 ms)
  1858                              <1> ;	bits 3-0: head unload time (0Fh = 240 ms)
  1859                              <1> ; Byte 1: Second byte for specify command:
  1860                              <1> ;	bits 7-1: head load time (1 = 4 ms)
  1861                              <1> ;	bit 0: non-DMA mode (always 0)
  1862                              <1> ; Byte 2: motor off timeout in clock ticks (25h - approximately 2 seconds)
  1863                              <1> ; Byte 3: sector size (00h - 128, 01h - 256, 02h - 512, 03h - 1024)
  1864                              <1> ; Byte 4: sectors per track
  1865                              <1> ; Byte 5: gap length for read/write (2Ah for 5.25", 1Bh for 3.5")
  1866                              <1> ; Byte 6: special sector size (0FFh - not used)
  1867                              <1> ; Byte 7: gap length for formating (50h for 5.25", 6Ch for 3.5")
  1868                              <1> ; Byte 8: format filler byte (default 0F6h)
  1869                              <1> ; Byte 9: head settle time in milliseconds
  1870                              <1> ; Byte A: motor start time, in 1/8 seconds
  1871                              <1> ; Byte B: number of cylinders minus one
  1872                              <1> ; Byte C: transfer rate (in bits 7 - 6)
  1873                              <1> ;-------------------------------------------------------------------------
  1874                              <1> media_360_in_360:
  1875 00002F6F DF022502092AFF50F6- <1> 	db	0DFh, 02h, 25h, 02h, 09h, 2Ah, 0FFh, 50h, 0F6h, 0Fh, 08h
  1875 00002F78 0F08                <1>
  1876 00002F7A 2780                <1> 	db	27h, 80h
  1877                              <1> media_1200:
  1878 00002F7C DF0225020F1BFF54F6- <1> 	db	0DFh, 02h, 25h, 02h, 0Fh, 1Bh, 0FFh, 54h, 0F6h, 0Fh, 08h
  1878 00002F85 0F08                <1>
  1879 00002F87 4F00                <1> 	db	4Fh, 00h
  1880                              <1> media_720:
  1881 00002F89 DF022502092AFF50F6- <1> 	db	0DFh, 02h, 25h, 02h, 09h, 2Ah, 0FFh, 50h, 0F6h, 0Fh, 08h
  1881 00002F92 0F08                <1>
  1882 00002F94 4F80                <1> 	db	4Fh, 80h
  1883                              <1> media_1440:
  1884 00002F96 BF022502121BFF6CF6- <1> 	db	0BFh, 02h, 25h, 02h, 12h, 1Bh, 0FFh, 6Ch, 0F6h, 0Fh, 08h
  1884 00002F9F 0F08                <1>
  1885 00002FA1 4F00                <1> 	db	4Fh, 00h
  1886                              <1> media_360_in_1200:
  1887 00002FA3 DF0225020923FF50F6- <1> 	db	0DFh, 02h, 25h, 02h, 09h, 23h, 0FFh, 50h, 0F6h, 0Fh, 08h
  1887 00002FAC 0F08                <1>
  1888 00002FAE 2740                <1> 	db	27h, 40h
  1889                              <1> media_2880:
  1890 00002FB0 AF022502241BFF50F6- <1> 	db	0AFh, 02h, 25h, 02h, 24h, 1Bh, 0FFh, 50h, 0F6h, 0Fh, 08h
  1890 00002FB9 0F08                <1>
  1891 00002FBB 4FC0                <1> 	db	4Fh, 0C0h
  1892                              <1> 
  1893                              <1> ;=========================================================================
  1894                              <1> ; Disk parameter table for IBM compatibility
  1895                              <1> ; Using 2.88M disk as it has maximal number of cylinders and sectors
  1896                              <1> ;-------------------------------------------------------------------------
  1897 00002FBD FF<rep Ah>          <1> 	setloc	0EFC7h
  1897          ******************  <1>  warning: Inserting 10 bytes [-w+user]
  1898                              <1> int_1E:
  1899 00002FC7 AF022502241BFF50F6- <1> 	db	0AFh, 02h, 25h, 02h, 24h, 1Bh, 0FFh, 50h, 0F6h, 0Fh, 08h
  1899 00002FD0 0F08                <1>
  1900                              <1> ;	db	4Fh, 0C0h
  1326                                  %include	"printer2.inc"		; INT 17
  1327                              <1> ;=========================================================================
  1328                              <1> ; printer2.inc - Parallel printer support (part 2 of 2)
  1329                              <1> ;       INT 17h, function AH=00h
  1330                              <1> ;	INT 17h, function AH=02h
  1331                              <1> ;	- see printer1.inc for other INT 17h functions
  1332                              <1> ;-------------------------------------------------------------------------
  1333                              <1> ;
  1334                              <1> ; Compiles with NASM 2.13.02, might work with other versions
  1335                              <1> ;
  1336                              <1> ; Copyright (C) 2010 - 2023 Sergey Kiselev.
  1337                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
  1338                              <1> ;
  1339                              <1> ; This program is free software: you can redistribute it and/or modify
  1340                              <1> ; it under the terms of the GNU General Public License as published by
  1341                              <1> ; the Free Software Foundation, either version 3 of the License, or
  1342                              <1> ; (at your option) any later version.
  1343                              <1> ;
  1344                              <1> ; This program is distributed in the hope that it will be useful,
  1345                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  1346                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  1347                              <1> ; GNU General Public License for more details.
  1348                              <1> ;
  1349                              <1> ; You should have received a copy of the GNU General Public License
  1350                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  1351                              <1> ;
  1352                              <1> ;=========================================================================
  1353                              <1> 
  1354                              <1> ;=========================================================================
  1355                              <1> ; int_17  - BIOS Printer Services
  1356                              <1> ;-------------------------------------------------------------------------
  1357                              <1> 	setloc	0EFD2h			; INT 17 Entry Point
  1358                              <1> int_17:
  1359 00002FD2 FB                  <1> 	sti
  1360 00002FD3 53                  <1> 	push	bx
  1361 00002FD4 52                  <1> 	push	dx
  1362 00002FD5 56                  <1> 	push	si
  1363 00002FD6 1E                  <1> 	push	ds
  1364 00002FD7 BB4000              <1> 	mov	bx,biosdseg
  1365 00002FDA 8EDB                <1> 	mov	ds,bx
  1366 00002FDC 83FA03              <1> 	cmp	dx,num_parallel
  1367 00002FDF 7326                <1> 	jae	int_17_error		; invalid port number specified
  1368 00002FE1 BE7800              <1> 	mov	si,printer_timeout	; printer port timeout setting in BDA
  1369 00002FE4 01D6                <1> 	add	si,dx			; [SI] = timeout for the selected port
  1370 00002FE6 89D3                <1> 	mov	bx,dx
  1371 00002FE8 D1E3                <1> 	shl	bx,1
  1372 00002FEA 8B5708              <1> 	mov	dx,word [equip_parallel+bx] ; DX = serial port address
  1373 00002FED 09D2                <1> 	or	dx,dx
  1374 00002FEF 7416                <1> 	jz	int_17_error		; specified port is not installed
  1375                              <1> 
  1376 00002FF1 88C3                <1> 	mov	bl,al			; save AL to BL
  1377                              <1> 
  1378 00002FF3 08E4                <1> 	or	ah,ah
  1379 00002FF5 7415                <1> 	jz	int_17_fn00		; AH = 00h
  1380 00002FF7 FECC                <1> 	dec	ah
  1381 00002FF9 7503E972E5          <1> 	jz	int_17_fn01		; AH = 01h
  1382 00002FFE FECC                <1> 	dec	ah
  1383 00003000 7436                <1> 	jz	int_17_fn02		; AH = 02h
  1384                              <1> 
  1385                              <1> int_17_exit:
  1386 00003002 80F448              <1> 	xor	ah,prn_stat_invert	; invert bits 3 and 6 of the status
  1387 00003005 88D8                <1> 	mov	al,bl			; restore AL
  1388                              <1> 
  1389                              <1> int_17_error:
  1390 00003007 1F                  <1> 	pop	ds
  1391 00003008 5E                  <1> 	pop	si
  1392 00003009 5A                  <1> 	pop	dx
  1393 0000300A 5B                  <1> 	pop	bx
  1394 0000300B CF                  <1> 	iret
  1395                              <1> 
  1396                              <1> ;=========================================================================
  1397                              <1> ; int_17_fn00 - Print character
  1398                              <1> ; Input:
  1399                              <1> ;	AH = 0 - function 00h - print character
  1400                              <1> ;	AL = character to print
  1401                              <1> ;	DX = printer port number (0-2)
  1402                              <1> ; Output:
  1403                              <1> ;	AH = printer status:
  1404                              <1> ;		bit 0	= 1	- timeout error
  1405                              <1> ;		bit 1,2		- reserved
  1406                              <1> ;		bit 3	= 1	- I/O error
  1407                              <1> ;		bit 4	= 1	- printed selected
  1408                              <1> ;		bit 5	= 1	- out of paper
  1409                              <1> ;		bit 6	= 1	- acknowledge from printer
  1410                              <1> ;		bit 7	= 1	- printer not busy
  1411                              <1> ;-------------------------------------------------------------------------
  1412                              <1> int_17_fn00:
  1413 0000300C EE                  <1> 	out	dx,al			; output the character to the data port
  1414 0000300D 42                  <1> 	inc	dx			; DX = prn_stat_reg
  1415                              <1> 					; OPTIMIZATION:
  1416                              <1> 					; prn_stat_reg = prn_data_reg + 1
  1417 0000300E EC                  <1> 	in	al,dx			; read status
  1418 0000300F 88C4                <1> 	mov	ah,al			; AH = printer status
  1419 00003011 F6C480              <1> 	test	ah,prn_stat_busy	; check if printer is busy
  1420 00003014 750C                <1>         jnz     .not_busy
  1421                              <1> 
  1422 00003016 B8FE90              <1> 	mov	ax,90FEh		; printer busy
  1423 00003019 CD15                <1> 	int	15h			; call OS hook
  1424                              <1> 
  1425 0000301B B780                <1> 	mov	bh,prn_stat_busy
  1426 0000301D E88FE4              <1> 	call	wait_for_port		; wait for printer to be ready
  1427 00003020 750E                <1> 	jnz	.timeout		; timeout had occured
  1428                              <1> 
  1429                              <1> .not_busy:
  1430 00003022 42                  <1> 	inc	dx			; DX = prn_ctrl_reg
  1431                              <1> 					; OPTIMIZATION:
  1432                              <1> 					; prn_ctrl_reg = prn_stat_reg + 1
  1433 00003023 B00D                <1> 	mov	al,(prn_ctrl_sel | prn_ctrl_init | prn_ctrl_strobe)
  1434 00003025 EE                  <1> 	out	dx,al			; activate strobe
  1435 00003026 E6C0                <1> 	out	unused_reg,al		; I/O delay
  1436 00003028 B00C                <1> 	mov	al,(prn_ctrl_sel | prn_ctrl_init)
  1437 0000302A EE                  <1> 	out	dx,al			; de-activate strobe
  1438 0000302B 80E4F8              <1> 	and	ah,prn_stat_bits	; leave only valid status bits
  1439 0000302E EBD2                <1> 	jmp	int_17_exit
  1440                              <1> 
  1441                              <1> .timeout:
  1442 00003030 80E4F8              <1> 	and	ah,prn_stat_bits
  1443 00003033 80CC01              <1> 	or	ah,prn_stat_tmout	; set timeout bit
  1444 00003036 EBCA                <1> 	jmp	int_17_exit
  1445                              <1> 
  1446                              <1> ;=========================================================================
  1447                              <1> ; int_17_fn02 - Return printer status
  1448                              <1> ; Input:
  1449                              <1> ;	AH = 2 - function 02h - return printer status
  1450                              <1> ;	DX = printer port number (0-2)
  1451                              <1> ; Output:
  1452                              <1> ;	AH = printer status (see int_17_fn00 for complete description)
  1453                              <1> ;-------------------------------------------------------------------------
  1454                              <1> int_17_fn02:
  1455 00003038 42                  <1> 	inc	dx			; DX = prn_stat_reg
  1456                              <1> 					; OPTIMIZATION:
  1457                              <1> 					; prn_stat_reg = prn_data_reg + 1
  1458                              <1> int_17_status:
  1459 00003039 EC                  <1> 	in	al,dx			; read the status
  1460 0000303A 88C4                <1> 	mov	ah,al			; move status to AH
  1461 0000303C 80E4F8              <1> 	and	ah,prn_stat_bits	; discard reserved bits
  1462 0000303F EBC1                <1> 	jmp	int_17_exit
  1327                                  %include	"video.inc"		; INT 10
  1328                              <1> ;=========================================================================
  1329                              <1> ; video.inc - BIOS video services
  1330                              <1> ;       INT 10h, functions AH=00h to AH=0Fh
  1331                              <1> ;-------------------------------------------------------------------------
  1332                              <1> ;
  1333                              <1> ; Compiles with NASM 2.13.02, might work with other versions
  1334                              <1> ;
  1335                              <1> ; This code is adopted from XT-clone BIOS by Anonymous
  1336                              <1> ;
  1337                              <1> ; This program is free software: you can redistribute it and/or modify
  1338                              <1> ; it under the terms of the GNU General Public License as published by
  1339                              <1> ; the Free Software Foundation, either version 3 of the License, or
  1340                              <1> ; (at your option) any later version.
  1341                              <1> ;
  1342                              <1> ; This program is distributed in the hope that it will be useful,
  1343                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  1344                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  1345                              <1> ; GNU General Public License for more details.
  1346                              <1> ;
  1347                              <1> ; You should have received a copy of the GNU General Public License
  1348                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  1349                              <1> ;
  1350                              <1> ;=========================================================================
  1351                              <1> 
  1352                              <1> ;-------------------------------------------------------------------------
  1353                              <1> ; CRTC registers
  1354                              <1> crtc_cur_start	equ	0Ah		; CRTC cursor start line register
  1355                              <1> crtc_cur_end	equ	0Bh		; CRTC cursor end line register
  1356                              <1> crtc_offset_hi	equ	0Ch		; CRTC start address high register
  1357                              <1> crtc_offset_lo	equ	0Dh		; CRTC start address low register
  1358                              <1> crtc_cur_pos_hi	equ	0Eh		; CRCT cursor location high register
  1359                              <1> crtc_cur_pos_lo	equ	0Fh		; CRTC cursor location low register
  1360                              <1> crtc_pen_hi	equ	10h		; CRTC light pen position high byte
  1361                              <1> crtc_pen_lo	equ	11h		; CRTC light pen position low byte
  1362                              <1> 
  1363                              <1> ;-------------------------------------------------------------------------
  1364                              <1> ; control characters
  1365                              <1> bel	equ	07h
  1366                              <1> bs	equ	08h
  1367                              <1> lf	equ	0Ah
  1368                              <1> cr	equ	0Dh
  1369                              <1> 
  1370 00003041 FF<rep 4h>          <1> 	setloc	0F045h			; int 10 functions table
  1370          ******************  <1>  warning: Inserting 4 bytes [-w+user]
  1371                              <1> 
  1372                              <1> int_10_dispatch:
  1373 00003045 [0431]              <1> 	dw	int_10_fn00		; Set video mode
  1374 00003047 [B431]              <1> 	dw	int_10_fn01		; Set text mode cursor shape
  1375 00003049 [BE31]              <1> 	dw	int_10_fn02		; Set cursor position
  1376 0000304B [E131]              <1> 	dw	int_10_fn03		; Get cursor position and shape
  1377 0000304D [F531]              <1> 	dw	int_10_fn04		; Read light pen position
  1378 0000304F [8832]              <1> 	dw	int_10_fn05		; Set active display page
  1379 00003051 [B332]              <1> 	dw	int_10_fn06		; Scroll up window
  1380 00003053 [B332]              <1> 	dw	int_10_fn07		; Scroll down window
  1381 00003055 [3934]              <1> 	dw	int_10_fn08		; Read character and attribute
  1382 00003057 [3934]              <1> 	dw	int_10_fn09		; Write character and attribute
  1383 00003059 [3934]              <1> 	dw	int_10_fn0A		; Write character only
  1384 0000305B [1436]              <1> 	dw	int_10_fn0B		; Set background color or palette
  1385 0000305D [3E36]              <1> 	dw	int_10_fn0C		; Write graphics pixel
  1386 0000305F [7636]              <1> 	dw	int_10_fn0D		; Read graphics pixel
  1387 00003061 [9436]              <1> 	dw	int_10_fn0E		; Teletype output
  1388 00003063 [0937]              <1> 	dw	int_10_fn0F		; Get current video mode
  1389                              <1> int_10_num_func	equ ($-int_10_dispatch)/2
  1390                              <1> 
  1391                              <1> 
  1392                              <1> ;-------------------------------------------------------------------------
  1393                              <1> ; offsets for registers on stack
  1394                              <1> 
  1395                              <1> int_10_ax	equ	0
  1396                              <1> int_10_al	equ	int_10_ax
  1397                              <1> int_10_ah	equ	int_10_ax+1
  1398                              <1> int_10_bx	equ	int_10_ax+2
  1399                              <1> int_10_bl	equ	int_10_bx
  1400                              <1> int_10_bh	equ	int_10_bx+1
  1401                              <1> int_10_cx	equ	int_10_bx+2
  1402                              <1> int_10_ch	equ	int_10_cx+1
  1403                              <1> int_10_dx	equ	int_10_cx+2
  1404                              <1> 
  1405                              <1> ;=========================================================================
  1406                              <1> ; int_10 - BIOS video services
  1407                              <1> ; Input:
  1408                              <1> ;	AH - Function
  1409                              <1> ;		00h - Set video mode
  1410                              <1> ;		01h - Set text mode cursor shape
  1411                              <1> ;		02h - Set cursor position
  1412                              <1> ;		03h - Get cursor position and shape
  1413                              <1> ;		04h - Read light pen position
  1414                              <1> ;		05h - Select active display page
  1415                              <1> ;		06h - Scroll up window
  1416                              <1> ;		07h - Scroll down window
  1417                              <1> ;		08h - Read character and attribute at cursor position
  1418                              <1> ;		09h - Write character and attribute at cursor position
  1419                              <1> ;		0Ah - Write character only at cursor position
  1420                              <1> ;		0Bh -
  1421                              <1> ;			BH = 00h - Set background/border color
  1422                              <1> ;			BH = 01h - Set palette
  1423                              <1> ;		0Ch - Write graphics pixel
  1424                              <1> ;		0Dh - Read graphics pixel
  1425                              <1> ;		0Eh - Teletype output
  1426                              <1> ;		0Fh - Get current video mode
  1427                              <1> ;-------------------------------------------------------------------------
  1428                              <1> 	setloc	0F065h			; int 10 Entry Point
  1429                              <1> int_10:
  1430 00003065 FB                  <1> 	sti
  1431 00003066 FC                  <1> 	cld				;  ...strings auto-increment
  1432 00003067 55                  <1> 	push	bp
  1433 00003068 06                  <1> 	push	es
  1434 00003069 1E                  <1> 	push	ds
  1435 0000306A 56                  <1> 	push	si
  1436 0000306B 57                  <1> 	push	di
  1437 0000306C 52                  <1> 	push	dx
  1438 0000306D 51                  <1> 	push	cx
  1439 0000306E 53                  <1> 	push	bx
  1440 0000306F 50                  <1> 	push	ax
  1441 00003070 BB4000              <1> 	mov	bx,biosdseg
  1442 00003073 8EDB                <1> 	mov	ds,bx
  1443 00003075 8A1E4900            <1> 	mov	bl,byte [video_mode]
  1444 00003079 80FB07              <1> 	cmp	bl,07h			; check for monochrome mode
  1445 0000307C BB00B8              <1> 	mov	bx,0B800h		; assume CGA, BX = CGA video segment
  1446 0000307F 7202                <1> 	jb	.color			; it is CGA
  1447 00003081 B7B0                <1> 	mov	bh,0B0h			; else MDA, BX = MDA video segment
  1448                              <1> 
  1449                              <1> .color:
  1450 00003083 8EC3                <1> 	mov	es,bx			; load video segment to ES
  1451 00003085 89E5                <1> 	mov	bp,sp			;  ...start of stack frame
  1452 00003087 80FC10              <1> 	cmp	ah,int_10_num_func	; dispatch table size
  1453 0000308A 730B                <1> 	jae	.exit			; invalid function
  1454 0000308C B700                <1> 	mov	bh,0
  1455 0000308E 88E3                <1> 	mov	bl,ah
  1456 00003090 D1E3                <1> 	shl	bx,1
  1457 00003092 2EFF97[4530]        <1>     cs	call	near [int_10_dispatch+bx]
  1458                              <1> 
  1459                              <1> .exit:
  1460 00003097 58                  <1> 	pop	ax
  1461 00003098 5B                  <1> 	pop	bx
  1462 00003099 59                  <1> 	pop	cx
  1463 0000309A 5A                  <1> 	pop	dx
  1464 0000309B 5F                  <1> 	pop	di
  1465 0000309C 5E                  <1> 	pop	si
  1466 0000309D 1F                  <1> 	pop	ds
  1467 0000309E 07                  <1> 	pop	es
  1468 0000309F 5D                  <1> 	pop	bp
  1469 000030A0 CF                  <1> 	iret
  1470                              <1> 
  1471                              <1> 
  1472                              <1> ;=========================================================================
  1473                              <1> ; int_1D - Video parameters tables
  1474                              <1> ; Contains values loaded to MC6845 CRTC registers 00h to 0Fh during
  1475                              <1> ; video mode initialization
  1476                              <1> ;-------------------------------------------------------------------------
  1477 000030A1 FF<rep 3h>          <1> 	setloc	0F0A4h			; int 1D (MDA and CGA Video Parm Table)
  1477          ******************  <1>  warning: Inserting 3 bytes [-w+user]
  1478                              <1> int_1D:
  1479                              <1> 	; CGA test 40x25 modes
  1480 000030A4 38282D0A1F06191C    <1> 	db	38h, 28h, 2Dh, 0Ah, 1Fh, 06h, 19h, 1Ch
  1481 000030AC 0207060700000000    <1> 	db	02h, 07h, 06h, 07h, 00h, 00h, 00h, 00h
  1482                              <1> 
  1483                              <1> 	; CGA text 80x25 modes
  1484 000030B4 71505A0A1F06191C    <1> 	db	71h, 50h, 5Ah, 0Ah, 1Fh, 06h, 19h, 1Ch
  1485 000030BC 0207060700000000    <1> 	db	02h, 07h, 06h, 07h, 00h, 00h, 00h, 00h
  1486                              <1> 
  1487                              <1> 	; CGA graphics modes
  1488 000030C4 38282D0A7F066470    <1> 	db	38h, 28h, 2Dh, 0Ah, 7Fh, 06h, 64h, 70h
  1489 000030CC 0201060700000000    <1> 	db	02h, 01h, 06h, 07h, 00h, 00h, 00h, 00h
  1490                              <1> 
  1491                              <1> 	; MDA text 80x25 mode
  1492 000030D4 6150520F19061919    <1> 	db	61h, 50h, 52h, 0Fh, 19h, 06h, 19h, 19h
  1493 000030DC 020D0B0C00000000    <1> 	db	02h, 0Dh, 0Bh, 0Ch, 00h, 00h, 00h, 00h
  1494                              <1> 
  1495                              <1> page_size:
  1496 000030E4 0008                <1> 	dw	0800h			; text 40x25 mode
  1497 000030E6 0010                <1> 	dw	1000h			; text 80x25 mode
  1498 000030E8 0040                <1> 	dw	4000h			; graphics modes
  1499 000030EA 0040                <1> 	dw	4000h
  1500                              <1> 
  1501                              <1> columns:
  1502 000030EC 2828                <1> 	db	40, 40			; modes 0, 1 - 40x25
  1503 000030EE 5050                <1> 	db	80, 80			; modes 2, 3 - 80x25
  1504 000030F0 2828                <1> 	db	40, 40			; modes 4, 5 - 40x25
  1505 000030F2 5050                <1> 	db	80, 80			; modes 6, 7 - 80x25
  1506                              <1> 
  1507 000030F4 2C282D292A2E1E29    <1> MODES	db	2Ch,28h,2Dh,29h,2Ah,2Eh,1Eh,29h ; Table of mode sets
  1508                              <1> 
  1509 000030FC 0000101020202030    <1> TABMUL	db	00h,00h,10h,10h,20h,20h,20h,30h ; Table lookup for multiply
  1510                              <1> 
  1511                              <1> ;=========================================================================
  1512                              <1> ; int_10_fn00 - Set video mode
  1513                              <1> ; Input:
  1514                              <1> ;	AH = 00h
  1515                              <1> ;	AL = video mode
  1516                              <1> ;		00h - CGA - text 40x25, 16 shades of gray
  1517                              <1> ;		01h - CGA - text 40x25, 16 colors
  1518                              <1> ;		02h - CGA - text 80x25, 16 shades of gray
  1519                              <1> ;		03h - CGA - text 80x25, 16 colors
  1520                              <1> ;		04h - CGA - graphics 320x200, 4 colors
  1521                              <1> ;		05h - CGA - graphics 320x200, 4 shades of gray
  1522                              <1> ;		06h - CGA - graphics 640x200, monochrome
  1523                              <1> ;		07h - MDA - text 80x25, monochrome
  1524                              <1> ;-------------------------------------------------------------------------
  1525                              <1> int_10_fn00:
  1526 00003104 8A5E00              <1> 	mov	bl,byte [bp+int_10_al]	; BL = video mode
  1527                              <1> 					; assume CGA mode
  1528 00003107 B900B8              <1> 	mov	cx,0B800h		; CGA video memory segment
  1529 0000310A BAD403              <1> 	mov	dx,3D4h			; port for MC6845 CRTC address register
  1530 0000310D A01000              <1> 	mov	al,byte [equipment_list] ; get equipment - low byte
  1531 00003110 2430                <1> 	and	al,equip_video		; get video adapter type
  1532 00003112 3C30                <1> 	cmp	al,equip_mono		; monochrome?
  1533 00003114 B000                <1> 	mov	al,0
  1534 00003116 7507                <1> 	jne	.color			; jump if CGA/color mode
  1535                              <1> 					; set MDA mode
  1536 00003118 B307                <1> 	mov	bl,07h			; MDA can only be 7
  1537 0000311A B5B0                <1> 	mov	ch,0B0h			; MDA video memory segment
  1538 0000311C B2B4                <1> 	mov	dl,0B4h 		; port for MC6845 CRTC address register
  1539 0000311E 40                  <1> 	inc	ax
  1540                              <1> 
  1541                              <1> .color:
  1542 0000311F 8EC1                <1> 	mov	es,cx			; ES = video memory segment
  1543 00003121 89166300            <1> 	mov	word [video_port],dx	; Save current CRTC display port
  1544 00003125 80C204              <1> 	add	dl,4
  1545 00003128 EE                  <1> 	out	dx,al			; Reset the video
  1546 00003129 881E4900            <1> 	mov	byte [video_mode],bl	; Save current CRTC mode
  1547 0000312D B700                <1> 	mov	bh,0
  1548 0000312F 53                  <1> 	push	bx
  1549 00003130 06                  <1> 	push	es
  1550 00003131 31C0                <1> 	xor	ax,ax
  1551 00003133 8EC0                <1> 	mov	es,ax			; Load interrupt table segment to ES
  1552 00003135 26C4367400          <1>     es	les	si,[1Dh*4]		; Load video parameters table
  1553                              <1> 					; (INT 1Dh vector) to ES:SI
  1554 0000313A 2E8A9F[FC30]        <1>     cs	mov	bl,byte [bx+TABMUL]	; Get BL for indexing into int_1D
  1555 0000313F 01DE                <1> 	add	si,bx
  1556                              <1> 
  1557 00003141 268B4C0A            <1>     es	mov	cx,word [si+crtc_cur_start] ; cursor shape from INT 1Dh table
  1558 00003145 86CD                <1> 	xchg	cl,ch			; convert to LSB format
  1559 00003147 890E6000            <1> 	mov	word [video_cur_shape],cx ; store cursor shape
  1560                              <1> 
  1561 0000314B B91000              <1> 	mov	cx,10h			; Sixteen values to send
  1562                              <1> 
  1563                              <1> .setup_crt_loop:
  1564 0000314E 268A04              <1>     es	mov	al,byte [si]		; Value to send in SI
  1565 00003151 E8E305              <1> 	call	vid_crtc_writeb			;  ...send it
  1566 00003154 FEC4                <1> 	inc	ah			;  ...bump count
  1567 00003156 46                  <1> 	inc	si			;  ...point to next
  1568 00003157 E2F5                <1> 	loop	.setup_crt_loop		;  ...loop until done
  1569 00003159 07                  <1> 	pop	es
  1570 0000315A 31FF                <1> 	xor	di,di
  1571 0000315C B90020              <1> 	mov	cx,2000h		; video memory size for CGA
  1572 0000315F 31C0                <1> 	xor	ax,ax			; fill word for graphics mode
  1573 00003161 E8B805              <1> 	call	vid_check_mode		; Set flags according to mode
  1574 00003164 7208                <1> 	jc	.clear_screen		; jump if graphics mode
  1575 00003166 7503                <1> 	jnz	.text_fill		; jump if CGA mode
  1576 00003168 B90008              <1> 	mov	cx,0800h 		; video memory size for MDA
  1577                              <1> 
  1578                              <1> .text_fill:
  1579 0000316B B82007              <1> 	mov	ax,07h << 8 | ' '	; fill word for test mode
  1580                              <1> 
  1581                              <1> .clear_screen:
  1582 0000316E F3AB                <1> 	repz	stosw			; clear screen with fill word
  1583                              <1> 
  1584 00003170 8B166300            <1> 	mov	dx,word [video_port]	; Get the port
  1585 00003174 80C204              <1> 	add	dl,4
  1586 00003177 5B                  <1> 	pop	bx
  1587 00003178 2E8A87[F430]        <1>     cs	mov	al,byte [bx+MODES]	; Load data to set for mode
  1588 0000317D EE                  <1> 	out	dx,al			;  ...and send it
  1589 0000317E A26500              <1> 	mov	byte [video_mode_reg],al ;  ...then save active data
  1590 00003181 42                  <1> 	inc	dx
  1591 00003182 B030                <1> 	mov	al,30h			; Assume not 640 x 200 b/w
  1592 00003184 80FB06              <1> 	cmp	bl,6			;  ...correct?
  1593 00003187 7502                <1> 	jnz	.set_palette
  1594 00003189 B03F                <1> 	mov	al,3Fh			; Palette for 640 x 200 b/w
  1595                              <1> 
  1596                              <1> .set_palette:
  1597 0000318B A26600              <1> 	mov	byte [video_palet_reg],al ;  ...save palette
  1598 0000318E EE                  <1> 	out	dx,al			;  ...send palette
  1599                              <1> 
  1600 0000318F 8CD8                <1> 	mov	ax,ds
  1601 00003191 8EC0                <1> 	mov	es,ax
  1602 00003193 31C0                <1> 	xor	ax,ax
  1603 00003195 A26200              <1> 	mov	byte [video_page],al	;  ...active page=page 0
  1604 00003198 B90900              <1> 	mov	cx,9			; video_page_offt + video_cur_pos * 8
  1605 0000319B BF4E00              <1> 	mov	di,video_page_offt
  1606 0000319E F3AB                <1>  	rep	stosw			; zero page offset and cursor position
  1607                              <1> 
  1608 000031A0 2E8A87[EC30]        <1>     cs	mov	al,byte [bx+columns]	; Get display width
  1609 000031A5 A34A00              <1> 	mov	word [video_columns],ax	;  ...save it
  1610 000031A8 80E3FE              <1> 	and	bl,0FEh			; Clear the LSB to get an index
  1611                              <1> 					; to 16-bit word page_size table
  1612                              <1> 					; FIXME: It returns graphics mode page
  1613                              <1> 					; size for mode 7. Probably not
  1614                              <1> 					; critical, as MDA has only one page
  1615 000031AB 2E8B87[E430]        <1>     cs	mov	ax,word [bx+page_size]	; Get video page size
  1616 000031B0 A34C00              <1> 	mov	word [video_page_size],ax ;  ...save it
  1617 000031B3 C3                  <1> 	ret
  1618                              <1> 
  1619                              <1> ;=========================================================================
  1620                              <1> ; int_10_fn01 - Set text-mode cursor shape
  1621                              <1> ; Input:
  1622                              <1> ;	AH = 01h
  1623                              <1> ;	CH = cursor scan line start
  1624                              <1> ;	CL = cursor scan line end
  1625                              <1> ; Output:
  1626                              <1> ;	none
  1627                              <1> ;-------------------------------------------------------------------------
  1628                              <1> int_10_fn01:
  1629 000031B4 890E6000            <1> 	mov	word [video_cur_shape],cx ; save cursor shape to BIOS data area
  1630 000031B8 B40A                <1> 	mov	ah,crtc_cur_start	; select CRTC cursor shape registers
  1631 000031BA E87105              <1> 	call	vid_crtc_writew		; write it to CRTC
  1632 000031BD C3                  <1> 	ret
  1633                              <1> 
  1634                              <1> ;=========================================================================
  1635                              <1> ; int_10_fn02 - Set cursor position
  1636                              <1> ; Input:
  1637                              <1> ;	AH = 02h
  1638                              <1> ;	BH = page number
  1639                              <1> ;	DH = cursor row (00h is top)
  1640                              <1> ;	DL = cursor column (00h is left)
  1641                              <1> ; Output:
  1642                              <1> ;	none
  1643                              <1> ;-------------------------------------------------------------------------
  1644                              <1> int_10_fn02:
  1645 000031BE 8A5E03              <1> 	mov	bl,byte [bp+int_10_bh]	; BL = page number
  1646 000031C1 381E6200            <1> 	cmp	byte [video_page],bl	; is it on current page?
  1647 000031C5 7512                <1> 	jne	bios_set_cur_pos	; if not visible only update BIOS data
  1648                              <1> 
  1649                              <1> ;=========================================================================
  1650                              <1> ; set_cur_pos - set CRTC cursor position, update BIOS cursor location
  1651                              <1> ;	BL = page
  1652                              <1> ;	DH = cursor row (00h is top)
  1653                              <1> ;	DL = cursor column (00h is left)
  1654                              <1> ;-------------------------------------------------------------------------
  1655                              <1> set_cur_pos:
  1656 000031C7 89D0                <1> 	mov	ax,dx			; AX = cursor position
  1657 000031C9 E8AA05              <1> 	call	vid_position_to_offset			; AX - offset
  1658 000031CC 03064E00            <1> 	add	ax,word [video_page_offt]	;  + byte offset, regen reg.
  1659 000031D0 D1E8                <1> 	shr	ax,1
  1660 000031D2 89C1                <1> 	mov	cx,ax
  1661 000031D4 B40E                <1> 	mov	ah,crtc_cur_pos_hi	; CRCT cursor location high register
  1662 000031D6 E85505              <1> 	call	vid_crtc_writew		; send cursor position to CRTC
  1663                              <1> bios_set_cur_pos:
  1664 000031D9 B700                <1> 	mov	bh,0
  1665 000031DB D0E3                <1> 	shl	bl,1			; index to words table
  1666 000031DD 895750              <1> 	mov	word [bx+video_cur_pos],dx ; save position to BIOS data area
  1667 000031E0 C3                  <1> 	ret
  1668                              <1> 
  1669                              <1> ;=========================================================================
  1670                              <1> ; int_10_fn03 - Get cursor position and shape
  1671                              <1> ; Input:
  1672                              <1> ;	AH = 03h
  1673                              <1> ;	BH = page number
  1674                              <1> ; Output:
  1675                              <1> ;	CH = cursor start scan line
  1676                              <1> ;	CL = cursor end scan line
  1677                              <1> ;	DH = cursor row (00h is top)
  1678                              <1> ;	DL = cursor column (00h is left)
  1679                              <1> ;-------------------------------------------------------------------------
  1680                              <1> int_10_fn03:
  1681 000031E1 B700                <1> 	mov	bh,0
  1682 000031E3 8A5E03              <1> 	mov	bl,byte [bp+int_10_bh]	; BL = page number
  1683 000031E6 D0E3                <1> 	shl	bl,1
  1684 000031E8 8B4750              <1> 	mov	ax,word [bx+video_cur_pos] ; get current cursor position
  1685 000031EB 894606              <1> 	mov	word [bp+int_10_dx],ax	; return position in DX
  1686 000031EE A16000              <1> 	mov	ax,word [video_cur_shape]  ; get cursor shape
  1687 000031F1 894604              <1> 	mov	word [bp+int_10_cx],ax	; return cursor shape in CX
  1688 000031F4 C3                  <1> 	ret
  1689                              <1> 
  1690                              <1> ;=========================================================================
  1691                              <1> ; int_10_fn04 - Read light pen position
  1692                              <1> ; Input:
  1693                              <1> ;	AH = 04h
  1694                              <1> ; Output:
  1695                              <1> ;	AH - light pen trigger flag
  1696                              <1> ;		00h not down/triggered
  1697                              <1> ;		01h down/triggered
  1698                              <1> ;	If light pen is triggered:
  1699                              <1> ;		DH = character row
  1700                              <1> ;		DL = character column
  1701                              <1> ;		CH = pixel row
  1702                              <1> ;		BX = pixel column
  1703                              <1> ;-------------------------------------------------------------------------
  1704                              <1> int_10_fn04:
  1705 000031F5 C6460100            <1> 	mov	byte [bp+int_10_ah],0	; set AH = 0, light pen not triggered
  1706 000031F9 8B166300            <1> 	mov	dx,word [video_port]
  1707 000031FD 80C206              <1> 	add	dl,6			; CRTC status register
  1708 00003200 EC                  <1> 	in	al,dx			; read it
  1709 00003201 A804                <1> 	test	al,4			; test light pen switch bit
  1710 00003203 7472                <1> 	jz	.reset_pen		; reset pen and return if switch is off
  1711 00003205 A802                <1> 	test	al,2			; test light pen tigger bit
  1712 00003207 7501                <1> 	jnz	.read_pen		; continue if triggered
  1713 00003209 C3                  <1> 	ret				; not triggered - return
  1714                              <1> 
  1715                              <1> .read_pen:
  1716 0000320A 8B166300            <1> 	mov	dx,word [video_port]	; CRTC index register
  1717 0000320E B010                <1> 	mov	al,crtc_pen_hi		; CRTC pen position high byte register
  1718 00003210 EE                  <1> 	out	dx,al			; select it
  1719 00003211 42                  <1> 	inc	dx			; CRTC data register
  1720 00003212 EC                  <1> 	in	al,dx			; read high byte of pen position
  1721 00003213 88C4                <1> 	mov	ah,al
  1722 00003215 4A                  <1> 	dec	dx			; CRTC index register
  1723 00003216 B011                <1> 	mov	al,crtc_pen_lo		; CRTC pen position low byte register
  1724 00003218 EE                  <1> 	out	dx,al			; select it
  1725 00003219 42                  <1> 	inc	dx			; CRTC data register
  1726 0000321A EC                  <1> 	in	al,dx			; read low byte of pen position
  1727                              <1> 
  1728 0000321B B700                <1> 	mov	bh,0
  1729 0000321D 8A1E4900            <1> 	mov	bl,byte [video_mode]	; get current video mode
  1730 00003221 2E8A9F[8032]        <1>     cs	mov	bl,byte [bx+.correction] ; light pen correction factor
  1731 00003226 29D8                <1> 	sub	ax,bx
  1732 00003228 7902                <1> 	jns	.1
  1733 0000322A 31C0                <1> 	xor	ax,ax			; set to zero if negative result
  1734                              <1> 
  1735                              <1> .1:
  1736 0000322C E8ED04              <1> 	call	vid_check_mode			; check video mode
  1737 0000322F 7325                <1> 	jnc	.text			; calculate character position if text
  1738 00003231 B228                <1> 	mov	dl,40			; divide by 40
  1739 00003233 F6F2                <1> 	div	dl			; AL = row, AH = column (reminder)
  1740 00003235 B700                <1> 	mov	bh,0
  1741 00003237 88E3                <1> 	mov	bl,ah
  1742 00003239 B103                <1> 	mov	cl,3
  1743 0000323B D3E3                <1> 	shl	bx,cl			; BX = AH * 8 - pixel column
  1744 0000323D 88C5                <1> 	mov	ch,al
  1745 0000323F D0E5                <1> 	shl	ch,1			; CH = AL * 2 - pixel row
  1746 00003241 88E2                <1> 	mov	dl,ah			; DL = AH - character column
  1747 00003243 88C6                <1> 	mov	dh,al
  1748 00003245 D0EE                <1> 	shr	dh,1
  1749 00003247 D0EE                <1> 	shr	dh,1			; DH = AL / 4 - character row
  1750 00003249 803E490006          <1> 	cmp	byte [video_mode],6	; check for 640x200 mode
  1751 0000324E 751A                <1> 	jnz	.exit
  1752 00003250 D1E3                <1> 	shl	bx,1			; adjust pixel column (double it)
  1753 00003252 D0E2                <1> 	shl	dl,1			; same or character column
  1754 00003254 EB14                <1> 	jmp	.exit
  1755                              <1> 
  1756                              <1> .text:
  1757 00003256 F6364A00            <1> 	div	byte [video_columns] 	; divide by number of columns
  1758 0000325A 86C4                <1> 	xchg	al,ah			; AL = column, AH = row
  1759 0000325C 89C2                <1> 	mov	dx,ax			; save characer row,column to DH,AL
  1760 0000325E B103                <1> 	mov	cl,3
  1761 00003260 D2E4                <1> 	shl	ah,cl
  1762 00003262 88E5                <1> 	mov	ch,ah			; CH = AH * 8 - pixel row
  1763 00003264 B700                <1> 	mov	bh,0
  1764 00003266 88C3                <1> 	mov	bl,al
  1765 00003268 D3E3                <1> 	shl	bx,cl			; BX = AL * 8 - pixel column
  1766                              <1> 
  1767                              <1> .exit:
  1768 0000326A C6460101            <1> 	mov	byte [bp+int_10_ah],1	; set AH = 1, light pen triggered
  1769 0000326E 895606              <1> 	mov	word [bp+int_10_dx],dx	;  ...row, column in user dx
  1770 00003271 895E02              <1> 	mov	word [bp+int_10_bx],bx	;  ...pixel column in user bx
  1771 00003274 886E05              <1> 	mov	byte [bp+int_10_ch],ch	;  ...raster line in user ch
  1772                              <1> 
  1773                              <1> .reset_pen:
  1774 00003277 8B166300            <1> 	mov	dx,word [video_port]	; Get port of active CRTC card
  1775 0000327B 80C207              <1> 	add	dl,7			; clear light pen strobe reg
  1776 0000327E EE                  <1> 	out	dx,al			; reset it
  1777 0000327F C3                  <1> 	ret
  1778                              <1> 
  1779                              <1> .correction:
  1780 00003280 0303050503030304    <1> 	db	3, 3, 5, 5, 3, 3, 3, 4	; light pen correction
  1781                              <1> 
  1782                              <1> ;=========================================================================
  1783                              <1> ; int_10_fn05 - Select active display page
  1784                              <1> ; Input:
  1785                              <1> ;	AH = 05h
  1786                              <1> ;	AL - new page number (00h is the first page)
  1787                              <1> ; Output:
  1788                              <1> ;	none
  1789                              <1> ;-------------------------------------------------------------------------
  1790                              <1> int_10_fn05:
  1791 00003288 A26200              <1> 	mov	byte [video_page],al	; update page number in BIOS data area
  1792 0000328B 88C3                <1> 	mov	bl,al			; also copy it to BL
  1793 0000328D B400                <1> 	mov	ah,0
  1794 0000328F F7264C00            <1> 	mul	word [video_page_size]	; calculate page offset
  1795 00003293 A34E00              <1> 	mov	word [video_page_offt],ax ; save the offset
  1796 00003296 D1E8                <1> 	shr	ax,1			; calculate CRTC page start address
  1797 00003298 89C1                <1> 	mov	cx,ax			; save a copy to CX
  1798 0000329A B40C                <1> 	mov	ah,crtc_offset_hi	; CRTC start address high register
  1799 0000329C E88F04              <1> 	call	vid_crtc_writew		; write new offset to CRTC
  1800                              <1> 
  1801 0000329F B700                <1> 	mov	bh,0
  1802 000032A1 D1E3                <1> 	shl	bx,1
  1803 000032A3 8B4750              <1> 	mov	ax,word [bx+video_cur_pos] ; AX - cursor position for new page
  1804 000032A6 E8CD04              <1> 	call	vid_position_to_offset			; AX - offset relative to start of page
  1805 000032A9 D1E8                <1> 	shr	ax,1
  1806 000032AB 01C1                <1> 	add	cx,ax			; add to the page offset
  1807 000032AD B40E                <1> 	mov	ah,crtc_cur_pos_hi	; CRCT cursor location high register
  1808 000032AF E87C04              <1> 	call	vid_crtc_writew		; send cursor position to CRTC
  1809 000032B2 C3                  <1> 	ret
  1810                              <1> 
  1811                              <1> ;=========================================================================
  1812                              <1> ; int_10_fn06 - scroll up window
  1813                              <1> ; int_10_fn07 - scroll down window
  1814                              <1> ; Input:
  1815                              <1> ;	AH = 06h (scroll up) or AH = 07 (scroll down)
  1816                              <1> ;	AL = number of rows by which to scroll up (00h = clear entire window)
  1817                              <1> ;	BH = attribute used to write blank rows at bottom of window
  1818                              <1> ;	CH,CL = row,column of window's upper left corner
  1819                              <1> ;	DH,DL = row,column of window's lower right corner
  1820                              <1> ; Output:
  1821                              <1> ;	none
  1822                              <1> ; TODO:
  1823                              <1> ;	optimize graphics fill
  1824                              <1> ;-------------------------------------------------------------------------
  1825                              <1> int_10_fn06:
  1826                              <1> int_10_fn07:
  1827 000032B3 E86604              <1> 	call	vid_check_mode
  1828 000032B6 7303E9D900          <1> 	jc	.graphics_scroll
  1829                              <1> 
  1830 000032BB 31F6                <1> 	xor	si,si			; SI - "snow" workaround not required
  1831 000032BD 803E490002          <1> 	cmp	byte [video_mode],2
  1832 000032C2 720A                <1> 	jb	.no_snow
  1833 000032C4 803E490003          <1> 	cmp	byte [video_mode],3
  1834 000032C9 7703                <1> 	ja	.no_snow
  1835 000032CB BE5555              <1> 	mov	si,0101010101010101b	; CGA "snow" workaround required
  1836                              <1> ;	mov	si,0001000100010001b	; CGA "snow" workaround required
  1837                              <1> .no_snow:
  1838 000032CE 8B4606              <1> 	mov	ax,word [bp+int_10_dx]	; AX = window's lower right corner
  1839 000032D1 50                  <1> 	push	ax
  1840 000032D2 807E0107            <1> 	cmp	byte [bp+int_10_ah],07h	; check for scroll down function
  1841 000032D6 7403                <1> 	jz	.1			; jump if scroll down
  1842 000032D8 8B4604              <1> 	mov	ax,word [bp+int_10_cx]	; AX = window's upper left corner
  1843                              <1> 
  1844                              <1> .1:
  1845 000032DB E89804              <1> 	call	vid_position_to_offset
  1846 000032DE 03064E00            <1> 	add	ax,word [video_page_offt]
  1847 000032E2 89C7                <1> 	mov	di,ax			; DI = scroll copy destination address
  1848                              <1> 
  1849                              <1> ; calculate scroll window size (DX)
  1850                              <1> 
  1851 000032E4 5A                  <1> 	pop	dx			; DX = window's lower right corner
  1852 000032E5 2B5604              <1> 	sub	dx,word [bp+int_10_cx]	; substract windows's upper left corner
  1853 000032E8 81C20101            <1> 	add	dx,101h 		; add 1x1
  1854                              <1> 
  1855                              <1> ; calculate offset between the source and the destination (AX)
  1856                              <1> 
  1857 000032EC 8B1E4A00            <1> 	mov	bx,word [video_columns]	; BX = columns (note BX <= 80)
  1858 000032F0 D1E3                <1> 	shl	bx,1			; each character takes two bytes
  1859 000032F2 8A4600              <1> 	mov	al,byte [bp+int_10_al]	; AL = number of rows to scroll
  1860 000032F5 52                  <1> 	push    dx
  1861 000032F6 B400                <1>         mov     ah,0
  1862 000032F8 F7E3                <1>         mul     bx
  1863 000032FA 5A                  <1>         pop     dx
  1864                              <1> 
  1865 000032FB 28D3                <1> 	sub	bl,dl			; BX = distance between end of one
  1866 000032FD 28D3                <1> 	sub	bl,dl			;   row and beggining of another
  1867 000032FF 1E                  <1> 	push	ds
  1868 00003300 8CC1                <1> 	mov	cx,es
  1869 00003302 8ED9                <1> 	mov	ds,cx			; load video segment to DS
  1870 00003304 807E0106            <1> 	cmp	byte [bp+int_10_ah],06h	; check for scroll up function
  1871 00003308 7405                <1> 	jz	.2			; jump if scroll up
  1872 0000330A F7D8                <1> 	neg	ax			; negate offset
  1873 0000330C F7DB                <1> 	neg	bx			; negate distance
  1874 0000330E FD                  <1> 	std				; copy backwards
  1875                              <1> 
  1876                              <1> .2:
  1877 0000330F 8A4E00              <1> 	mov	cl,byte [bp+int_10_al]	; CL = number of rows to scroll
  1878 00003312 08C9                <1> 	or	cl,cl
  1879 00003314 7423                <1> 	jz	.text_fill_only		; jump if clear window only requested
  1880 00003316 96                  <1> 	xchg	ax,si			; AX = snow workaround flag, SI = offset
  1881 00003317 01FE                <1> 	add	si,di			; SI = scroll copy source address
  1882 00003319 28CE                <1> 	sub	dh,cl			; DH = number of rows to copy
  1883                              <1> 
  1884 0000331B 09DB                <1> 	or	bx,bx
  1885 0000331D 7434                <1> 	jz	.text_full_row_scroll
  1886                              <1> 
  1887                              <1> .text_scroll_loop:
  1888 0000331F B500                <1> 	mov	ch,0
  1889 00003321 88D1                <1> 	mov	cl,dl			; CX = characters in row to copy
  1890                              <1> 
  1891 00003323 D1C8                <1> 	ror	ax,1			; rotate snow workaround flag
  1892 00003325 7303                <1> 	jnc	.text_scroll_no_retrace
  1893 00003327 E85800              <1> 	call	.retrace_wait
  1894                              <1> 
  1895                              <1> .text_scroll_no_retrace:
  1896 0000332A F3A5                <1> 	repz	movsw			; copy one row
  1897                              <1> 
  1898                              <1> ;.text_scroll_next_row:
  1899 0000332C 01DE                <1> 	add	si,bx			; SI = next row to copy source address
  1900 0000332E 01DF                <1> 	add	di,bx			; DI = next row to copy destination
  1901 00003330 FECE                <1> 	dec	dh			; decrement row counter
  1902 00003332 75EB                <1> 	jnz	.text_scroll_loop	; jump if there is more rows to copy
  1903                              <1> 
  1904                              <1> .text_fill:
  1905 00003334 8A7600              <1> 	mov	dh,byte [bp+int_10_al]	; DH = number of rows to fill
  1906 00003337 89C6                <1> 	mov	si,ax			; SI = snow workaround flag
  1907                              <1> 
  1908                              <1> .text_fill_only:
  1909 00003339 B500                <1> 	mov	ch,0
  1910 0000333B 8A6603              <1> 	mov	ah,byte [bp+int_10_bh]	; AH = blank attribute
  1911 0000333E B020                <1> 	mov	al,' '			; AL = blank character
  1912                              <1> 
  1913                              <1> .text_fill_loop:
  1914 00003340 88D1                <1> 	mov	cl,dl			; CX = characters in row to fill
  1915 00003342 D1CE                <1> 	ror	si,1			; rotate snow workaround flag
  1916 00003344 7303                <1> 	jnc	.text_fill_no_retrace	; jump if LSB was zero - no wait
  1917 00003346 E83900              <1> 	call	.retrace_wait		; wait for vertical retrace
  1918                              <1> 
  1919                              <1> .text_fill_no_retrace:
  1920 00003349 F3AB                <1> 	repz	stosw			; fill one row
  1921 0000334B 01DF                <1> 	add	di,bx			; DI = next row to fill destination
  1922 0000334D FECE                <1> 	dec	dh			; decrement row counter
  1923 0000334F 75EF                <1> 	jnz	.text_fill_loop		; jump if there is more rows to fill
  1924                              <1> 
  1925 00003351 1F                  <1> 	pop	ds
  1926 00003352 C3                  <1> 	ret
  1927                              <1> 
  1928                              <1> .text_full_row_scroll:
  1929 00003353 09C0                <1> 	or	ax,ax
  1930 00003355 741F                <1> 	jz	.text_full_row_no_snow
  1931 00003357 50                  <1> 	push	ax
  1932 00003358 88D0                <1> 	mov	al,dl
  1933 0000335A F6E6                <1> 	mul	dh
  1934                              <1> 
  1935                              <1> .text_full_row_loop:
  1936 0000335C B9F000              <1> 	mov	cx,240
  1937 0000335F 39C8                <1> 	cmp	ax,cx
  1938 00003361 7705                <1> 	ja	.copy_chunk
  1939 00003363 91                  <1> 	xchg	ax,cx
  1940 00003364 31C0                <1> 	xor	ax,ax
  1941 00003366 EB02                <1> 	jmp	.do_copy
  1942                              <1> 
  1943                              <1> .copy_chunk:
  1944 00003368 29C8                <1> 	sub	ax,cx
  1945                              <1> 
  1946                              <1> .do_copy:
  1947 0000336A E81500              <1> 	call	.retrace_wait
  1948 0000336D F3A5                <1> 	rep	movsw
  1949 0000336F 09C0                <1> 	or	ax,ax
  1950 00003371 75E9                <1> 	jnz	.text_full_row_loop
  1951 00003373 58                  <1> 	pop	ax
  1952 00003374 EBBE                <1> 	jmp	.text_fill
  1953                              <1> 
  1954                              <1> .text_full_row_no_snow:
  1955 00003376 50                  <1> 	push	ax
  1956 00003377 88D0                <1> 	mov	al,dl
  1957 00003379 F6E6                <1> 	mul	dh
  1958 0000337B 89C1                <1> 	mov	cx,ax
  1959 0000337D F3A5                <1> 	rep	movsw
  1960 0000337F 58                  <1> 	pop	ax
  1961 00003380 EBB2                <1> 	jmp	.text_fill
  1962                              <1> 
  1963                              <1> ;-------------------------------------------------------------------------
  1964                              <1> ; .retrace_wait - next till the next vertical retrace
  1965                              <1> 
  1966                              <1> .retrace_wait:
  1967 00003382 50                  <1> 	push	ax
  1968 00003383 52                  <1> 	push	dx
  1969 00003384 BADA03              <1> 	mov	dx,03DAh		; DX = CGA status register
  1970                              <1> 
  1971                              <1> .retrace_wait_not_set:
  1972 00003387 EC                  <1> 	in	al,dx
  1973 00003388 A808                <1> 	test	al,08h			; bit 3 set if vertical retrace
  1974 0000338A 75FB                <1> 	jnz	.retrace_wait_not_set	; jump if retrace
  1975                              <1> 
  1976                              <1> .retrace_wait_set:
  1977 0000338C EC                  <1> 	in	al,dx
  1978 0000338D A808                <1> 	test	al,08h			; bit 3 set if vertical retrace
  1979 0000338F 74FB                <1> 	jz	.retrace_wait_set	; jump if no retrace
  1980 00003391 5A                  <1> 	pop	dx
  1981 00003392 58                  <1> 	pop	ax
  1982                              <1> 
  1983                              <1> .retrace_exit:
  1984 00003393 C3                  <1> 	ret
  1985                              <1> 
  1986                              <1> ;-------------------------------------------------------------------------
  1987                              <1> ; .graphics_scroll - scroll for graphics modes
  1988                              <1> 
  1989                              <1> .graphics_scroll:
  1990 00003394 8B4606              <1> 	mov	ax,word [bp+int_10_dx]	; AX = window's lower right corner
  1991 00003397 50                  <1> 	push	ax
  1992 00003398 807E0107            <1> 	cmp	byte [bp+int_10_ah],07h ; check for scroll down function
  1993 0000339C 7403                <1> 	jz	.3			; jump if scroll down
  1994 0000339E 8B4604              <1> 	mov	ax,word [bp+int_10_cx]	; AX = window's upper left corner
  1995                              <1> 
  1996                              <1> .3:
  1997 000033A1 E8E303              <1> 	call	vid_gfx_pos_to_offset	
  1998 000033A4 89C7                <1> 	mov	di,ax			; DI = scroll copy destination address
  1999                              <1> 
  2000                              <1> ; calculate scroll windows size (DX)
  2001                              <1> 
  2002 000033A6 5A                  <1> 	pop	dx			; DX = window's lower right corner
  2003 000033A7 2B5604              <1> 	sub	dx,word [bp+int_10_cx]	; substract window's upper left corner
  2004 000033AA 81C20101            <1> 	add	dx,101h 		; add 1x1
  2005 000033AE D0E6                <1> 	shl	dh,1			; multiply by four: one character takes
  2006 000033B0 D0E6                <1> 	shl	dh,1			;   four bytes in each plane
  2007 000033B2 8A4601              <1> 	mov	al,byte [bp+int_10_ah]	; AL = function
  2008 000033B5 803E490006          <1> 	cmp	byte [video_mode],06h	; check for 640x200 mode
  2009 000033BA 7409                <1> 	jz	.4			; jump if 640x200 mode
  2010 000033BC D0E2                <1> 	shl	dl,1			; double character width for 320x200 
  2011 000033BE D1E7                <1> 	shl	di,1			; double character width for 320x200
  2012 000033C0 3C07                <1> 	cmp	al,07h			; check for scroll down function
  2013 000033C2 7509                <1> 	jnz	.5			; jump if scroll down
  2014 000033C4 47                  <1> 	inc	di			; scroll up - adjust source address
  2015                              <1> 
  2016                              <1> .4:
  2017 000033C5 3C07                <1> 	cmp	al,07h			; check for scroll down function
  2018 000033C7 7504                <1> 	jnz	.5			; jump if not scroll down
  2019 000033C9 81C7F000            <1> 	add	di,0F0h			; adjust destination address
  2020                              <1> 					;   for copying backwards
  2021                              <1> 
  2022                              <1> .5:
  2023 000033CD 8A5E00              <1> 	mov	bl,byte [bp+int_10_al]	; BL = number of rows to scroll
  2024 000033D0 D0E3                <1> 	shl	bl,1			; multiply by four: one character takes
  2025 000033D2 D0E3                <1> 	shl	bl,1			;   four bytes in each plane
  2026 000033D4 53                  <1> 	push	bx
  2027 000033D5 28DE                <1> 	sub	dh,bl			; DH = number of rows to copy
  2028 000033D7 B050                <1> 	mov	al,50h
  2029 000033D9 F6E3                <1> 	mul	bl
  2030 000033DB BBB01F              <1> 	mov	bx,1FB0h
  2031 000033DE 807E0106            <1> 	cmp	byte [bp+int_10_ah],06h	; check for scroll up function
  2032 000033E2 7406                <1> 	jz	.6			; jump if scroll up
  2033 000033E4 F7D8                <1> 	neg	ax			; negate offset for scroll down
  2034 000033E6 BB5020              <1> 	mov	bx,2050h
  2035 000033E9 FD                  <1> 	std				; copy backwards
  2036                              <1> 
  2037                              <1> .6:
  2038 000033EA 89FE                <1> 	mov	si,di
  2039 000033EC 01C6                <1> 	add	si,ax			; SI = scroll copy source address
  2040 000033EE 58                  <1> 	pop	ax
  2041 000033EF 8CC1                <1> 	mov	cx,es
  2042 000033F1 8ED9                <1> 	mov	ds,cx			; load video segment to DS
  2043 000033F3 08C0                <1> 	or	al,al
  2044 000033F5 7426                <1> 	jz	.graphics_fill		; jump if clear window only requested
  2045 000033F7 50                  <1> 	push	ax
  2046                              <1> 
  2047                              <1> .graphics_scroll_loop:
  2048 000033F8 B500                <1> 	mov	ch,0
  2049 000033FA 88D1                <1> 	mov	cl,dl			; CX = bytes in row to copy
  2050 000033FC 56                  <1> 	push	si
  2051 000033FD 57                  <1> 	push	di
  2052 000033FE F3A4                <1> 	repz	movsb			; copy one row in the first plane
  2053 00003400 5F                  <1> 	pop	di
  2054 00003401 5E                  <1> 	pop	si
  2055 00003402 81C60020            <1> 	add	si,2000h		; point SI and DI to the second plane
  2056 00003406 81C70020            <1> 	add	di,2000h
  2057 0000340A 88D1                <1> 	mov	cl,dl			; CX = bytes in row to copy
  2058 0000340C 56                  <1> 	push	si
  2059 0000340D 57                  <1> 	push	di
  2060 0000340E F3A4                <1> 	repz	movsb			; copy one row in the second plane
  2061 00003410 5F                  <1> 	pop	di
  2062 00003411 5E                  <1> 	pop	si
  2063 00003412 29DE                <1> 	sub	si,bx			; SI = next row to copy source address
  2064 00003414 29DF                <1> 	sub	di,bx			; DI = next row to copy destination
  2065 00003416 FECE                <1> 	dec	dh			; decrement row counter
  2066 00003418 75DE                <1> 	jnz	.graphics_scroll_loop	; jump if there is more rows to copy
  2067                              <1> 
  2068 0000341A 58                  <1> 	pop	ax
  2069 0000341B 88C6                <1> 	mov	dh,al			; DH = number of rows to fill
  2070                              <1> 
  2071                              <1> .graphics_fill:
  2072 0000341D 8A4603              <1> 	mov	al,byte [bp+int_10_bh]	; AL = fill color
  2073 00003420 B500                <1> 	mov	ch,0
  2074                              <1> 
  2075                              <1> .graphics_fill_loop:
  2076 00003422 88D1                <1> 	mov	cl,dl			; CX = bytes in row to fill
  2077 00003424 57                  <1> 	push	di
  2078 00003425 F3AA                <1> 	repz	stosb			; fill one row in the first plane
  2079 00003427 5F                  <1> 	pop	di
  2080 00003428 81C70020            <1> 	add	di,2000h		; point DI to the second plane
  2081 0000342C 88D1                <1> 	mov	cl,dl			; CX = bytes in row to fill
  2082 0000342E 57                  <1> 	push	di
  2083 0000342F F3AA                <1> 	repz	stosb			; fill one row in the second plane
  2084 00003431 5F                  <1> 	pop	di
  2085 00003432 29DF                <1> 	sub	di,bx
  2086 00003434 FECE                <1> 	dec	dh			; decrement row counter
  2087 00003436 75EA                <1> 	jnz	.graphics_fill_loop	; jumpif there is more rows to fill
  2088 00003438 C3                  <1> 	ret
  2089                              <1> 
  2090                              <1> ;=========================================================================
  2091                              <1> ; int_10_fn08 - Read character and attribute
  2092                              <1> ; Input:
  2093                              <1> ;	AH = 08h
  2094                              <1> ; Output:
  2095                              <1> ;	AL - character read
  2096                              <1> ;	BH - video attribute (text modes only)
  2097                              <1> ; int_10_fn09 - Write character and attribute
  2098                              <1> ; Input:
  2099                              <1> ;	AH = 09h
  2100                              <1> ;	AL - character to write
  2101                              <1> ;	BH - page number
  2102                              <1> ;	BL - attribute (text modes) or color (graphics modes)
  2103                              <1> ;	CX - number of times to write character
  2104                              <1> ; Output:
  2105                              <1> ;	none
  2106                              <1> ; int_10_fn0A - Write character only
  2107                              <1> ; Input:
  2108                              <1> ;	AH = 0Ah
  2109                              <1> ;	AL - character to write
  2110                              <1> ;	BH - page number
  2111                              <1> ;	CX - repeat count
  2112                              <1> ; Output:
  2113                              <1> ;	none
  2114                              <1> ;-------------------------------------------------------------------------
  2115                              <1> int_10_fn08:
  2116                              <1> int_10_fn09:
  2117                              <1> int_10_fn0A:
  2118 00003439 E8E002              <1> 	call	vid_check_mode
  2119 0000343C 7277                <1> 	jc	.graphics		; jump if graphics mode
  2120 0000343E 8A5E03              <1> 	mov	bl,byte [bp+int_10_bh]	; BL = page number
  2121 00003441 B700                <1> 	mov	bh,0
  2122 00003443 53                  <1> 	push	bx
  2123 00003444 E82803              <1> 	call	vid_current_offset
  2124 00003447 89C7                <1> 	mov	di,ax			; DI = character offset in the page
  2125 00003449 58                  <1> 	pop	ax			; AX = page number
  2126 0000344A F7264C00            <1> 	mul	word [video_page_size] 	; AX = page number * page size
  2127 0000344E 01C7                <1> 	add	di,ax			; DI = character offset
  2128 00003450 89FE                <1> 	mov	si,di			; SI = character offset
  2129 00003452 8B166300            <1> 	mov	dx,word [video_port]	; DX = CRTC port
  2130 00003456 83C206              <1> 	add	dx,6			; DX = CGA status register
  2131 00003459 1E                  <1> 	push	ds
  2132 0000345A 8CC3                <1> 	mov	bx,es
  2133 0000345C 8EDB                <1> 	mov	ds,bx			; load video segment to DS
  2134 0000345E 8A4601              <1> 	mov	al,byte [bp+int_10_ah]	; AL = function
  2135 00003461 3C08                <1> 	cmp	al,08h			; check for read character function
  2136 00003463 7512                <1> 	jnz	.text_write		; jump if not read char (write char)
  2137                              <1> 
  2138                              <1> .read_retrace_wait:
  2139 00003465 EC                  <1> 	in	al,dx
  2140 00003466 A801                <1> 	test	al,01h			; bit 0 set if horizontal retrace
  2141 00003468 75FB                <1> 	jnz	.read_retrace_wait	; jump if retrace
  2142 0000346A FA                  <1> 	cli
  2143                              <1> 
  2144                              <1> .read_no_retrace_wait:
  2145 0000346B EC                  <1> 	in	al,dx
  2146 0000346C A801                <1> 	test	al,01h			; bit 0 set if horizontal retrace
  2147 0000346E 74FB                <1> 	jz	.read_no_retrace_wait	; jump if no retrace
  2148                              <1> 
  2149 00003470 AD                  <1> 	lodsw				; read character and attribute
  2150 00003471 FB                  <1> 	sti
  2151 00003472 1F                  <1> 	pop	ds
  2152 00003473 894600              <1> 	mov	word [bp+int_10_ax],ax	; return character and attribute in AX
  2153 00003476 C3                  <1> 	ret
  2154                              <1> 
  2155                              <1> .text_write:
  2156 00003477 8A5E00              <1> 	mov	bl,byte [bp+int_10_al]	; BL = character to write
  2157 0000347A 8A7E02              <1> 	mov	bh,byte [bp+int_10_bl]	; BH = attribute to write
  2158 0000347D 8B4E04              <1> 	mov	cx,word [bp+int_10_cx]  ; CX = number of times to write char
  2159 00003480 3C0A                <1> 	cmp	al,0Ah			; check for write char only function
  2160 00003482 7418                <1> 	jz	.text_write_char_only	; jump if write char only
  2161                              <1> 
  2162                              <1> .write_char_retrace:
  2163 00003484 EC                  <1> 	in	al,dx
  2164 00003485 A808                <1> 	test	al,08h			; bit 3 set if vertical retrace
  2165 00003487 750B                <1> 	jnz	.do_write_char_attr	; retrace is in progress - write char
  2166                              <1> 
  2167                              <1> .write_retrace_wait1:
  2168 00003489 EC                  <1> 	in	al,dx
  2169 0000348A A801                <1> 	test	al,01h			; bit 0 set if horizontal retrace
  2170 0000348C 75FB                <1> 	jnz	.write_retrace_wait1	; jump if retrace
  2171 0000348E FA                  <1> 	cli
  2172                              <1> 
  2173                              <1> .write_no_retrace_wait1:
  2174 0000348F EC                  <1> 	in	al,dx
  2175 00003490 A801                <1> 	test	al,01h			; bit 0 set if horizontal retrace
  2176 00003492 74FB                <1> 	jz	.write_no_retrace_wait1	; jump if no retrace
  2177                              <1> 
  2178                              <1> .do_write_char_attr:
  2179 00003494 89D8                <1> 	mov	ax,bx			; AX = character / attribute
  2180 00003496 AB                  <1> 	stosw				; write it to video memory
  2181 00003497 FB                  <1> 	sti
  2182 00003498 E2EA                <1> 	loop	.write_char_retrace	; repeat CX times
  2183 0000349A 1F                  <1> 	pop	ds
  2184 0000349B C3                  <1> 	ret
  2185                              <1> 
  2186                              <1> .text_write_char_only:
  2187 0000349C EC                  <1> 	in	al,dx
  2188 0000349D A808                <1> 	test	al,08h			; bit 3 set if vertical retrace
  2189 0000349F 750B                <1> 	jnz	.do_write_char_only	; retrace is in progress - write char
  2190                              <1> 
  2191                              <1> .write_retrace_wait2:
  2192 000034A1 EC                  <1> 	in	al,dx
  2193 000034A2 A801                <1> 	test	al,01h			; bit 0 set if horizontal retrace
  2194 000034A4 75FB                <1> 	jnz	.write_retrace_wait2	; jump if retrace
  2195 000034A6 FA                  <1> 	cli
  2196                              <1> 
  2197                              <1> .write_no_retrace_wait2:
  2198 000034A7 EC                  <1> 	in	al,dx
  2199 000034A8 A801                <1> 	test	al,01h			; bit 0 set if horizontal retrace
  2200 000034AA 74FB                <1> 	jz	.write_no_retrace_wait2	; jump if no retrace
  2201                              <1> 
  2202                              <1> .do_write_char_only:
  2203 000034AC 88D8                <1> 	mov	al,bl			; AL = character to write
  2204 000034AE AA                  <1> 	stosb				; write it to video memory
  2205 000034AF FB                  <1> 	sti
  2206 000034B0 47                  <1> 	inc	di			; skip attribute
  2207 000034B1 E2E9                <1> 	loop	.text_write_char_only	; repeat CX times
  2208 000034B3 1F                  <1> 	pop	ds
  2209 000034B4 C3                  <1> 	ret
  2210                              <1> 
  2211                              <1> .graphics:
  2212 000034B5 807E0108            <1> 	cmp	byte [bp+int_10_ah],08h	; check for read character function
  2213 000034B9 7503E9B300          <1> 	jz	.graphics_read
  2214                              <1> 
  2215 000034BE A15000              <1> 	mov	ax,word [video_cur_pos]	; Get cursor position
  2216 000034C1 E8C302              <1> 	call	vid_gfx_pos_to_offset	;  ...convert (row,col) -> col
  2217 000034C4 89C7                <1> 	mov	di,ax			; Save in displacement register
  2218 000034C6 1E                  <1> 	push	ds
  2219 000034C7 8A4600              <1> 	mov	al,byte [bp+int_10_al]	; Get character to write
  2220 000034CA B400                <1> 	mov	ah,0
  2221 000034CC 08C0                <1> 	or	al,al			; Is it user character set?
  2222 000034CE 7807                <1> 	js	.CG9_02			;  ...skip if so
  2223 000034D0 8CCA                <1> 	mov	dx,cs			; Else use ROM character set
  2224 000034D2 BE[6E3A]            <1> 	mov	si,gfx_font		; load graphics font offset
  2225 000034D5 EB0C                <1> 	jmp	.CG9_03
  2226                              <1> 
  2227                              <1> .CG9_02:
  2228 000034D7 247F                <1> 	and	al,7Fh			; Origin to zero
  2229 000034D9 31DB                <1> 	xor	bx,bx			;  ...then go load
  2230 000034DB 8EDB                <1> 	mov	ds,bx			;  ...user graphics
  2231 000034DD C5367C00            <1> 	lds	si,[7Ch]		;  ...vector, offset in si
  2232 000034E1 8CDA                <1> 	mov	dx,ds			;  ...segment into dx
  2233                              <1> 
  2234                              <1> .CG9_03:
  2235 000034E3 1F                  <1> 	pop	ds			; Restore data segment
  2236 000034E4 B103                <1> 	mov	cl,3			;  ...char 8 pixels wide
  2237 000034E6 D3E0                <1> 	shl	ax,cl
  2238 000034E8 01C6                <1> 	add	si,ax			; Add regen. buffer base addr.
  2239 000034EA 8B4E04              <1> 	mov	cx,word [bp+int_10_cx]	;  ...load char. count
  2240 000034ED 803E490006          <1> 	cmp	byte [video_mode],6	; Is the mode 640 x 200 b/w?
  2241 000034F2 1E                  <1> 	push	ds
  2242 000034F3 8EDA                <1> 	mov	ds,dx
  2243 000034F5 7451                <1> 	jz	.CG8_02			;  ...skip if so
  2244 000034F7 D1E7                <1> 	shl	di,1
  2245 000034F9 8A4602              <1> 	mov	al,byte [bp+int_10_bl]	; Get character attribute
  2246 000034FC 83E003              <1> 	and	ax,3
  2247 000034FF BB5555              <1> 	mov	bx,5555h
  2248 00003502 F7E3                <1> 	mul	bx
  2249 00003504 89C2                <1> 	mov	dx,ax
  2250 00003506 8A5E02              <1> 	mov	bl,byte [bp+int_10_bl]	; Restore BL (character attribute)
  2251                              <1> 
  2252                              <1> .CG9_04:
  2253 00003509 B708                <1> 	mov	bh,8			; Char 8 pixels wide
  2254 0000350B 57                  <1> 	push	di
  2255 0000350C 56                  <1> 	push	si
  2256                              <1> 
  2257                              <1> .CG9_05:
  2258 0000350D AC                  <1> 	lodsb				; Read the screen
  2259 0000350E 51                  <1> 	push	cx
  2260 0000350F 53                  <1> 	push	bx
  2261 00003510 31DB                <1> 	xor	bx,bx
  2262 00003512 B90800              <1> 	mov	cx,8
  2263                              <1> 
  2264                              <1> .CG9_06:
  2265 00003515 D0E8                <1> 	shr	al,1			; Shift bits thru byte
  2266 00003517 D1DB                <1> 	rcr	bx,1
  2267 00003519 D1FB                <1> 	sar	bx,1
  2268 0000351B E2F8                <1> 	loop	.CG9_06
  2269                              <1> 
  2270 0000351D 89D8                <1> 	mov	ax,bx			; Result into ax
  2271 0000351F 5B                  <1> 	pop	bx
  2272 00003520 59                  <1> 	pop	cx
  2273 00003521 21D0                <1> 	and	ax,dx
  2274 00003523 86E0                <1> 	xchg	ah,al
  2275 00003525 08DB                <1> 	or	bl,bl
  2276 00003527 7903                <1> 	jns	.CG9_07
  2277 00003529 263305              <1>     es	xor	ax,word [di]
  2278                              <1> 
  2279                              <1> .CG9_07:
  2280 0000352C 268905              <1>     es	mov	word [di],ax		; Write new word
  2281 0000352F 81F70020            <1> 	xor	di,2000h
  2282 00003533 F7C70020            <1> 	test	di,2000h		; Is this other plane?
  2283 00003537 7503                <1> 	jnz	.CG9_08			;  ...nope
  2284 00003539 83C750              <1> 	add	di,50h			; Else advance character
  2285                              <1> 
  2286                              <1> .CG9_08:
  2287 0000353C FECF                <1> 	dec	bh			; Show another char written
  2288 0000353E 75CD                <1> 	jnz	.CG9_05			;  ...more to go
  2289 00003540 5E                  <1> 	pop	si
  2290 00003541 5F                  <1> 	pop	di
  2291 00003542 47                  <1> 	inc	di
  2292 00003543 47                  <1> 	inc	di
  2293 00003544 E2C3                <1> 	loop	.CG9_04
  2294 00003546 1F                  <1> 	pop	ds
  2295 00003547 C3                  <1> 	ret
  2296                              <1> 
  2297                              <1> .CG8_02:
  2298 00003548 8A5E02              <1> 	mov	bl,byte [bp+int_10_bl]	; Get display page
  2299 0000354B BA0020              <1> 	mov	dx,2000h		;  ...size of graphics plane
  2300                              <1> 
  2301                              <1> .CG8_03:
  2302 0000354E B708                <1> 	mov	bh,8			; Pixel count to write
  2303 00003550 57                  <1> 	push	di
  2304 00003551 56                  <1> 	push	si
  2305                              <1> 
  2306                              <1> .CG8_04:
  2307 00003552 AC                  <1> 	lodsb				; Read from one plane
  2308 00003553 08DB                <1> 	or	bl,bl			;  ...done both planes?
  2309 00003555 7903                <1> 	jns	.CG8_05			;  ...skip if not
  2310 00003557 263205              <1>     es	xor	al,byte [di]		; Else load attribute
  2311                              <1> 
  2312                              <1> .CG8_05:
  2313 0000355A 268805              <1>     es	mov	byte [di],al		; Write out attribute
  2314 0000355D 31D7                <1> 	xor	di,dx			;  ...get other plane
  2315 0000355F 85D7                <1> 	test	di,dx			; Done both planes?
  2316 00003561 7503                <1> 	jnz	.CG8_06			;  ...skip if not
  2317 00003563 83C750              <1> 	add	di,50h			; Else position for now char
  2318                              <1> 
  2319                              <1> .CG8_06:
  2320 00003566 FECF                <1> 	dec	bh			; Show row of pixels read
  2321 00003568 75E8                <1> 	jnz	.CG8_04			;  ...not done all of them
  2322 0000356A 5E                  <1> 	pop	si
  2323 0000356B 5F                  <1> 	pop	di
  2324 0000356C 47                  <1> 	inc	di
  2325 0000356D E2DF                <1> 	loop	.CG8_03
  2326 0000356F 1F                  <1> 	pop	ds
  2327 00003570 C3                  <1> 	ret
  2328                              <1> 
  2329                              <1> .graphics_read:
  2330 00003571 FC                  <1> 	cld				; Increment upwards
  2331 00003572 A15000              <1> 	mov	ax,word [video_cur_pos]	;  ...get cursor position
  2332 00003575 E80F02              <1> 	call	vid_gfx_pos_to_offset	; Convert (row,col) -> columns
  2333 00003578 89C6                <1> 	mov	si,ax			;  ...save in si
  2334 0000357A 83EC08              <1> 	sub	sp,8			; Grab 8 bytes temp storage
  2335 0000357D 89E7                <1> 	mov	di,sp			;  ...save base in di
  2336 0000357F 803E490006          <1> 	cmp	byte [video_mode],6	; Mode 640 x 200 b/w?
  2337 00003584 8CC0                <1> 	mov	ax,es
  2338 00003586 1E                  <1> 	push	ds
  2339 00003587 57                  <1> 	push	di
  2340 00003588 8ED8                <1> 	mov	ds,ax			; load video segment to DS
  2341 0000358A 7431                <1> 	jz	CGR_06			; Mode is 640 x 200 b/w - skip
  2342 0000358C B608                <1> 	mov	dh,8			; Eight pixels high/char
  2343 0000358E D1E6                <1> 	shl	si,1
  2344 00003590 BB0020              <1> 	mov	bx,2000h		; Bytes per video plane
  2345                              <1> 
  2346                              <1> CGR_02:
  2347 00003593 8B04                <1> 	mov	ax,word [si] 		; Read existing word
  2348 00003595 86E0                <1> 	xchg	ah,al
  2349 00003597 B900C0              <1> 	mov	cx,0C000h		; Attributes to scan for
  2350 0000359A B200                <1> 	mov	dl,0
  2351                              <1> 
  2352                              <1> CGR_03:
  2353 0000359C 85C8                <1> 	test	ax,cx			; Look for attributes
  2354 0000359E F8                  <1> 	clc
  2355 0000359F 7401                <1> 	jz	CGR_04			;  ...set, skip
  2356 000035A1 F9                  <1> 	stc				; Else show not set
  2357                              <1> 
  2358                              <1> CGR_04:
  2359 000035A2 D0D2                <1> 	rcl	dl,1
  2360 000035A4 D1E9                <1> 	shr	cx,1
  2361 000035A6 D1E9                <1> 	shr	cx,1
  2362 000035A8 73F2                <1> 	jnb	CGR_03			;  ...more shifts to go
  2363 000035AA 368815              <1>     ss	mov	byte [di],dl
  2364 000035AD 47                  <1> 	inc	di
  2365 000035AE 31DE                <1> 	xor	si,bx			; Do other video plane
  2366 000035B0 85DE                <1> 	test	si,bx			;  ...done both planes?
  2367 000035B2 7503                <1> 	jnz	CGR_05			;  ...no, skip
  2368 000035B4 83C650              <1> 	add	si,50h			; Else advance pointer
  2369                              <1> 
  2370                              <1> CGR_05:
  2371 000035B7 FECE                <1> 	dec	dh			; Show another pixel row done
  2372 000035B9 75D8                <1> 	jnz	CGR_02			;  ...more rows to do
  2373 000035BB EB17                <1> 	jmp	short	CGR_08
  2374                              <1> 
  2375                              <1> CGR_06:
  2376 000035BD B604                <1> 	mov	dh,4			; Mode 640 x 200 b/w - special
  2377                              <1> 
  2378                              <1> CGR_07:
  2379 000035BF 8A24                <1> 	mov	ah,byte [si] 		; Read pixels from one plane
  2380 000035C1 368825              <1>     ss	mov	byte [di],ah		;  ...save on stack
  2381 000035C4 47                  <1> 	inc	di			;  ...advance
  2382 000035C5 8AA40020            <1> 	mov	ah,byte [si+2000h]	; Read pixels from other plane
  2383 000035C9 368825              <1>     ss	mov	byte [di],ah		; Save pixels on stack
  2384 000035CC 47                  <1> 	inc	di			;  ...advance
  2385 000035CD 83C650              <1> 	add	si,50h			; Total pixels in char
  2386 000035D0 FECE                <1> 	dec	dh			;  ...another row processed
  2387 000035D2 75EB                <1> 	jnz	CGR_07			;  ...more to do
  2388                              <1> 
  2389                              <1> CGR_08:
  2390 000035D4 8CCA                <1> 	mov	dx,cs			; Load segment of graphics font 
  2391 000035D6 BF[6E3A]            <1> 	mov	di,gfx_font		;  ...and offset
  2392 000035D9 8EC2                <1> 	mov	es,dx			;  ...save offset in es
  2393 000035DB 8CD2                <1> 	mov	dx,ss
  2394 000035DD 8EDA                <1> 	mov	ds,dx
  2395 000035DF 5E                  <1> 	pop	si
  2396 000035E0 B000                <1> 	mov	al,0
  2397                              <1> 
  2398                              <1> CGR_09:
  2399 000035E2 BA8000              <1> 	mov	dx,80h			; Number of char. in graphics set
  2400                              <1> 
  2401                              <1> CGR_10:
  2402 000035E5 56                  <1> 	push	si
  2403 000035E6 57                  <1> 	push	di
  2404 000035E7 B90800              <1> 	mov	cx,8			; Bytes to compare for char
  2405 000035EA F3A6                <1> 	repz	cmpsb			;  ...do compare
  2406 000035EC 5F                  <1> 	pop	di
  2407 000035ED 5E                  <1> 	pop	si
  2408 000035EE 741C                <1> 	jz	CGR_11			; Found graphics character
  2409 000035F0 FEC0                <1> 	inc	al			;  ...else show another char
  2410 000035F2 83C708              <1> 	add	di,8			;  ...advance one row
  2411 000035F5 4A                  <1> 	dec	dx			;  ...one less char  to scan
  2412 000035F6 75ED                <1> 	jnz	CGR_10			; Loop if more char left
  2413                              <1> 
  2414 000035F8 08C0                <1> 	or	al,al			; User graphics character set?
  2415 000035FA 7410                <1> 	jz	CGR_11			;  ...no, not found
  2416 000035FC 31DB                <1> 	xor	bx,bx			; 
  2417 000035FE 8EDB                <1> 	mov	ds,bx			; Load interrupt table segment to ES
  2418 00003600 C43E7C00            <1> 	les	di,[1Fh*4]		; Load user font for graphics 
  2419                              <1> 					; (INT 1Fh vector) to ES:SI
  2420 00003604 8CC3                <1> 	mov	bx,es
  2421 00003606 09FB                <1> 	or	bx,di
  2422 00003608 7402                <1> 	jz	CGR_11			;  ...not found
  2423 0000360A EBD6                <1> 	jmp	short	CGR_09		; Try using user graphics char
  2424                              <1> 
  2425                              <1> CGR_11:
  2426 0000360C 884600              <1> 	mov	byte [bp+int_10_al],al	; Return char in user al
  2427 0000360F 1F                  <1> 	pop	ds
  2428 00003610 83C408              <1> 	add	sp,8			;  ...return temp storage
  2429 00003613 C3                  <1> 	ret
  2430                              <1> 
  2431                              <1> ;=========================================================================
  2432                              <1> ; int_10_fn0B - Set background color or palette
  2433                              <1> ; Input:
  2434                              <1> ; 	AH - 0Bh
  2435                              <1> ;	BH = 00h - set background / border color
  2436                              <1> ;		BL - background (graphics modes) or border (text modes)
  2437                              <1> ;	BH = 01h - set palette (320x200 graphics mode)
  2438                              <1> ;		BL - palette ID:
  2439                              <1> ;			00h - background, green, red, and yellow (brown)
  2440                              <1> ;			01h - background, cyan, magenta, and white
  2441                              <1> ; Output:
  2442                              <1> ;	none
  2443                              <1> ;-------------------------------------------------------------------------
  2444                              <1> int_10_fn0B:
  2445 00003614 A06600              <1> 	mov	al,byte [video_palet_reg] ; AL = current palette register
  2446 00003617 8A6602              <1> 	mov	ah,byte [bp+int_10_bl]	; AH = color / palette ID
  2447 0000361A 807E0300            <1> 	cmp	byte [bp+int_10_bh],00h	; check function
  2448 0000361E 7509                <1> 	jnz	.set_palette		; jump to set palette if BH != 0
  2449                              <1> 
  2450 00003620 24E0                <1> 	and	al,0E0h			; clear color bits - bits 0-5
  2451 00003622 80E41F              <1> 	and	ah,1Fh			; clear non-color bits in input
  2452 00003625 08E0                <1> 	or	al,ah			; apply new color
  2453 00003627 EB09                <1> 	jmp	.write_palet_reg
  2454                              <1> 
  2455                              <1> .set_palette:
  2456 00003629 24DF                <1> 	and	al,0DFh			; clear palette bit - bit 6
  2457 0000362B F6C401              <1> 	test	ah,01h
  2458 0000362E 7402                <1> 	jz	.write_palet_reg
  2459 00003630 0C20                <1> 	or	al,20h			; set palette bit for BL = 01h
  2460                              <1> 
  2461                              <1> .write_palet_reg:
  2462 00003632 A26600              <1> 	mov	byte [video_palet_reg],al ; save new palette reg in BIOS data
  2463 00003635 8B166300            <1> 	mov	dx,word [video_port]
  2464 00003639 83C205              <1> 	add	dx,5			; CRTC color select register
  2465 0000363C EE                  <1> 	out	dx,al			; send it to CRTC
  2466 0000363D C3                  <1> 	ret
  2467                              <1> 
  2468                              <1> ;=========================================================================
  2469                              <1> ; int_10_fn0C - Write graphics pixel
  2470                              <1> ; Input:
  2471                              <1> ;	AH = 0Ch
  2472                              <1> ;	AL = pixel color, if bit 7 set, pixel is XOR'ed onto screen
  2473                              <1> ;	CX = column
  2474                              <1> ;	DX = row
  2475                              <1> ; Output:
  2476                              <1> ;	none
  2477                              <1> ;-------------------------------------------------------------------------
  2478                              <1> int_10_fn0C:
  2479 0000363E E80501              <1> 	call	vid_pixel_address	; calculate pixel address	
  2480 00003641 750D                <1> 	jnz	.mode_320x200		; jump if 320x200 mode
  2481 00003643 8A4600              <1> 	mov	al,byte [bp+int_10_al]	; AL - color
  2482 00003646 88C3                <1> 	mov	bl,al			; copy color to BL
  2483 00003648 2401                <1> 	and	al,1			; one bit per pixel
  2484 0000364A D0C8                <1> 	ror	al,1			; make color MSB instead of LSB
  2485 0000364C B47F                <1> 	mov	ah,7Fh			; AH = pixel mask
  2486 0000364E EB0F                <1> 	jmp	.prepare_mask
  2487                              <1> 
  2488                              <1> .mode_320x200:
  2489 00003650 D0E1                <1> 	shl	cl,1
  2490 00003652 8A4600              <1> 	mov	al,byte [bp+int_10_al]	; AL - color
  2491 00003655 88C3                <1> 	mov	bl,al			; copy color to BL
  2492 00003657 2403                <1> 	and	al,3			; two bit per pixel
  2493 00003659 D0C8                <1> 	ror	al,1			; make color MSB instead of LSB
  2494 0000365B D0C8                <1> 	ror	al,1
  2495 0000365D B43F                <1> 	mov	ah,3Fh			; AH = pixel mask
  2496                              <1> 
  2497                              <1> .prepare_mask:
  2498 0000365F D2CC                <1> 	ror	ah,cl			; position pixel mask correctly
  2499 00003661 D2E8                <1> 	shr	al,cl			; position color bits correctly
  2500 00003663 268A0C              <1>     es	mov	cl,byte [si]		; read the byte containing the pixel
  2501 00003666 08DB                <1> 	or	bl,bl			; check if bit 7 set
  2502 00003668 7904                <1> 	jns	.set_color		; bit 7 not set - new color
  2503 0000366A 30C1                <1> 	xor	cl,al			; else XOR with existing color
  2504 0000366C EB04                <1> 	jmp	.write_pixel
  2505                              <1> 
  2506                              <1> .set_color:
  2507 0000366E 20E1                <1> 	and	cl,ah			; clear existing color bits
  2508 00003670 08C1                <1> 	or	cl,al			; set new color bits
  2509                              <1> 
  2510                              <1> .write_pixel:
  2511 00003672 26880C              <1>     es	mov	[si],cl			; write the byte with the new pixel
  2512 00003675 C3                  <1> 	ret
  2513                              <1> 
  2514                              <1> ;=========================================================================
  2515                              <1> ; int_10_fn0D - Read graphics pixel
  2516                              <1> ; Input:
  2517                              <1> ;	AH = 0Dh
  2518                              <1> ;	CX = column
  2519                              <1> ;	DX = row
  2520                              <1> ; Output:
  2521                              <1> ;	AL = pixel color 
  2522                              <1> ;-------------------------------------------------------------------------
  2523                              <1> int_10_fn0D:
  2524 00003676 E8CD00              <1> 	call	vid_pixel_address	; calculate pixel address
  2525 00003679 268A04              <1>     es	mov	al,byte [si]		; read byte containing the pixel
  2526 0000367C 7508                <1> 	jnz	.mode_320x200		; jump if 320x200 mode
  2527 0000367E D2E0                <1> 	shl	al,cl			; shift pixel to bit 7
  2528 00003680 D0C0                <1> 	rol	al,1			; shift pixel from bit 7 to bit 0
  2529 00003682 2401                <1> 	and	al,1			; one bit per pixel
  2530 00003684 EB0A                <1> 	jmp	.exit
  2531                              <1> 
  2532                              <1> .mode_320x200:
  2533 00003686 D0E1                <1> 	shl	cl,1			; update position for two bits per pixel
  2534 00003688 D2E0                <1> 	shl	al,cl			; shift pixel to bits 7-6
  2535 0000368A D0C0                <1> 	rol	al,1			; shift pixel to bits 1-0
  2536 0000368C D0C0                <1> 	rol	al,1
  2537 0000368E 2403                <1> 	and	al,3			; two bits per pixel
  2538                              <1> 
  2539                              <1> .exit:
  2540 00003690 884600              <1> 	mov	byte [bp+int_10_al],al	; return pixel color in AL
  2541 00003693 C3                  <1> 	ret
  2542                              <1> 
  2543                              <1> ;=========================================================================
  2544                              <1> ; int_10_fn0E - Teletype output
  2545                              <1> ; Input:
  2546                              <1> ;	AH = 0Eh
  2547                              <1> ;	AL = character to write
  2548                              <1> ;	BL = foreground color (graphics modes only)
  2549                              <1> ; Output:
  2550                              <1> ;	none
  2551                              <1> ; Notes:
  2552                              <1> ;	- writes character to the active video page
  2553                              <1> ;	- support following control characters: BEL, BS, LF, CR
  2554                              <1> ;-------------------------------------------------------------------------
  2555                              <1> int_10_fn0E:
  2556 00003694 8A1E6200            <1> 	mov	bl,byte [video_page]	; BL = active video page
  2557 00003698 B700                <1> 	mov	bh,0
  2558 0000369A D0E3                <1> 	shl	bl,1			; word index
  2559 0000369C 8B5750              <1> 	mov	dx,word [bx+video_cur_pos] ; DX = cursor position
  2560                              <1> 
  2561 0000369F 8A4600              <1> 	mov	al,byte [bp+int_10_al]	; AL = character to write
  2562 000036A2 3C08                <1> 	cmp	al,bs
  2563 000036A4 7429                <1> 	jz	.bs			; jump if backspace (BS)
  2564 000036A6 3C0A                <1> 	cmp	al,lf
  2565 000036A8 741C                <1> 	jz	.lf			; jump if line feed (LF)
  2566 000036AA 3C07                <1> 	cmp	al,bel
  2567 000036AC 7433                <1> 	jz	.bel			; jump if beep (BEL)
  2568 000036AE 3C0D                <1> 	cmp	al,cr
  2569 000036B0 7426                <1> 	jz	.cr			; jump if carriage return (CR)
  2570 000036B2 8A5E02              <1> 	mov	bl,byte [bp+int_10_bl]	; BL = attribute for graphics mode
  2571 000036B5 B40A                <1> 	mov	ah,0Ah			; INT 10h, function 0Ah - write char
  2572 000036B7 B90100              <1> 	mov	cx,1			; one character
  2573 000036BA CD10                <1> 	int	10h			; write character
  2574 000036BC FEC2                <1> 	inc	dl			; move cursor to the next column
  2575 000036BE 3A164A00            <1> 	cmp	dl,byte [video_columns]	; compare position to number of columns
  2576 000036C2 7516                <1> 	jnz	.set_cursor_pos		; jump if not past the last column
  2577 000036C4 B200                <1> 	mov	dl,0			; move to the first position
  2578                              <1> 
  2579                              <1> .lf:
  2580 000036C6 80FE18              <1> 	cmp	dh,24			; on the last row?
  2581 000036C9 741C                <1> 	jz	.scroll			; jump if on the last row - scroll
  2582 000036CB FEC6                <1> 	inc	dh			; move cursor to the next row
  2583 000036CD 750B                <1> 	jnz	.set_cursor_pos		; set new cursor position
  2584                              <1> 
  2585                              <1> .bs:
  2586 000036CF 80FA00              <1> 	cmp	dl,0			; on the first column?
  2587 000036D2 7406                <1> 	jz	.set_cursor_pos		; jump if yes - nothing to do
  2588 000036D4 FECA                <1> 	dec	dl			; move cursor to the previous position
  2589 000036D6 EB02                <1> 	jmp	.set_cursor_pos		; set new cursor position
  2590                              <1> 
  2591                              <1> .cr:
  2592 000036D8 B200                <1> 	mov	dl,0			; set cursor to the first column
  2593                              <1> 
  2594                              <1> .set_cursor_pos:
  2595 000036DA 8A1E6200            <1> 	mov	bl,byte [video_page]	; BL = active video page
  2596 000036DE E9E6FA              <1> 	jmp	set_cur_pos		; set new cursor position
  2597                              <1> 
  2598                              <1> .bel:
  2599 000036E1 B302                <1> 	mov	bl,2			; 0.2 second beep
  2600 000036E3 E870DF              <1> 	call	beep
  2601 000036E6 C3                  <1> 	ret
  2602                              <1> 
  2603                              <1> .scroll:
  2604 000036E7 B402                <1> 	mov	ah,02h
  2605 000036E9 CD10                <1> 	int	10h			; set new cursor position
  2606 000036EB E82E00              <1> 	call	vid_check_mode
  2607 000036EE B700                <1> 	mov	bh,0
  2608 000036F0 7206                <1> 	jc	.do_scroll		; jump if text mode - do scroll
  2609 000036F2 B408                <1> 	mov	ah,08h			; INT 10h, function 08h - read char
  2610 000036F4 CD10                <1> 	int	10h			; read attirbute at current position
  2611 000036F6 88E7                <1> 	mov	bh,ah
  2612                              <1> 
  2613                              <1> .do_scroll:
  2614 000036F8 B406                <1> 	mov	ah,06h			; INT 10h, function 06h - Scroll up
  2615 000036FA B001                <1> 	mov	al,1			; scroll one line
  2616 000036FC 31C9                <1> 	xor	cx,cx			; top right corner is 0,0
  2617 000036FE B618                <1> 	mov	dh,24			; bottom row is 24
  2618 00003700 8A164A00            <1> 	mov	dl,byte [video_columns] ; right column is the last column
  2619 00003704 FECA                <1> 	dec	dl
  2620 00003706 CD10                <1> 	int	10h			; scroll page up
  2621 00003708 C3                  <1> 	ret
  2622                              <1> 
  2623                              <1> ;=========================================================================
  2624                              <1> ; int_10_fn0F - Get current video mode
  2625                              <1> ; Input:
  2626                              <1> ;	AH = 0Fh
  2627                              <1> ; Output:
  2628                              <1> ;	AL = video mode
  2629                              <1> ;	AH = characters per column
  2630                              <1> ;	BH = active video page
  2631                              <1> ;-------------------------------------------------------------------------
  2632                              <1> int_10_fn0F:
  2633 00003709 A04A00              <1> 	mov	al,byte [video_columns]
  2634 0000370C 884601              <1> 	mov	byte [bp+int_10_ah],al
  2635 0000370F A04900              <1> 	mov	al,byte [video_mode]
  2636 00003712 884600              <1> 	mov	byte [bp+int_10_al],al
  2637 00003715 A06200              <1> 	mov	al,byte [video_page]
  2638 00003718 884603              <1> 	mov	byte [bp+int_10_bh],al
  2639 0000371B C3                  <1> 	ret
  2640                              <1> 
  2641                              <1> ;=========================================================================
  2642                              <1> ; vid_check_mode - Check current video mode
  2643                              <1> ; Input:
  2644                              <1> ;	none
  2645                              <1> ; Output:
  2646                              <1> ;	ZF set if monochrome mode (mode 07h)
  2647                              <1> ;	CF set if graphics modes (modes 04h - 06h)
  2648                              <1> ;-------------------------------------------------------------------------
  2649                              <1> vid_check_mode:
  2650 0000371C 50                  <1> 	push	ax
  2651 0000371D A04900              <1> 	mov	al,byte [video_mode]
  2652 00003720 3C07                <1> 	cmp	al,07h			; set ZF if monochrome mode
  2653 00003722 7408                <1> 	jz	.exit			; jump if monochrome
  2654 00003724 3C04                <1> 	cmp	al,04h			; clears CF if graphics mode
  2655 00003726 F5                  <1> 	cmc				; invert CF flag (CF = 1 - graphics)
  2656 00003727 7303                <1> 	jnc	.exit			; jump if not graphics (CF = 0, ZF = 0)
  2657 00003729 18C0                <1> 	sbb	al,al			; AL=AL-(AL+CF) set CF and clear ZF?
  2658 0000372B F9                  <1> 	stc				; set CF back
  2659                              <1> 
  2660                              <1> .exit:
  2661 0000372C 58                  <1> 	pop	ax
  2662 0000372D C3                  <1> 	ret
  2663                              <1> 
  2664                              <1> ;=========================================================================
  2665                              <1> ; vid_crtc_writew - Write a word to two consecutive CRTC registers
  2666                              <1> ; Input:
  2667                              <1> ;	AH = register number
  2668                              <1> ;	CX = word to write
  2669                              <1> ; Output:
  2670                              <1> ;	AX trashed
  2671                              <1> ; Note:
  2672                              <1> ;	Writes CH to register number AH, and CL to register number AH+1
  2673                              <1> ;-------------------------------------------------------------------------
  2674                              <1> vid_crtc_writew:
  2675 0000372E 88E8                <1> 	mov	al,ch
  2676 00003730 E80400              <1> 	call	vid_crtc_writeb		; write CH to CRTC register AH
  2677 00003733 FEC4                <1> 	inc	ah			; point AH to the next register
  2678 00003735 88C8                <1> 	mov	al,cl			; prepare AL for vid_crtc_writeb
  2679                              <1> 
  2680                              <1> ; fall through to vid_crtc_writeb (writting to AH+1)
  2681                              <1> 
  2682                              <1> ;=========================================================================
  2683                              <1> ; vid_crtc_writew - Write a word to two consecutive CRTC registers
  2684                              <1> ; Input:
  2685                              <1> ;	AH = register number
  2686                              <1> ;	AL = byte to write
  2687                              <1> ; Output:
  2688                              <1> ;	none
  2689                              <1> ;-------------------------------------------------------------------------
  2690                              <1> vid_crtc_writeb:
  2691 00003737 52                  <1> 	push	dx
  2692 00003738 8B166300            <1> 	mov	dx,word [video_port]	; DX = CRTC index port
  2693 0000373C 86C4                <1> 	xchg	al,ah			; AH = byte, AL = register number
  2694 0000373E EE                  <1> 	out	dx,al			; write register number
  2695 0000373F 86C4                <1> 	xchg	al,ah			; AH = register numbet, AL = byte
  2696 00003741 FEC2                <1> 	inc	dl			; DX = CRTC data port
  2697 00003743 EE                  <1> 	out	dx,al			; write byte
  2698 00003744 5A                  <1> 	pop	dx
  2699 00003745 C3                  <1> 	ret
  2700                              <1> 
  2701                              <1> ;=========================================================================
  2702                              <1> ; vid_pixel_address - calculate pixel address and mask
  2703                              <1> ; Input:
  2704                              <1> ;	CX - column
  2705                              <1> ;	DX - row
  2706                              <1> ; Output:
  2707                              <1> ;	SI - pixel address
  2708                              <1> ;	CH - pixel mask
  2709                              <1> ;	CL - pixel position in the byte
  2710                              <1> ;	ZF - mode
  2711                              <1> ;		0 = 320x200
  2712                              <1> ;		1 = 640x200
  2713                              <1> ;-------------------------------------------------------------------------
  2714                              <1> vid_pixel_address:
  2715 00003746 31F6                <1> 	xor	si,si			; SI = 0
  2716 00003748 D0EA                <1> 	shr	dl,1			; divide row by two
  2717 0000374A 7303                <1> 	jnb	.even			; jump if on even row 
  2718 0000374C BE0020              <1> 	mov	si,2000h		; odd row - second video plane
  2719                              <1> 
  2720                              <1> .even:
  2721 0000374F B050                <1> 	mov	al,50h			; bytes in each row
  2722 00003751 F6E2                <1> 	mul	dl			; AX - address of the row
  2723                              <1> 
  2724 00003753 01C6                <1> 	add	si,ax			; add row address to SI
  2725 00003755 89CA                <1> 	mov	dx,cx			; DX - column
  2726 00003757 B90203              <1> 	mov	cx,0302h 		; CH - pixel pos mask, CL - shift
  2727 0000375A 803E490006          <1> 	cmp	byte [video_mode],6	; 640x200 mode?
  2728 0000375F 9C                  <1> 	pushf				; save ZF (and other flags
  2729 00003760 7503                <1> 	jnz	.1			; skip if not 640x200
  2730 00003762 B90307              <1> 	mov	cx,0703h 		; pixel pos mask and shift for 640x200
  2731                              <1> 
  2732                              <1> .1:
  2733 00003765 20D5                <1> 	and	ch,dl			; CH = pixel position in the byte
  2734 00003767 D3EA                <1> 	shr	dx,cl			; DX = address of the column
  2735 00003769 01D6                <1> 	add	si,dx			; add column address to SI
  2736 0000376B 86CD                <1> 	xchg	cl,ch			; CH = pixel mask, CL = pixel position
  2737 0000376D 9D                  <1> 	popf
  2738 0000376E C3                  <1> 	ret
  2739                              <1> 
  2740                              <1> ;=========================================================================
  2741                              <1> ; vid_current_offset - convert current cursor position to offset
  2742                              <1> ;		       relative to page starting address
  2743                              <1> ; Input:
  2744                              <1> ;	BL = page
  2745                              <1> ; Output:
  2746                              <1> ;	AX = offset
  2747                              <1> ;-------------------------------------------------------------------------
  2748                              <1> vid_current_offset:
  2749 0000376F B700                <1> 	mov	bh,0
  2750 00003771 D1E3                <1> 	shl	bx,1				; word index
  2751 00003773 8B4750              <1> 	mov	ax,word [bx+video_cur_pos]	; AX = current cursor position
  2752                              <1> 
  2753                              <1> ; fall through to vid_position_to_offset
  2754                              <1> 
  2755                              <1> ;=========================================================================
  2756                              <1> ; vid_position_to_offset - convert position (row and column) to offset
  2757                              <1> ;			   relative to page starting address
  2758                              <1> ; Input:
  2759                              <1> ;	AH = row
  2760                              <1> ;	AL = column
  2761                              <1> ; Output:
  2762                              <1> ;	AX = offset
  2763                              <1> ;-------------------------------------------------------------------------
  2764                              <1> vid_position_to_offset:
  2765 00003776 53                  <1> 	push	bx
  2766 00003777 88C3                <1> 	mov	bl,al			; BL = column
  2767 00003779 88E0                <1> 	mov	al,ah			; AL = row
  2768 0000377B F6264A00            <1> 	mul	byte [video_columns] 	; AX = row * video_columns
  2769 0000377F B700                <1> 	mov	bh,0			;
  2770 00003781 01D8                <1> 	add	ax,bx			; AX = row * video_columns + column
  2771 00003783 D1E0                <1> 	shl	ax,1			; multiply by two (char + attribute)
  2772 00003785 5B                  <1> 	pop	bx
  2773 00003786 C3                  <1> 	ret
  2774                              <1> 
  2775                              <1> ;=========================================================================
  2776                              <1> ; vid_gfx_pos_to_offset - convert position (row and column) to offset
  2777                              <1> ; Input:
  2778                              <1> ;	AH = row
  2779                              <1> ;	AL = column
  2780                              <1> ; Output:
  2781                              <1> ;	AX = offset
  2782                              <1> ;-------------------------------------------------------------------------
  2783                              <1> vid_gfx_pos_to_offset:
  2784 00003787 53                  <1> 	push	bx
  2785 00003788 88C3                <1> 	mov	bl,al			; BL = column
  2786 0000378A 88E0                <1> 	mov	al,ah			; AL = row
  2787 0000378C F6264A00            <1> 	mul	byte [video_columns] 	; AX = row * video_columns
  2788 00003790 D1E0                <1> 	shl	ax,1			; multiply by four: one character takes
  2789 00003792 D1E0                <1> 	shl	ax,1			;   four bytes in each plane
  2790 00003794 B700                <1> 	mov	bh,0
  2791 00003796 01D8                <1> 	add	ax,bx			; AX = row * video_columns * 4 + column
  2792 00003798 5B                  <1> 	pop	bx
  2793 00003799 C3                  <1> 	ret
  1328                                  
  1329                                  ;=========================================================================
  1330                                  ; detect_rom_ext - Look for BIOS extensions, initialize if found
  1331                                  ;-------------------------------------------------------------------------
  1332                                  
  1333                                  detect_rom_ext:
  1334 0000379A B040                    	mov	al,e_ext_start		; ROM extension scan start
  1335 0000379C E680                    	out	post_reg,al
  1336 0000379E E421                    	in	al,pic1_reg1		; get IMR (option ROMs may trash it)
  1337 000037A0 50                      	push	ax			; save it
  1338 000037A1 BA00C8                  	mov	dx,0C800h
  1339 000037A4 BB00F8                  	mov	bx,0F800h
  1340                                  %ifdef BIOS_SETUP
  1341                                  	call	get_config_a
  1342                                  	test	al,nvram_ext_scan
  1343                                  	jz	.ext_scan_loop		; ext_scan clear - scan till F8000
  1344                                  	mov	bx,0F000h		; ext_scan set - scan till F0000
  1345                                  %endif ; BIOS_SETUP
  1346                                  
  1347                                  .ext_scan_loop:
  1348 000037A7 E8EC00                  	call	extension_scan
  1349 000037AA 833E670000              	cmp	word [67h],0
  1350 000037AF 7429                    	jz	.ext_scan_done		; No ROM extension found
  1351 000037B1 B041                    	mov	al,e_ext_detect		; ROM extension found
  1352 000037B3 E680                    	out	post_reg,al
  1353 000037B5 BE[B203]                	mov	si,msg_rom_found
  1354 000037B8 E8D8DF                  	call	print
  1355 000037BB A16900                  	mov	ax,word [69h]		; ROM extension's segment
  1356 000037BE E8EDDF                  	call	print_hex
  1357 000037C1 BE[CF03]                	mov	si,msg_rom_init
  1358 000037C4 E8CCDF                  	call	print
  1359 000037C7 53                      	push	bx
  1360 000037C8 52                      	push	dx
  1361 000037C9 FF1E6700                	call	far [67h]
  1362 000037CD B84000                  	mov	ax,biosdseg		; DS = BIOS data area
  1363 000037D0 8ED8                    	mov	ds,ax
  1364 000037D2 B042                    	mov	al,e_ext_init_ok	; ROM extension initialized
  1365 000037D4 E680                    	out	post_reg,al
  1366 000037D6 5A                      	pop	dx
  1367 000037D7 5B                      	pop	bx
  1368 000037D8 EBCD                    	jmp	.ext_scan_loop
  1369                                  
  1370                                  .ext_scan_done:
  1371 000037DA 58                      	pop	ax			; get previous IMR
  1372 000037DB E621                    	out	pic1_reg1,al		; restore it
  1373 000037DD B043                    	mov	al,e_ext_complete	; ROM extension scan complete
  1374 000037DF E680                    	out	post_reg,al
  1375                                  
  1376 000037E1 C3                      	ret
  1377                                  
  1378                                  ;=========================================================================
  1379                                  ; detect_ram - Determine the size of installed RAM and test it
  1380                                  ; Input:
  1381                                  ;	none
  1382                                  ; Output:
  1383                                  ;	AX = RAM size
  1384                                  ;	CX, SI - trashed
  1385                                  ;-------------------------------------------------------------------------
  1386                                  detect_ram:
  1387 000037E2 B030                    	mov	al,e_ram_start		; RAM scan start
  1388 000037E4 E680                    	out	post_reg,al
  1389                                  
  1390 000037E6 1E                      	push	ds
  1391 000037E7 B106                    	mov	cl,6			; for SHL - converting KiB to segment
  1392 000037E9 B82000                  	mov	ax,MIN_RAM_SIZE
  1393                                  
  1394                                  .fill_loop:
  1395 000037EC 50                      	push	ax
  1396 000037ED D3E0                    	shl	ax,cl			; convert KiB to segment (mult. by 64)
  1397 000037EF 8ED8                    	mov	ds,ax
  1398 000037F1 A3FE3F                  	mov	word [RAM_TEST_BLOCK-2],ax
  1399 000037F4 58                      	pop	ax
  1400 000037F5 83C010                  	add	ax,RAM_TEST_BLOCK/1024
  1401 000037F8 3D8002                  	cmp	ax,MAX_RAM_SIZE
  1402 000037FB 75EF                    	jne	.fill_loop
  1403 000037FD B82000                  	mov	ax,MIN_RAM_SIZE
  1404                                  
  1405                                  .size_loop:
  1406 00003800 50                      	push	ax
  1407 00003801 D3E0                    	shl	ax,cl			; convert KiB to segment (mult. by 64)
  1408 00003803 8ED8                    	mov	ds,ax
  1409 00003805 3906FE3F                	cmp	word [RAM_TEST_BLOCK-2],ax
  1410 00003809 750B                    	jne	.size_done
  1411 0000380B 58                      	pop	ax
  1412 0000380C 83C010                  	add	ax,RAM_TEST_BLOCK/1024
  1413 0000380F 3D8002                  	cmp	ax,MAX_RAM_SIZE
  1414 00003812 7303                    	jnb	.size_exit
  1415 00003814 EBEA                    	jmp	.size_loop
  1416                                  
  1417                                  .size_done:
  1418 00003816 58                      	pop	ax
  1419                                  
  1420                                  .size_exit:
  1421 00003817 1F                      	pop	ds
  1422 00003818 A31300                  	mov	word [memory_size],ax	; store it for now... might change later
  1423 0000381B C3                      	ret
  1424                                  
  1425                                  ;=========================================================================
  1426                                  ; int_12 - Get memory size
  1427                                  ; Input:
  1428                                  ;	none
  1429                                  ; Output:
  1430                                  ;	AX = memory size
  1431                                  ;-------------------------------------------------------------------------
  1432 0000381C FF<rep 25h>             	setloc	0F841h			; INT 12 Entry Point
  1432          ******************       warning: Inserting 37 bytes [-w+user]
  1433                                  int_12:
  1434 00003841 FB                      	sti
  1435 00003842 1E                      	push	ds
  1436 00003843 B84000                  	mov	ax,biosdseg
  1437 00003846 8ED8                    	mov	ds,ax
  1438 00003848 A11300                  	mov	ax,word [memory_size]
  1439 0000384B 1F                      	pop	ds
  1440 0000384C CF                      	iret
  1441                                  
  1442                                  ;=========================================================================
  1443                                  ; int_11 - Get equipment list
  1444                                  ; Input:
  1445                                  ;	none
  1446                                  ; Output:
  1447                                  ;	AX = equipment list
  1448                                  ;-------------------------------------------------------------------------
  1449                                  	setloc	0F84Dh			; INT 11 Entry Point
  1450                                  int_11:
  1451 0000384D FB                      	sti
  1452 0000384E 1E                      	push	ds
  1453 0000384F B84000                  	mov	ax,biosdseg
  1454 00003852 8ED8                    	mov	ds,ax
  1455 00003854 A11000                  	mov	ax,word [equipment_list]
  1456 00003857 1F                      	pop	ds
  1457 00003858 CF                      	iret
  1458                                  
  1459                                  ;=========================================================================
  1460                                  ; Includes with fixed entry points (for IBM compatibility)
  1461                                  ;-------------------------------------------------------------------------
  1462                                  
  1463                                  %include	"misc.inc"
  1464                              <1> ;=========================================================================
  1465                              <1> ; misc.inc - Miscellaneous BIOS Services
  1466                              <1> ;       INT 15h, functions:
  1467                              <1> ;       	4Fh	- OS hook keyboard intercept
  1468                              <1> ;		90h	- Device busy loop
  1469                              <1> ;		91h	- Interrupt completed
  1470                              <1> ;		0C0h	- Get system configruation
  1471                              <1> ;		0C2h	- PS/2 mouse services (see ps2aux.inc)
  1472                              <1> ;		
  1473                              <1> ;-------------------------------------------------------------------------
  1474                              <1> ;
  1475                              <1> ; Compiles with NASM 2.13.02, might work with other versions
  1476                              <1> ;
  1477                              <1> ; Copyright (C) 2010 - 2023 Sergey Kiselev.
  1478                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
  1479                              <1> ;
  1480                              <1> ; This program is free software: you can redistribute it and/or modify
  1481                              <1> ; it under the terms of the GNU General Public License as published by
  1482                              <1> ; the Free Software Foundation, either version 3 of the License, or
  1483                              <1> ; (at your option) any later version.
  1484                              <1> ;
  1485                              <1> ; This program is distributed in the hope that it will be useful,
  1486                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  1487                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  1488                              <1> ; GNU General Public License for more details.
  1489                              <1> ;
  1490                              <1> ; You should have received a copy of the GNU General Public License
  1491                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  1492                              <1> ;
  1493                              <1> ;=========================================================================
  1494                              <1> 
  1495                              <1> ;-------------------------------------------------------------------------
  1496                              <1> ; offsets for registers on stack
  1497                              <1> int_15_bp	equ	0
  1498                              <1> int_15_ip	equ	int_15_bp+2
  1499                              <1> int_15_cs	equ	int_15_ip+2
  1500                              <1> int_15_flags	equ	int_15_cs+2
  1501                              <1> 
  1502                              <1> ;=========================================================================
  1503                              <1> ; int_15 - Miscellaneous BIOS services
  1504                              <1> ; Input:
  1505                              <1> ;	AH = 4Fh - OS hook keyboard intercept
  1506                              <1> ;		- Does nothing
  1507                              <1> ;	AH = 0C2h - PS/2 mouse services
  1508                              <1> ;		- Implemented in ps2aux.inc
  1509                              <1> ;-------------------------------------------------------------------------
  1510                              <1> 	setloc	0F859h			; INT 15 Entry Point
  1511                              <1> int_15:
  1512 00003859 FB                  <1> 	sti
  1513 0000385A 80FC4F              <1> 	cmp	ah,4Fh
  1514 0000385D 742A                <1> 	je	int_15_exit		; continue with int 09h ISR
  1515 0000385F 80FCC0              <1> 	cmp	ah,0C0h
  1516 00003862 7426                <1> 	je	int_15_fnC0
  1517 00003864 3D0190              <1> 	cmp	ax,9001h
  1518 00003867 741E                <1> 	je	int_15_os_hook		; diskette - device busy hook
  1519 00003869 3DFD90              <1> 	cmp	ax,90FDh
  1520 0000386C 7419                <1> 	je	int_15_os_hook		; diskette - motor start hook
  1521 0000386E 3D0191              <1> 	cmp	ax,9101h
  1522 00003871 7414                <1> 	je	int_15_os_hook		; diskette - interrupt completed
  1523                              <1> 
  1524                              <1> %ifdef PS2_MOUSE
  1525                              <1> 	cmp	ah,0C2h
  1526                              <1> 	jne	.1
  1527                              <1> 	jmp	int_15_fnC2		; jump to PS/2 mouse handler
  1528                              <1> .1:
  1529                              <1> %endif
  1530                              <1> 
  1531 00003873 B486                <1> 	mov	ah,86h			; no cassete present
  1532                              <1> 
  1533                              <1> int_15_err:
  1534 00003875 55                  <1> 	push	bp
  1535 00003876 89E5                <1> 	mov	bp,sp
  1536 00003878 804E0601            <1> 	or	byte [bp+int_15_flags],1 ; set CF flag
  1537 0000387C 5D                  <1> 	pop	bp
  1538 0000387D CF                  <1> 	iret
  1539                              <1> 
  1540                              <1> int_15_ok:
  1541 0000387E 55                  <1> 	push	bp
  1542 0000387F 89E5                <1> 	mov	bp,sp
  1543 00003881 806606FE            <1> 	and	byte [bp+int_15_flags],~1 ; clear CF flag
  1544 00003885 5D                  <1> 	pop	bp
  1545 00003886 CF                  <1> 	iret
  1546                              <1> 
  1547                              <1> int_15_os_hook:
  1548 00003887 B400                <1> 	mov	ah,00h
  1549                              <1> 
  1550                              <1> int_15_exit:
  1551 00003889 CF                  <1> 	iret
  1552                              <1> 
  1553                              <1> ;=========================================================================
  1554                              <1> ; int_15_fnC0 - Get configuration
  1555                              <1> ; Input:
  1556                              <1> ;	AH = 0C0h - get configuration
  1557                              <1> ; Output:
  1558                              <1> ;	AH = 00h - function supported
  1559                              <1> ;	ES:BX = configuration table (0F000h:0E6F5h)
  1560                              <1> ;	CF = 0 (success)
  1561                              <1> ;-------------------------------------------------------------------------
  1562                              <1> int_15_fnC0:
  1563 0000388A B400                <1> 	mov	ah,00h
  1564 0000388C BB00F0              <1> 	mov	bx,bioscseg
  1565 0000388F 8EC3                <1> 	mov	es,bx
  1566 00003891 BB[F526]            <1> 	mov	bx,config_table
  1567 00003894 EBE8                <1> 	jmp	int_15_ok
  1464                                  
  1465                                  ;=========================================================================
  1466                                  ; extension_scan - scan for BIOS extensions
  1467                                  ; Input:
  1468                                  ;	DX - start segment
  1469                                  ;	BX - end segment
  1470                                  ; Returns:
  1471                                  ;	DX - address for the continuation of the scan
  1472                                  ;	biosdseg:67h - address of the extension, 0000:0000 if not found
  1473                                  ;-------------------------------------------------------------------------
  1474                                  extension_scan:
  1475 00003896 C70667000000            	mov	word [67h],0
  1476 0000389C C70669000000            	mov	word [69h],0
  1477                                  .scan:
  1478 000038A2 8EC2                    	mov	es,dx
  1479 000038A4 26813E000055AA              es	cmp	word [0],0AA55h		; check for signature
  1480 000038AB 7532                    	jnz	.next			; no signature, check next 2 KiB
  1481 000038AD 26A00200                    es	mov	al,byte [2]		; AL = rom size in 512 byte blocks
  1482 000038B1 B400                    	mov	ah,0
  1483 000038B3 B105                    	mov	cl,5
  1484 000038B5 D3E0                    	shl	ax,cl			; convert size to paragraphs
  1485 000038B7 01C2                    	add	dx,ax
  1486 000038B9 83C27F                  	add	dx,007Fh		; round DX to the nearest 2 KiB
  1487 000038BC 83E280                  	and	dx,0FF80h		; (2 KiB = 128 x 16 bytes)
  1488 000038BF B104                    	mov	cl,4
  1489 000038C1 D3E0                    	shl	ax,cl			; convert size to bytes
  1490 000038C3 89C1                    	mov	cx,ax
  1491 000038C5 B000                    	mov	al,0
  1492 000038C7 31F6                    	xor	si,si
  1493                                  .checksum:
  1494 000038C9 260204                      es	add	al,byte [si]
  1495 000038CC 46                      	inc	si
  1496 000038CD E2FA                    	loop	.checksum
  1497 000038CF 08C0                    	or	al,al			; AL == 0?
  1498 000038D1 750C                    	jnz	.next			; AL not zero - bad checksum
  1499 000038D3 C70667000300            	mov	word [67h],3		; extension initialization offset
  1500 000038D9 8C066900                	mov	word [69h],es		; extension segment
  1501 000038DD EB08                    	jmp	.exit
  1502                                  .next:
  1503 000038DF 81C28000                	add	dx,80h			; add 2 KiB
  1504 000038E3 39DA                    	cmp	dx,bx
  1505 000038E5 72BB                    	jb	.scan
  1506                                  .exit:
  1507 000038E7 C3                      	ret
  1508                                  
  1509                                  ;=========================================================================
  1510                                  ; ipl - Initial Program Load - try to read and execute boot sector
  1511                                  ;-------------------------------------------------------------------------
  1512                                  ipl:
  1513 000038E8 FB                      	sti
  1514 000038E9 31C0                    	xor	ax,ax
  1515 000038EB 8ED8                    	mov	ds,ax
  1516 000038ED C7067800[C72F]          	mov	word [78h],int_1E	; set Floppy Parameters Table location
  1517 000038F3 8C0E7A00                	mov	word [7Ah],cs
  1518                                  
  1519                                  .boot_retry:
  1520 000038F7 B90400                  	mov	cx,4			; retry booting from floppy 4 times
  1521                                  
  1522                                  .fd_read_retry:
  1523 000038FA 51                      	push	cx
  1524 000038FB B400                    	mov	ah,00h			; reset disk system
  1525 000038FD B200                    	mov	dl,00h			; drive 0
  1526 000038FF CD13                    	int	13h
  1527 00003901 7220                    	jb	.fd_failed
  1528 00003903 B408                    	mov	ah,08h			; get drive parameters
  1529 00003905 B200                    	mov	dl,00h			; drive 0
  1530 00003907 CD13                    	int	13h
  1531 00003909 7218                    	jc	.fd_failed
  1532 0000390B 80FA00                  	cmp	dl,00h
  1533 0000390E 7416                    	jz	.try_hdd		; jump if zero drives
  1534 00003910 B80102                  	mov	ax,0201h		; read one sector
  1535 00003913 31D2                    	xor	dx,dx			; head 0, drive 0
  1536 00003915 8EC2                    	mov	es,dx			; to 0000:7C00
  1537 00003917 BB007C                  	mov	bx,7C00h
  1538 0000391A B90100                  	mov	cx,0001h		; track 0, sector 1
  1539 0000391D CD13                    	int	13h
  1540 0000391F 7202                    	jc	.fd_failed
  1541 00003921 EB1D                    	jmp	.check_signature	; read successful, check for boot sector
  1542                                  
  1543                                  .fd_failed:
  1544 00003923 59                      	pop	cx
  1545 00003924 E2D4                    	loop	.fd_read_retry
  1546                                  
  1547                                  ; try booting from HDD
  1548                                  .try_hdd:
  1549 00003926 B40D                    	mov	ah,0Dh			; reset hard disks
  1550 00003928 B280                    	mov	dl,80h			; drive 80h
  1551 0000392A CD13                    	int	13h
  1552 0000392C 7220                    	jc	.boot_failed
  1553 0000392E B80102                  	mov	ax,0201h		; read one sector
  1554 00003931 BA8000                  	mov	dx,0080h		; head 0, drive 80h
  1555 00003934 31C9                    	xor	cx,cx
  1556 00003936 8EC1                    	mov	es,cx
  1557 00003938 BB007C                  	mov	bx,7C00h		; to 0000:7C00
  1558 0000393B 41                      	inc	cx			; CX == 0001h; track 0, sector 1
  1559 0000393C CD13                    	int	13h
  1560 0000393E 720E                    	jc	.boot_failed
  1561                                  
  1562                                  .check_signature:
  1563 00003940 26813EFE7D55AA              es	cmp	word [7DFEh],0AA55h
  1564 00003947 7505                    	jnz	.boot_failed		; boot sector signature not found
  1565 00003949 EA007C0000              	jmp	0000h:7C00h		; jump to the boot sector
  1566                                  
  1567                                  .boot_failed:
  1568 0000394E BE[7603]                	mov	si,msg_boot_failed
  1569 00003951 E83FDE                  	call	print
  1570 00003954 B400                    	mov	ah,00h
  1571 00003956 CD16                    	int	16h
  1572 00003958 EB9D                    	jmp	.boot_retry
  1573                                  
  1574                                  ;=========================================================================
  1575                                  ; test_ram - Test installed RAM
  1576                                  ; Input:
  1577                                  ;	AX = detected RAM size
  1578                                  ; Output:
  1579                                  ;	AX = tested RAM size
  1580                                  ;	CX, SI - trashed
  1581                                  ;-------------------------------------------------------------------------
  1582                                  test_ram:
  1583 0000395A 813E72003412            	cmp	word [warm_boot],1234h	; warm boot - don't test RAM
  1584 00003960 7474                    	je	.test_done
  1585                                  
  1586                                  %ifdef BIOS_SETUP
  1587                                  	push	ax
  1588                                  	call	get_config_a
  1589                                  	test	al,nvram_mem_test
  1590                                  	pop	ax
  1591                                  	jnz	.test_done		; mem_test set - skip memory test
  1592                                  %endif ; BIOS_SETUP
  1593                                  
  1594 00003962 BE[1003]                	mov	si,msg_ram_testing
  1595 00003965 E82BDE                  	call	print
  1596 00003968 B82000                  	mov	ax,MIN_RAM_SIZE		; start from 32 KiB
  1597                                  
  1598                                  .test_loop:
  1599 0000396B 50                      	push	ax
  1600 0000396C B403                    	mov	ah,03h			; INT 10h, AH=03h - get cursor position
  1601 0000396E B700                    	mov	bh,00h			; page 0
  1602 00003970 CD10                    	int	10h			; position returned in DX
  1603 00003972 58                      	pop	ax
  1604 00003973 E85ADE                  	call	print_dec
  1605 00003976 50                      	push	ax
  1606 00003977 B402                    	mov	ah,02h			; INT 10h, AH=02h - set cursor position
  1607 00003979 B700                    	mov	bh,00h			; page 0
  1608 0000397B CD10                    	int	10h
  1609 0000397D B401                    	mov	ah,01h
  1610 0000397F CD16                    	int	16h
  1611 00003981 7412                    	jz	.test_no_key
  1612 00003983 B400                    	mov	ah,00h
  1613 00003985 CD16                    	int	16h			; read the keystroke
  1614 00003987 3C1B                    	cmp	al,1Bh			; ESC?
  1615 00003989 7421                    	je	.test_esc
  1616 0000398B 3D003B                  	cmp	ax,3B00h		; F1?
  1617 0000398E 7505                    	jne	.test_no_key
  1618 00003990 800E120001              	or	byte [post_flags],post_setup
  1619                                  
  1620                                  .test_no_key:
  1621 00003995 58                      	pop	ax
  1622 00003996 E83E00                  	call	ram_test_block
  1623 00003999 721D                    	jc	.test_error		; error in last test
  1624 0000399B 83C010                  	add	ax,RAM_TEST_BLOCK/1024	; test the next block
  1625 0000399E 3B061300                	cmp	ax,word [memory_size]
  1626 000039A2 72C7                    	jb	.test_loop
  1627                                  
  1628 000039A4 50                      	push	ax
  1629 000039A5 B031                    	mov	al,e_ram_complete	; RAM scan complete
  1630 000039A7 E680                    	out	post_reg,al
  1631 000039A9 58                      	pop	ax
  1632                                  
  1633 000039AA EB2A                    	jmp	.test_done
  1634                                  
  1635                                  .test_esc:
  1636 000039AC 58                      	pop	ax
  1637 000039AD A11300                  	mov	ax,word [memory_size]
  1638                                  
  1639 000039B0 50                      	push	ax
  1640 000039B1 B032                    	mov	al,e_ram_esc		; RAM scan canceled
  1641 000039B3 E680                    	out	post_reg,al
  1642 000039B5 58                      	pop	ax
  1643                                  
  1644 000039B6 EB1E                    	jmp	.test_done
  1645                                  
  1646                                  .test_error:
  1647 000039B8 A31300                  	mov	word [memory_size],ax	; store size of good memory
  1648 000039BB BE[2D03]                	mov	si,msg_ram_error
  1649 000039BE E8D2DD                  	call	print
  1650 000039C1 E80CDE                  	call	print_dec
  1651 000039C4 BE[6F03]                	mov	si,msg_kib
  1652 000039C7 E8C9DD                  	call	print
  1653 000039CA BE[8900]                	mov	si,msg_crlf
  1654 000039CD E8C3DD                  	call	print
  1655                                  
  1656 000039D0 50                      	push	ax
  1657 000039D1 B055                    	mov	al,e_ram_fail		; RAM scan failed
  1658 000039D3 E680                    	out	post_reg,al
  1659 000039D5 58                      	pop	ax
  1660                                  
  1661                                  .test_done:
  1662 000039D6 C3                      	ret
  1663                                  
  1664                                  ;=========================================================================
  1665                                  ; ram_test_block - Test a 16 KiB (RAM_TEST_BLOCK) of RAM
  1666                                  ; Input:
  1667                                  ;	AX = address of the memory to test (in KiB)
  1668                                  ; Output:
  1669                                  ;	CF = status
  1670                                  ;		0 = passed
  1671                                  ;		1 = failed
  1672                                  ;-------------------------------------------------------------------------
  1673                                  ram_test_block:
  1674 000039D7 50                      	push	ax
  1675 000039D8 53                      	push	bx
  1676 000039D9 51                      	push	cx
  1677 000039DA 56                      	push	si
  1678 000039DB 57                      	push	di
  1679 000039DC 1E                      	push	ds
  1680 000039DD 06                      	push	es
  1681 000039DE B106                    	mov	cl,6			; convert KiB to segment address
  1682 000039E0 D3E0                    	shl	ax,cl			; (multiply by 64)
  1683 000039E2 8ED8                    	mov	ds,ax
  1684 000039E4 8EC0                    	mov	es,ax
  1685 000039E6 31F6                    	xor	si,si
  1686 000039E8 31FF                    	xor	di,di
  1687 000039EA BB0020                  	mov	bx,RAM_TEST_BLOCK/2	; RAM test block size in words
  1688 000039ED B8AA55                  	mov	ax,55AAh		; first test pattern
  1689 000039F0 89D9                    	mov	cx,bx
  1690 000039F2 F3AB                        rep	stosw				; store test pattern
  1691 000039F4 89D9                    	mov	cx,bx			; RAM test block size
  1692                                  .1:
  1693 000039F6 AD                      	lodsw
  1694 000039F7 3DAA55                  	cmp	ax,55AAh		; compare to the test pattern
  1695 000039FA 7522                    	jne	.fail
  1696 000039FC E2F8                    	loop	.1
  1697 000039FE 31F6                    	xor	si,si
  1698 00003A00 31FF                    	xor	di,di
  1699 00003A02 B855AA                  	mov	ax,0AA55h		; second test pattern
  1700 00003A05 89D9                    	mov	cx,bx			; RAM test block size
  1701 00003A07 F3AB                        rep stosw				; store test pattern
  1702 00003A09 89D9                    	mov	cx,bx			; RAM test block size
  1703                                  .2:
  1704 00003A0B AD                      	lodsw
  1705 00003A0C 3D55AA                  	cmp	ax,0AA55h		; compare to the test pattern
  1706 00003A0F 750D                    	jne	.fail
  1707 00003A11 E2F8                    	loop	.2
  1708 00003A13 31FF                    	xor	di,di
  1709 00003A15 31C0                    	xor	ax,ax			; zero
  1710 00003A17 89D9                    	mov	cx,bx			; RAM test block size
  1711 00003A19 F3AB                        rep stosw				; zero the memory
  1712 00003A1B F8                      	clc				; test passed, clear CF
  1713 00003A1C EB01                    	jmp	.exit
  1714                                  
  1715                                  .fail:
  1716 00003A1E F9                      	stc				; test failed, set CF
  1717                                  	
  1718                                  .exit:
  1719 00003A1F 07                      	pop	es
  1720 00003A20 1F                      	pop	ds
  1721 00003A21 5F                      	pop	di
  1722 00003A22 5E                      	pop	si
  1723 00003A23 59                      	pop	cx
  1724 00003A24 5B                      	pop	bx
  1725 00003A25 58                      	pop	ax
  1726 00003A26 C3                      	ret
  1727                                  
  1728                                  ;=========================================================================
  1729                                  ; Includes with fixed entry points (for IBM compatibility)
  1730                                  ;-------------------------------------------------------------------------
  1731                                  %include	"fnt00-7F.inc"
  1732                              <1> ;=========================================================================
  1733                              <1> ; fnt00-7F.inc - Font for graphics modes
  1734                              <1> ;       Characters from 00h to 7Fh
  1735                              <1> ;-------------------------------------------------------------------------
  1736                              <1> ;
  1737                              <1> ; Compiles with NASM 2.13.02, might work with other versions
  1738                              <1> ;
  1739                              <1> ; This font is borrowed from kbd package (alt-8x8)
  1740                              <1> ;
  1741                              <1> ; This program is free software: you can redistribute it and/or modify
  1742                              <1> ; it under the terms of the GNU General Public License as published by
  1743                              <1> ; the Free Software Foundation, either version 3 of the License, or
  1744                              <1> ; (at your option) any later version.
  1745                              <1> ;
  1746                              <1> ; This program is distributed in the hope that it will be useful,
  1747                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  1748                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  1749                              <1> ; GNU General Public License for more details.
  1750                              <1> ;
  1751                              <1> ; You should have received a copy of the GNU General Public License
  1752                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  1753                              <1> ;
  1754                              <1> ;=========================================================================
  1755 00003A27 FF<rep 47h>         <1> 	setloc	0FA6Eh			; IBM graphics char set entry
  1755          ******************  <1>  warning: Inserting 71 bytes [-w+user]
  1756                              <1> gfx_font:
  1757 00003A6E 0000000000000000    <1> 	db	 00h, 00h,   00h,  00h,  00h,  00h,  00h,  00h
  1758 00003A76 7E81A581BD99817E    <1> 	db	 7Eh, 81h,  0A5h,  81h, 0BDh,  99h,  81h,  7Eh
  1759 00003A7E 7EFFDBFFC3E7FF7E    <1> 	db	 7Eh, 0FFh, 0DBh, 0FFh, 0C3h, 0E7h, 0FFh,  7Eh
  1760 00003A86 6CFEFEFE7C381000    <1> 	db	 6Ch, 0FEh, 0FEh, 0FEh,  7Ch,  38h,  10h,  00h
  1761 00003A8E 10387CFE7C381000    <1> 	db	 10h,  38h,  7Ch, 0FEh,  7Ch,  38h,  10h,  00h
  1762 00003A96 387C38FEFE7C387C    <1> 	db	 38h,  7Ch,  38h, 0FEh, 0FEh,  7Ch,  38h,  7Ch
  1763 00003A9E 1010387CFE7C387C    <1> 	db	 10h,  10h,  38h,  7Ch, 0FEh,  7Ch,  38h,  7Ch
  1764 00003AA6 0000183C3C180000    <1> 	db	 00h,  00h,  18h,  3Ch,  3Ch,  18h,  00h,  00h
  1765 00003AAE FFFFE7C3C3E7FFFF    <1> 	db	0FFh, 0FFh, 0E7h, 0C3h, 0C3h, 0E7h, 0FFh, 0FFh
  1766 00003AB6 003C664242663C00    <1> 	db	 00h,  3Ch,  66h,  42h,  42h,  66h,  3Ch,  00h
  1767 00003ABE FFC399BDBD99C3FF    <1> 	db	0FFh, 0C3h,  99h, 0BDh, 0BDh,  99h, 0C3h, 0FFh
  1768 00003AC6 0F070F7DCCCCCC78    <1> 	db	 0Fh,  07h,  0Fh,  7Dh, 0CCh, 0CCh, 0CCh,  78h
  1769 00003ACE 3C6666663C187E18    <1> 	db	 3Ch,  66h,  66h,  66h,  3Ch,  18h,  7Eh,  18h
  1770 00003AD6 3F333F303070F0E0    <1> 	db	 3Fh,  33h,  3Fh,  30h,  30h,  70h, 0F0h, 0E0h
  1771 00003ADE 7F637F636367E6C0    <1> 	db	 7Fh,  63h,  7Fh,  63h,  63h,  67h, 0E6h, 0C0h
  1772 00003AE6 995A3CE7E73C5A99    <1> 	db	 99h,  5Ah,  3Ch, 0E7h, 0E7h,  3Ch,  5Ah,  99h
  1773 00003AEE 80E0F8FEF8E08000    <1> 	db	 80h, 0E0h, 0F8h, 0FEh, 0F8h, 0E0h,  80h,  00h
  1774 00003AF6 020E3EFE3E0E0200    <1> 	db	 02h,  0Eh,  3Eh, 0FEh,  3Eh,  0Eh,  02h,  00h
  1775 00003AFE 183C7E18187E3C18    <1> 	db	 18h,  3Ch,  7Eh,  18h,  18h,  7Eh,  3Ch,  18h
  1776 00003B06 6666666666006600    <1> 	db	 66h,  66h,  66h,  66h,  66h,  00h,  66h,  00h
  1777 00003B0E 7FDBDB7B1B1B1B00    <1> 	db	 7Fh, 0DBh, 0DBh,  7Bh,  1Bh,  1Bh,  1Bh,  00h
  1778 00003B16 3E63386C6C38CC78    <1> 	db	 3Eh,  63h,  38h,  6Ch,  6Ch,  38h, 0CCh,  78h
  1779 00003B1E 000000007E7E7E00    <1> 	db	 00h,  00h,  00h,  00h,  7Eh,  7Eh,  7Eh,  00h
  1780 00003B26 183C7E187E3C18FF    <1> 	db	 18h,  3Ch,  7Eh,  18h,  7Eh,  3Ch,  18h, 0FFh
  1781 00003B2E 183C7E1818181800    <1> 	db	 18h,  3Ch,  7Eh,  18h,  18h,  18h,  18h,  00h
  1782 00003B36 181818187E3C1800    <1> 	db	 18h,  18h,  18h,  18h,  7Eh,  3Ch,  18h,  00h
  1783 00003B3E 00180CFE0C180000    <1> 	db	 00h,  18h,  0Ch, 0FEh,  0Ch,  18h,  00h,  00h
  1784 00003B46 003060FE60300000    <1> 	db	 00h,  30h,  60h, 0FEh,  60h,  30h,  00h,  00h
  1785 00003B4E 0000C0C0C0FE0000    <1> 	db	 00h,  00h, 0C0h, 0C0h, 0C0h, 0FEh,  00h,  00h
  1786 00003B56 002466FF66240000    <1> 	db	 00h,  24h,  66h, 0FFh,  66h,  24h,  00h,  00h
  1787 00003B5E 00183C7EFFFF0000    <1> 	db	 00h,  18h,  3Ch,  7Eh,  0FFh, 0FFh, 00h,  00h
  1788 00003B66 00FFFF7E3C180000    <1> 	db	 00h, 0FFh, 0FFh,  7Eh,  3Ch,  18h,  00h,  00h
  1789 00003B6E 0000000000000000    <1> 	db	 00h,  00h,  00h,  00h,  00h,  00h,  00h,  00h
  1790 00003B76 3078783030003000    <1> 	db	 30h,  78h,  78h,  30h,  30h,  00h,  30h,  00h
  1791 00003B7E 6C6C6C0000000000    <1> 	db	 6Ch,  6Ch,  6Ch,  00h,  00h,  00h,  00h,  00h
  1792 00003B86 6C6CFE6CFE6C6C00    <1> 	db	 6Ch,  6Ch, 0FEh,  6Ch, 0FEh,  6Ch,  6Ch,  00h
  1793 00003B8E 307CC0780CF83000    <1> 	db	 30h,  7Ch, 0C0h,  78h,  0Ch, 0F8h,  30h,  00h
  1794 00003B96 00C6CC183066C600    <1> 	db	 00h, 0C6h, 0CCh,  18h,  30h,  66h, 0C6h,  00h
  1795 00003B9E 386C3876DCCC7600    <1> 	db	 38h,  6Ch,  38h,  76h, 0DCh, 0CCh,  76h,  00h
  1796 00003BA6 6060C00000000000    <1> 	db	 60h,  60h, 0C0h,  00h,  00h,  00h,  00h,  00h
  1797 00003BAE 1830606060301800    <1> 	db	 18h,  30h,  60h,  60h,  60h,  30h,  18h,  00h
  1798 00003BB6 6030181818306000    <1> 	db	 60h,  30h,  18h,  18h,  18h,  30h,  60h,  00h
  1799 00003BBE 00663CFF3C660000    <1> 	db	 00h,  66h,  3Ch, 0FFh,  3Ch,  66h,  00h,  00h
  1800 00003BC6 003030FC30300000    <1> 	db	 00h,  30h,  30h, 0FCh,  30h,  30h,  00h,  00h
  1801 00003BCE 0000000000303060    <1> 	db	 00h,  00h,  00h,  00h,  00h,  30h,  30h,  60h
  1802 00003BD6 000000FC00000000    <1> 	db	 00h,  00h,  00h, 0FCh,  00h,  00h,  00h,  00h
  1803 00003BDE 0000000000303000    <1> 	db	 00h,  00h,  00h,  00h,  00h,  30h,  30h,  00h
  1804 00003BE6 060C183060C08000    <1> 	db	 06h,  0Ch,  18h,  30h,  60h, 0C0h,  80h,  00h
  1805 00003BEE 7CC6CEDEF6E67C00    <1> 	db	 7Ch, 0C6h, 0CEh, 0DEh, 0F6h, 0E6h,  7Ch,  00h
  1806 00003BF6 307030303030FC00    <1> 	db	 30h,  70h,  30h,  30h,  30h,  30h, 0FCh,  00h
  1807 00003BFE 78CC0C3860CCFC00    <1> 	db	 78h, 0CCh,  0Ch,  38h,  60h, 0CCh, 0FCh,  00h
  1808 00003C06 78CC0C380CCC7800    <1> 	db	 78h, 0CCh,  0Ch,  38h,  0Ch, 0CCh,  78h,  00h
  1809 00003C0E 1C3C6CCCFE0C1E00    <1> 	db	 1Ch,  3Ch,  6Ch, 0CCh, 0FEh,  0Ch,  1Eh,  00h
  1810 00003C16 FCC0F80C0CCC7800    <1> 	db	0FCh, 0C0h, 0F8h,  0Ch,  0Ch, 0CCh,  78h,  00h
  1811 00003C1E 3860C0F8CCCC7800    <1> 	db	 38h,  60h, 0C0h, 0F8h, 0CCh, 0CCh,  78h,  00h
  1812 00003C26 FCCC0C1830303000    <1> 	db	0FCh, 0CCh,  0Ch,  18h,  30h,  30h,  30h,  00h
  1813 00003C2E 78CCCC78CCCC7800    <1> 	db	 78h, 0CCh, 0CCh,  78h, 0CCh, 0CCh,  78h,  00h
  1814 00003C36 78CCCC7C0C187000    <1> 	db	 78h, 0CCh, 0CCh,  7Ch,  0Ch,  18h,  70h,  00h
  1815 00003C3E 0030300000303000    <1> 	db	 00h,  30h,  30h,  00h,  00h,  30h,  30h,  00h
  1816 00003C46 0030300000303060    <1> 	db	 00h,  30h,  30h,  00h,  00h,  30h,  30h,  60h
  1817 00003C4E 183060C060301800    <1> 	db	 18h,  30h,  60h, 0C0h,  60h,  30h,  18h,  00h
  1818 00003C56 0000FC0000FC0000    <1> 	db	 00h,  00h, 0FCh,  00h,  00h, 0FCh,  00h,  00h
  1819 00003C5E 6030180C18306000    <1> 	db	 60h,  30h,  18h,  0Ch,  18h,  30h,  60h,  00h
  1820 00003C66 78CC0C1830003000    <1> 	db	 78h, 0CCh,  0Ch,  18h,  30h,  00h,  30h,  00h
  1821 00003C6E 7CC6DEDEDEC07800    <1> 	db	 7Ch, 0C6h, 0DEh, 0DEh, 0DEh, 0C0h,  78h,  00h
  1822 00003C76 3078CCCCFCCCCC00    <1> 	db	 30h,  78h, 0CCh, 0CCh, 0FCh, 0CCh, 0CCh,  00h
  1823 00003C7E FC66667C6666FC00    <1> 	db	0FCh,  66h,  66h,  7Ch,  66h,  66h, 0FCh,  00h
  1824 00003C86 3C66C0C0C0663C00    <1> 	db	 3Ch,  66h, 0C0h, 0C0h, 0C0h,  66h,  3Ch,  00h
  1825 00003C8E F86C6666666CF800    <1> 	db	0F8h,  6Ch,  66h,  66h,  66h,  6Ch, 0F8h,  00h
  1826 00003C96 FE6268786862FE00    <1> 	db	0FEh,  62h,  68h,  78h,  68h,  62h, 0FEh,  00h
  1827 00003C9E FE6268786860F000    <1> 	db	0FEh,  62h,  68h,  78h,  68h,  60h, 0F0h,  00h
  1828 00003CA6 3C66C0C0CE663E00    <1> 	db	 3Ch,  66h, 0C0h, 0C0h, 0CEh,  66h,  3Eh,  00h
  1829 00003CAE CCCCCCFCCCCCCC00    <1> 	db	0CCh, 0CCh, 0CCh, 0FCh, 0CCh, 0CCh, 0CCh,  00h
  1830 00003CB6 7830303030307800    <1> 	db	 78h,  30h,  30h,  30h,  30h,  30h,  78h,  00h
  1831 00003CBE 1E0C0C0CCCCC7800    <1> 	db	 1Eh,  0Ch,  0Ch,  0Ch, 0CCh, 0CCh,  78h,  00h
  1832 00003CC6 E6666C786C66E600    <1> 	db	0E6h,  66h,  6Ch,  78h,  6Ch,  66h, 0E6h,  00h
  1833 00003CCE F06060606266FE00    <1> 	db	0F0h,  60h,  60h,  60h,  62h,  66h, 0FEh,  00h
  1834 00003CD6 C6EEFEFED6C6C600    <1> 	db	0C6h, 0EEh, 0FEh, 0FEh, 0D6h, 0C6h, 0C6h,  00h
  1835 00003CDE C6E6F6DECEC6C600    <1> 	db	0C6h, 0E6h, 0F6h, 0DEh, 0CEh, 0C6h, 0C6h,  00h
  1836 00003CE6 386CC6C6C66C3800    <1> 	db	 38h,  6Ch, 0C6h, 0C6h, 0C6h,  6Ch,  38h,  00h
  1837 00003CEE FC66667C6060F000    <1> 	db	0FCh,  66h,  66h,  7Ch,  60h,  60h, 0F0h,  00h
  1838 00003CF6 78CCCCCCDC781C00    <1> 	db	 78h, 0CCh, 0CCh, 0CCh, 0DCh,  78h,  1Ch,  00h
  1839 00003CFE FC66667C6C66E600    <1> 	db	0FCh,  66h,  66h,  7Ch,  6Ch,  66h, 0E6h,  00h
  1840 00003D06 78CCE0701CCC7800    <1> 	db	 78h, 0CCh, 0E0h,  70h,  1Ch, 0CCh,  78h,  00h
  1841 00003D0E FCB4303030307800    <1> 	db	0FCh, 0B4h,  30h,  30h,  30h,  30h,  78h,  00h
  1842 00003D16 CCCCCCCCCCCCFC00    <1> 	db	0CCh, 0CCh, 0CCh, 0CCh, 0CCh, 0CCh, 0FCh,  00h
  1843 00003D1E CCCCCCCCCC783000    <1> 	db	0CCh, 0CCh, 0CCh, 0CCh, 0CCh,  78h,  30h,  00h
  1844 00003D26 C6C6C6D6FEEEC600    <1> 	db	0C6h, 0C6h, 0C6h, 0D6h, 0FEh, 0EEh, 0C6h,  00h
  1845 00003D2E C6446C38386CC600    <1> 	db	0C6h,  44h,  6Ch,  38h,  38h,  6Ch, 0C6h,  00h
  1846 00003D36 CCCCCC7830307800    <1> 	db	0CCh, 0CCh, 0CCh,  78h,  30h,  30h,  78h,  00h
  1847 00003D3E FEC68C183266FE00    <1> 	db	0FEh, 0C6h,  8Ch,  18h,  32h,  66h, 0FEh,  00h
  1848 00003D46 7860606060607800    <1> 	db	 78h,  60h,  60h,  60h,  60h,  60h,  78h,  00h
  1849 00003D4E C06030180C060200    <1> 	db	0C0h,  60h,  30h,  18h,  0Ch,  06h,  02h,  00h
  1850 00003D56 7818181818187800    <1> 	db	 78h,  18h,  18h,  18h,  18h,  18h,  78h,  00h
  1851 00003D5E 10386CC600000000    <1> 	db	 10h,  38h,  6Ch, 0C6h,  00h,  00h,  00h,  00h
  1852 00003D66 00000000000000FF    <1> 	db	 00h,  00h,  00h,  00h,  00h,  00h,  00h, 0FFh
  1853 00003D6E 3030180000000000    <1> 	db	 30h,  30h,  18h,  00h,  00h,  00h,  00h,  00h
  1854 00003D76 0000780C7CCC7C00    <1> 	db	 00h,  00h,  78h,  0Ch,  7Ch, 0CCh,  7Ch,  00h
  1855 00003D7E 6060607C66667C00    <1> 	db	 60h,  60h,  60h,  7Ch,  66h,  66h,  7Ch,  00h
  1856 00003D86 000078CCC0CC7800    <1> 	db	 00h,  00h,  78h, 0CCh, 0C0h, 0CCh,  78h,  00h
  1857 00003D8E 0C0C0C7CCCCC7C00    <1> 	db	 0Ch,  0Ch,  0Ch,  7Ch, 0CCh, 0CCh,  7Ch,  00h
  1858 00003D96 000078CCFCC07800    <1> 	db	 00h,  00h,  78h, 0CCh, 0FCh, 0C0h,  78h,  00h
  1859 00003D9E 386C60F06060F000    <1> 	db	 38h,  6Ch,  60h, 0F0h,  60h,  60h, 0F0h,  00h
  1860 00003DA6 00007CCCCC7C0CF8    <1> 	db	 00h,  00h,  7Ch, 0CCh, 0CCh,  7Ch,  0Ch, 0F8h
  1861 00003DAE 60607C6666666600    <1> 	db	 60h,  60h,  7Ch,  66h,  66h,  66h,  66h,  00h
  1862 00003DB6 3000703030307800    <1> 	db	 30h,  00h,  70h,  30h,  30h,  30h,  78h,  00h
  1863 00003DBE 0C000C0C0C0C6C38    <1> 	db	 0Ch,  00h,  0Ch,  0Ch,  0Ch,  0Ch,  6Ch,  38h
  1864 00003DC6 6060666C786C6600    <1> 	db	 60h,  60h,  66h,  6Ch,  78h,  6Ch,  66h,  00h
  1865 00003DCE 7030303030307800    <1> 	db	 70h,  30h,  30h,  30h,  30h,  30h,  78h,  00h
  1866 00003DD6 0000CCFEFED6C600    <1> 	db	 00h,  00h, 0CCh, 0FEh, 0FEh, 0D6h, 0C6h,  00h
  1867 00003DDE 0000F8CCCCCCCC00    <1> 	db	 00h,  00h, 0F8h, 0CCh, 0CCh, 0CCh, 0CCh,  00h
  1868 00003DE6 000078CCCCCC7800    <1> 	db	 00h,  00h,  78h, 0CCh, 0CCh, 0CCh,  78h,  00h
  1869 00003DEE 00007C66667C6060    <1> 	db	 00h,  00h,  7Ch,  66h,  66h,  7Ch,  60h,  60h
  1870 00003DF6 00007CCCCC7C0C0C    <1> 	db	 00h,  00h,  7Ch, 0CCh, 0CCh,  7Ch,  0Ch,  0Ch
  1871 00003DFE 0000DC766660F000    <1> 	db	 00h,  00h, 0DCh,  76h,  66h,  60h, 0F0h,  00h
  1872 00003E06 00007CC0780CF800    <1> 	db	 00h,  00h,  7Ch, 0C0h,  78h,  0Ch, 0F8h,  00h
  1873 00003E0E 10307C3030341800    <1> 	db	 10h,  30h,  7Ch,  30h,  30h,  34h,  18h,  00h
  1874 00003E16 0000CCCCCCCC7C00    <1> 	db	 00h,  00h, 0CCh, 0CCh, 0CCh, 0CCh,  7Ch,  00h
  1875 00003E1E 0000CCCCCC783000    <1> 	db	 00h,  00h, 0CCh, 0CCh, 0CCh,  78h,  30h,  00h
  1876 00003E26 0000C6D6FEFE6C00    <1> 	db	 00h,  00h, 0C6h, 0D6h, 0FEh, 0FEh,  6Ch,  00h
  1877 00003E2E 0000C66C386CC600    <1> 	db	 00h,  00h, 0C6h,  6Ch,  38h,  6Ch, 0C6h,  00h
  1878 00003E36 0000CCCCCC7C0CF8    <1> 	db	 00h,  00h, 0CCh, 0CCh, 0CCh,  7Ch,  0Ch, 0F8h
  1879 00003E3E 0000FC983064FC00    <1> 	db	 00h,  00h, 0FCh,  98h,  30h,  64h, 0FCh,  00h
  1880 00003E46 1C3030E030301C00    <1> 	db	 1Ch,  30h,  30h, 0E0h,  30h,  30h,  1Ch,  00h
  1881 00003E4E 1818180018181800    <1> 	db	 18h,  18h,  18h,  00h,  18h,  18h,  18h,  00h
  1882 00003E56 E030301C3030E000    <1> 	db	0E0h,  30h,  30h,  1Ch,  30h,  30h, 0E0h,  00h
  1883 00003E5E 76DC000000000000    <1> 	db	 76h, 0DCh,  00h,  00h,  00h,  00h,  00h,  00h
  1884 00003E66 0010386CC6C6FE00    <1> 	db	 00h,  10h,  38h,  6Ch, 0C6h, 0C6h, 0FEh,  00h
  1732                                  %include	"time2.inc"
  1733                              <1> ;=========================================================================
  1734                              <1> ; time2.int - BIOS Time Services
  1735                              <1> ;       INT 1Ah - BIOS Time Serivces
  1736                              <1> ;		dispatcher
  1737                              <1> ;       INT 08h - IRQ0 interrupt handler (timer interrupt)
  1738                              <1> ;-------------------------------------------------------------------------
  1739                              <1> ;
  1740                              <1> ; Compiles with NASM 2.13.02, might work with other versions
  1741                              <1> ;
  1742                              <1> ; Copyright (C) 2010 - 2023 Sergey Kiselev.
  1743                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
  1744                              <1> ;
  1745                              <1> ; This program is free software: you can redistribute it and/or modify
  1746                              <1> ; it under the terms of the GNU General Public License as published by
  1747                              <1> ; the Free Software Foundation, either version 3 of the License, or
  1748                              <1> ; (at your option) any later version.
  1749                              <1> ;
  1750                              <1> ; This program is distributed in the hope that it will be useful,
  1751                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  1752                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  1753                              <1> ; GNU General Public License for more details.
  1754                              <1> ;
  1755                              <1> ; You should have received a copy of the GNU General Public License
  1756                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  1757                              <1> ;
  1758                              <1> ;=========================================================================
  1759                              <1> 
  1760                              <1> ;=========================================================================
  1761                              <1> ; int_1A - BIOS Time Services
  1762                              <1> ; Note: see time1.inc for functions implementation
  1763                              <1> ;-------------------------------------------------------------------------
  1764                              <1> 	setloc	0FE6Eh			; INT 1A Entry Point
  1765                              <1> int_1A:
  1766 00003E6E 53                  <1> 	push	bx
  1767 00003E6F 1E                  <1> 	push	ds
  1768 00003E70 BB4000              <1> 	mov	bx,biosdseg
  1769 00003E73 8EDB                <1> 	mov	ds,bx
  1770 00003E75 80FC02              <1> 	cmp	ah,.max/2
  1771 00003E78 730F                <1> 	jae	int_1A_exit
  1772 00003E7A B700                <1> 	mov	bh,0
  1773 00003E7C 88E3                <1> 	mov	bl,ah
  1774 00003E7E D1E3                <1> 	shl	bx,1
  1775 00003E80 2EFFA7[853E]        <1>     cs	jmp	near [.dispatch+bx]
  1776                              <1> .dispatch:
  1777 00003E85 [1108]              <1> 	dw	int_1A_fn00
  1778 00003E87 [2308]              <1> 	dw	int_1A_fn01
  1779                              <1> %ifdef AT_RTC
  1780                              <1> 	dw	int_1A_fn02
  1781                              <1> 	dw	int_1A_fn03
  1782                              <1> 	dw	int_1A_fn04
  1783                              <1> 	dw	int_1A_fn05
  1784                              <1> 	dw	int_1A_fn06
  1785                              <1> 	dw	int_1A_fn07
  1786                              <1> %endif ; AT_RTC
  1787                              <1> .max	equ	$-.dispatch
  1788                              <1> int_1A_exit:
  1789 00003E89 1F                  <1> 	pop	ds
  1790 00003E8A 5B                  <1> 	pop	bx
  1791 00003E8B CF                  <1> 	iret
  1792                              <1> int_1A_exitf:
  1793 00003E8C 1F                  <1> 	pop	ds
  1794 00003E8D 5B                  <1> 	pop	bx
  1795 00003E8E CA0200              <1> 	retf	2
  1796                              <1> 
  1797                              <1> ;=========================================================================
  1798                              <1> ; int_08 - IRQ0 ISR, called approximately every 55ms
  1799                              <1> ;-------------------------------------------------------------------------
  1800 00003E91 FF<rep 14h>         <1> 	setloc	0FEA5h			; INT 08 Entry Point
  1800          ******************  <1>  warning: Inserting 20 bytes [-w+user]
  1801                              <1> int_08:
  1802 00003EA5 50                  <1> 	push	ax
  1803 00003EA6 1E                  <1> 	push	ds
  1804 00003EA7 B84000              <1> 	mov	ax,biosdseg
  1805 00003EAA 8ED8                <1> 	mov	ds,ax
  1806 00003EAC 803E400000          <1> 	cmp	byte [fdc_motor_tout],0
  1807 00003EB1 7413                <1> 	jz	.1
  1808 00003EB3 FE0E4000            <1> 	dec	byte [fdc_motor_tout]
  1809 00003EB7 750D                <1> 	jnz	.1
  1810 00003EB9 80263F00F0          <1> 	and	byte [fdc_motor_state],0F0h ; update fdc_motor_state byte
  1811 00003EBE B00C                <1> 	mov	al,0Ch			; turn off motors, enable DMA + IRQ
  1812 00003EC0 52                  <1> 	push	dx
  1813 00003EC1 BAF203              <1> 	mov	dx,fdc_dor_reg		; write it to Digital Output register
  1814 00003EC4 EE                  <1> 	out	dx,al
  1815 00003EC5 5A                  <1> 	pop	dx
  1816                              <1> .1:
  1817 00003EC6 FF066C00            <1> 	inc	word [ticks_lo]
  1818 00003ECA 7504                <1> 	jnz	.2
  1819 00003ECC FF066E00            <1> 	inc	word [ticks_hi]
  1820                              <1> .2:
  1821 00003ED0 833E6E0018          <1> 	cmp	word [ticks_hi],18h	; 1573042 ticks in one day
  1822 00003ED5 7519                <1> 	jnz	.3			; which is 65536 * 24 + 178 or
  1823 00003ED7 813E6C00B200        <1> 	cmp	word [ticks_lo],0B2h	; 10000h * 18h + 0B2h
  1824 00003EDD 7511                <1> 	jnz	.3
  1825 00003EDF C7066E000000        <1> 	mov	word [ticks_hi],0
  1826 00003EE5 C7066C000000        <1> 	mov	word [ticks_lo],0
  1827 00003EEB C606700001          <1> 	mov	byte [new_day],1
  1828                              <1> .3:
  1829 00003EF0 CD1C                <1> 	int	1Ch			; User timer interrupt
  1830 00003EF2 B020                <1> 	mov	al,20h
  1831 00003EF4 E620                <1> 	out	pic1_reg0,al
  1832 00003EF6 1F                  <1> 	pop	ds
  1833 00003EF7 58                  <1> 	pop	ax
  1834 00003EF8 CF                  <1> 	iret
  1733                                  
  1734                                  ;=========================================================================
  1735                                  ; int_ignore - signal end of interrupt to PIC if hardware interrupt, return
  1736                                  ;-------------------------------------------------------------------------
  1737 00003EF9 FF<rep 2Ah>             	setloc	0FF23h			; Spurious IRQ Handler Entry Point
  1737          ******************       warning: Inserting 42 bytes [-w+user]
  1738                                  int_ignore:
  1739 00003F23 50                      	push	ax
  1740 00003F24 1E                      	push	ds
  1741 00003F25 B84000                  	mov	ax,biosdseg
  1742 00003F28 8ED8                    	mov	ds,ax
  1743 00003F2A B00B                    	mov	al,0Bh			; PIC OCW3 - read in-service register
  1744 00003F2C E620                    	out	pic1_reg0,al
  1745 00003F2E 90                      	nop
  1746 00003F2F E420                    	in	al,pic1_reg0		; get IRQ number
  1747 00003F31 88C4                    	mov	ah,al
  1748 00003F33 08C0                    	or	al,al
  1749 00003F35 7504                    	jnz	.1
  1750 00003F37 B4FF                    	mov	ah,0FFh
  1751 00003F39 EB0A                    	jmp	.2
  1752                                  .1:
  1753 00003F3B E421                    	in	al,pic1_reg1		; clear the interrupt
  1754 00003F3D 08E0                    	or	al,ah
  1755 00003F3F E621                    	out	pic1_reg1,al
  1756 00003F41 B020                    	mov	al,20h			; end of interrupt
  1757 00003F43 E620                    	out	pic1_reg0,al		; signal end of interrupt
  1758                                  .2:
  1759 00003F45 88266B00                	mov	byte [last_irq],ah
  1760 00003F49 1F                      	pop	ds
  1761 00003F4A 58                      	pop	ax
  1762 00003F4B CF                      	iret
  1763                                  
  1764                                  ;=========================================================================
  1765                                  ; int_dummy - Dummy interrupt handler. Do nothing, return.
  1766                                  ;-------------------------------------------------------------------------
  1767 00003F4C FF<rep 7h>              	setloc	0FF53h			; Dummy Interrupt Handler
  1767          ******************       warning: Inserting 7 bytes [-w+user]
  1768                                  int_dummy:
  1769 00003F53 CF                      	iret
  1770                                  
  1771                                  ;=========================================================================
  1772                                  ; int_05 - BIOS Print Screen
  1773                                  ;-------------------------------------------------------------------------
  1774                                  	setloc	0FF54h			; INT 05 (Print Screen) Entry Point
  1775                                  int_05:
  1776 00003F54 FB                      	sti
  1777 00003F55 50                      	push	ax
  1778 00003F56 53                      	push	bx
  1779 00003F57 51                      	push	cx
  1780 00003F58 52                      	push	dx
  1781 00003F59 1E                      	push	ds
  1782 00003F5A B84000                  	mov	ax,biosdseg
  1783 00003F5D 8ED8                    	mov	ds,ax			; DS = BIOS data segment
  1784 00003F5F 803E000101              	cmp	byte [prt_scrn_flags],prt_scrn_run
  1785 00003F64 746A                    	je	.exit			; print screen is already in progress
  1786 00003F66 C606000101              	mov	byte [prt_scrn_flags],prt_scrn_run
  1787                                  					; signal that print screen is running
  1788                                  
  1789 00003F6B B40F                    	mov	ah,0Fh			; get video mode parameters
  1790 00003F6D CD10                    	int	10h			; returns number of columns in AH
  1791                                  					; and active display page in BH
  1792 00003F6F 88E1                    	mov	cl,ah			; store number columns
  1793                                  
  1794 00003F71 8A2E8400                	mov	ch,byte [video_rows]	; try getting number of rows
  1795 00003F75 08ED                    	or	ch,ch
  1796 00003F77 7407                    	jz	.wrong_num_rows		; CH == 0, apparently not initialized
  1797                                  
  1798 00003F79 FEC5                    	inc	ch			; CH = number of rows (on EGA/VGA)
  1799 00003F7B 80FD3C                  	cmp	ch,60			; 60 rows maximum (as far as I know)
  1800 00003F7E 7602                    	jbe	.get_cursor_pos
  1801                                  
  1802                                  .wrong_num_rows:
  1803 00003F80 B519                    	mov	ch,25			; assume 25 rows
  1804                                  
  1805                                  .get_cursor_pos:
  1806 00003F82 B403                    	mov	ah,03h			; get cursor position and size
  1807 00003F84 CD10                    	int	10h			; returns cursor position in DX
  1808 00003F86 52                      	push	dx			; save original position / DX in stack
  1809                                  
  1810                                  	
  1811 00003F87 B40D                    	mov	ah,0Dh			; move to the next line
  1812 00003F89 E85100                  	call	.print_char
  1813 00003F8C 7548                    	jnz	.error
  1814 00003F8E B40A                    	mov	ah,0Ah
  1815 00003F90 E84A00                  	call	.print_char
  1816 00003F93 7541                    	jnz	.error
  1817                                  
  1818 00003F95 B600                    	mov 	dh,0			; start from the first row (0)
  1819                                  
  1820                                  .row_loop:
  1821 00003F97 B200                    	mov 	dl,0			; start from the first column (0)
  1822                                  
  1823                                  .column_loop:
  1824 00003F99 B402                    	mov	ah,02h
  1825 00003F9B CD10                    	int	10h			; set cursor position (position in DX)
  1826                                  
  1827 00003F9D B408                    	mov	ah,08h
  1828 00003F9F CD10                    	int	10h			; read character at cursor position
  1829                                  
  1830 00003FA1 3C20                    	cmp	al,20h			; control character?
  1831 00003FA3 7302                    	jae	.continue		; no, print it
  1832 00003FA5 B020                    	mov	al,20h			; print space instead
  1833                                  
  1834                                  .continue:
  1835 00003FA7 E83300                  	call	.print_char
  1836 00003FAA 752A                    	jnz	.error
  1837 00003FAC FEC2                    	inc	dl
  1838 00003FAE 38CA                    	cmp	dl,cl			; on the last column?
  1839 00003FB0 72E7                    	jb	.column_loop		; print next column
  1840                                  
  1841 00003FB2 B40D                    	mov	ah,0Dh			; move to the next line
  1842 00003FB4 E82600                  	call	.print_char
  1843 00003FB7 751D                    	jnz	.error
  1844 00003FB9 B40A                    	mov	ah,0Ah
  1845 00003FBB E81F00                  	call	.print_char
  1846 00003FBE 7516                    	jnz	.error
  1847                                  
  1848 00003FC0 FEC6                    	inc	dh
  1849 00003FC2 38EE                    	cmp	dh,ch			; on the last row?
  1850 00003FC4 72D1                    	jb	.row_loop		; print next row
  1851                                  
  1852 00003FC6 C606000100              	mov	byte [prt_scrn_flags],prt_scrn_ready
  1853                                  					; ready for the next call
  1854                                  
  1855                                  .restore_cursor:
  1856 00003FCB 5A                      	pop	dx			; DX = original cursor position
  1857 00003FCC B402                    	mov	ah,02h
  1858 00003FCE CD10                    	int	10h			; set cursor position (position in DX)
  1859                                  
  1860                                  .exit:
  1861 00003FD0 1F                      	pop	ds
  1862 00003FD1 5A                      	pop	dx
  1863 00003FD2 59                      	pop	cx
  1864 00003FD3 5B                      	pop	bx
  1865 00003FD4 58                      	pop	ax
  1866 00003FD5 CF                      	iret
  1867                                  
  1868                                  .error:
  1869 00003FD6 C6060001FF              	mov	byte [prt_scrn_flags],prt_scrn_fail
  1870                                  					; signal failure
  1871 00003FDB EBEE                    	jmp	.restore_cursor
  1872                                  	
  1873                                  
  1874                                  .print_char:
  1875 00003FDD 52                      	push	dx
  1876 00003FDE 31D2                    	xor	dx,dx			; DX = 0 - first printer port
  1877 00003FE0 B400                    	mov	ah,00h			; INT 17h, AH=10h - print character
  1878 00003FE2 CD17                    	int	17h
  1879 00003FE4 5A                      	pop	dx
  1880 00003FE5 F6C425                  	test	ah,25h			; ZF = 0 - no error
  1881 00003FE8 C3                      	ret
  1882                                  
  1883                                  ;=========================================================================
  1884                                  ; start - at power up or reset execution starts here (F000:FFF0)
  1885                                  ;-------------------------------------------------------------------------
  1886 00003FE9 FF<rep 7h>                      setloc	0FFF0h			; Power-On Entry Point
  1886          ******************       warning: Inserting 7 bytes [-w+user]
  1887                                  start:
  1888 00003FF0 EA[5B20]00F0                    jmp     bioscseg:cold_start
  1889                                  
  1890                                  	setloc	0FFF5h			; ROM Date in ASCII
  1891 00003FF5 30362F32312F3233        	db	DATE			; BIOS release date MM/DD/YY
  1892 00003FFD 20                      	db	20h
  1893                                  
  1894                                  	setloc	0FFFEh			; System Model byte
  1895 00003FFE FE                      	db	MODEL_BYTE
  1896 00003FFF FF                      	db	0ffh
