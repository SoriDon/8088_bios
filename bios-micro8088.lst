     1                                  ;=========================================================================
     2                                  ; main.asm - BIOS main file
     3                                  ;	Skeleton for the BIOS
     4                                  ;	Power On Self Test (POST)
     5                                  ;	Interrupt table setup
     6                                  ;       INT 11h - Get equipment list
     7                                  ;       INT 12h - Get memory size
     8                                  ;-------------------------------------------------------------------------
     9                                  ;
    10                                  ; Compiles with NASM 2.13.02, might work with other versions
    11                                  ;
    12                                  ; Copyright (C) 2010 - 2023 Sergey Kiselev.
    13                                  ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
    14                                  ;
    15                                  ; This program is free software: you can redistribute it and/or modify
    16                                  ; it under the terms of the GNU General Public License as published by
    17                                  ; the Free Software Foundation, either version 3 of the License, or
    18                                  ; (at your option) any later version.
    19                                  ;
    20                                  ; This program is distributed in the hope that it will be useful,
    21                                  ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    22                                  ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    23                                  ; GNU General Public License for more details.
    24                                  ;
    25                                  ; You should have received a copy of the GNU General Public License
    26                                  ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    27                                  ;
    28                                  ;=========================================================================
    29                                  
    30                                  ;-------------------------------------------------------------------------
    31                                  ; Fixed BIOS Entry Points
    32                                  ; Source:
    33                                  ;	Intel(R) Platform Innovation Framework for EFI
    34                                  ;	Compatibility Support Module Specification
    35                                  ;	Section 5.2
    36                                  ;
    37                                  ;	Location	Description
    38                                  ;	--------	-----------
    39                                  ;	F000:E05B	POST Entry Point
    40                                  ;	F000:E2C3	NMI Entry Point
    41                                  ;	F000:E401	HDD Parameter Table
    42                                  ;	F000:E6F2	INT 19 Entry Point
    43                                  ;	F000:E6F5	Configuration Data Table
    44                                  ;	F000:E729	Baut Rate Generator Table
    45                                  ;	F000:E739	INT 14 Entry Point
    46                                  ;	F000:E82E	INT 16 Entry Point
    47                                  ;	F000:E987	INT 09 Entry Point
    48                                  ;	F000:EC59	INT 13 (Floppy) Entry Point
    49                                  ;	F000:EF57	INT 0E Entry Point
    50                                  ;	F000:EFC7	Floppy Disk Controller Parameter Table
    51                                  ;	F000:EFD2	INT 17
    52                                  ;	F000:F065	INT 10 (Video) Entry Point
    53                                  ;	F000:F0A4	INT 1D MDA and CGA Video Parameter Table
    54                                  ;	F000:F841	INT 12 Entry Point
    55                                  ;	F000:F84D	INT 11 Entry Point
    56                                  ;	F000:F859	INT 15 Entry Point
    57                                  ;	F000:FA6E	Low 128 Characters of Graphic Video Font
    58                                  ;	F000:FE6E	INT 1A Entry Point
    59                                  ;	F000:FEA5	INT 08 Entry Point
    60                                  ;	F000:FF53	Dummy Interrupt Handler (IRET)
    61                                  ;	F000:FF54	INT 05 (Print Screen) Entry Point
    62                                  ;	F000:FFF0	Power-On Entry Point
    63                                  ;	F000:FFF5	ROM Date in ASCII "MM/DD/YY" Format (8 Characters)
    64                                  ;	F000:FFFE	System Model (0xFC - AT, 0xFE - XT)
    65                                  
    66                                  	cpu	8086
    67                                  
    68                                  %include "macro.inc"
    69                              <1> ;=========================================================================
    70                              <1> ; macro.inc - Defines macros
    71                              <1> ;       setloc
    72                              <1> ;-------------------------------------------------------------------------
    73                              <1> ;
    74                              <1> ; Compiles with NASM 2.13.02, might work with other versions
    75                              <1> ;
    76                              <1> ; Copyright (C) 2010 - 2023 Sergey Kiselev.
    77                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
    78                              <1> ;
    79                              <1> ; This program is free software: you can redistribute it and/or modify
    80                              <1> ; it under the terms of the GNU General Public License as published by
    81                              <1> ; the Free Software Foundation, either version 3 of the License, or
    82                              <1> ; (at your option) any later version.
    83                              <1> ;
    84                              <1> ; This program is distributed in the hope that it will be useful,
    85                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    86                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    87                              <1> ; GNU General Public License for more details.
    88                              <1> ;
    89                              <1> ; You should have received a copy of the GNU General Public License
    90                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    91                              <1> ;
    92                              <1> ;=========================================================================
    93                              <1> 
    94                              <1> ;=========================================================================
    95                              <1> ; setloc - Set location. Insert 0FFh bytes until specifed location is reached.
    96                              <1> ;-------------------------------------------------------------------------
    97                              <1> %imacro setloc  1.nolist
    98                              <1> %assign pad_bytes (%1-($-$$)-START)
    99                              <1> %if pad_bytes < 0
   100                              <1> %assign over_bytes -pad_bytes
   101                              <1> %error Preceding code extends beyond setloc location by over_bytes bytes
   102                              <1> %endif
   103                              <1> %if pad_bytes > 0
   104                              <1> %warning Inserting pad_bytes bytes
   105                              <1>  times  pad_bytes db 0FFh
   106                              <1> %endif
   107                              <1> %endm
    69                                  %include "config.inc"
    70                              <1> ;=========================================================================
    71                              <1> ; config.inc - Compilation time settings and settings
    72                              <1> ;-------------------------------------------------------------------------
    73                              <1> ;
    74                              <1> ; Compiles with NASM 2.13.02, might work with other versions
    75                              <1> ;
    76                              <1> ; Copyright (C) 2010 - 2023 Sergey Kiselev.
    77                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
    78                              <1> ;
    79                              <1> ; This program is free software: you can redistribute it and/or modify
    80                              <1> ; it under the terms of the GNU General Public License as published by
    81                              <1> ; the Free Software Foundation, either version 3 of the License, or
    82                              <1> ; (at your option) any later version.
    83                              <1> ;
    84                              <1> ; This program is distributed in the hope that it will be useful,
    85                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    86                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    87                              <1> ; GNU General Public License for more details.
    88                              <1> ;
    89                              <1> ; You should have received a copy of the GNU General Public License
    90                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    91                              <1> ;
    92                              <1> ;=========================================================================
    93                              <1> 
    94                              <1> %define DATE		'06/26/23'	; BIOS release date MM/DD/YY
    95                              <1> %define VERSION		'1.0.0'		; BIOS version
    96                              <1> 
    97                              <1> ; Machine type is defined in the Makefile
    98                              <1> ;%define MACHINE_XI8088			; Xi 8088
    99                              <1> ;%define MACHINE_FE2010A 		; Faraday FE2010A
   100                              <1> ;%define MACHINE_BOOK8088		; Book8088
   101                              <1> ;%define MACHINE_XT			; IBM PC/XT or highly compatible board
   102                              <1> 					; FIXME: not implemented yet
   103                              <1> 
   104                              <1> ; Settings for Xi 8088
   105                              <1> %ifdef MACHINE_XI8088
   106                              <1> %define	START		8000h		; BIOS starts at offset 8000h
   107                              <1> %define MODEL_BYTE	0FCh		; Pretend it is an IBM PC/AT
   108                              <1> %define AT_RTC				; Has AT-compatible RTC
   109                              <1> %define AT_RTC_NVRAM			; Use AT RTC for BIOS configuration
   110                              <1> %define AT_NMI				; Use port 70h for NMI enable/disable
   111                              <1> %define AT_DELAY			; Use refresh bit of port 61h for delays
   112                              <1> %define SECOND_PIC			; Has two PICs (AT-style)
   113                              <1> %define AT_KEYBOARD			; Has AT-compatible keyboard controller
   114                              <1> %define PS2_MOUSE			; Enable PS/2 auxiliary device support
   115                              <1> %define DISABLE_KBD_DURING_INTERRUPTS	; Don't disable keyboard in INT1
   116                              <1> %define MIN_RAM_SIZE	32		; At least 32 KiB to boot the system
   117                              <1> %define MAX_RAM_SIZE	640		; Scan this much memory during POST
   118                              <1> %define RAM_TEST_BLOCK	16384		; block size for RAM test
   119                              <1> %define EBDA_SIZE	1		; 1KB reserved for EBDA
   120                              <1> 					; EBDA is required for PS/2 aux support
   121                              <1> %endif ; MACHINE_XI8088
   122                              <1> 
   123                              <1> ; Settings for FE2010A
   124                              <1> %ifdef MACHINE_FE2010A
   125                              <1> %define	START		0A000h		; BIOS starts at offset 0A000h
   126                              <1> %define MODEL_BYTE	0FEh		; IBM PC/XT
   127                              <1> %define AT_RTC				; Has AT-compatible RTC
   128                              <1> %define AT_RTC_AUTODETECT		; Autodetect RTC presence
   129                              <1> %define FLASH_NVRAM			; Use Flash ROM for BIOS configuration
   130                              <1> %define MIN_RAM_SIZE	32		; At least 32 KiB to boot the system
   131                              <1> %define MAX_RAM_SIZE	640		; Scan this much memory during POST
   132                              <1> %define RAM_TEST_BLOCK	16384		; block size for RAM test
   133                              <1> %endif ; MACHINE_FE2010A
   134                              <1> 
   135                              <1> ; Settings for Book8088
   136                              <1> %ifdef MACHINE_BOOK8088
   137                              <1> %define	START		0C000h		; BIOS starts at 0C000h - 16 KiB total
   138                              <1> %define MODEL_BYTE	0FEh		; IBM PC/XT
   139                              <1> %define MIN_RAM_SIZE	32		; At least 32 KiB to boot the system
   140                              <1> %define MAX_RAM_SIZE	640		; Scan this much memory during POST
   141                              <1> %define RAM_TEST_BLOCK	16384		; block size for RAM test
   142                              <1> %endif ; MACHINE_BOOK8088
   143                              <1> 
   144                              <1> ; Settings for IBM PC/XT
   145                              <1> %ifdef MACHINE_XT
   146                              <1> ;%define	START		0E000h		; BIOS starts at offset 0E000h
   147                              <1> %define	START		0C000h		; FIXME: more ROM for development
   148                              <1> %define MODEL_BYTE	0FEh		; IBM PC/XT
   149                              <1> %define MIN_RAM_SIZE	32		; At least 32 KiB to boot the system
   150                              <1> %define MAX_RAM_SIZE	640		; Scan this much memory during POST
   151                              <1> %define RAM_TEST_BLOCK	16384		; block size for RAM test
   152                              <1> %endif ; MACHINE_XT
   153                              <1> 
   154                              <1> ; Automatic settings based on the machine settings above
   155                              <1> %ifdef AT_RTC or AT_RTC_NVRAM or FLASH_NVRAM
   156                              <1> %define BIOS_SETUP			; Include BIOS setup utility
   157                              <1> %endif ; AT_RTC or AT_RTC_NVRAM or FLASH_NVRAM
   158                              <1> 
   159                              <1> ; Note: while Book8088 does have a turbo mode, it is not software controlled
   160                              <1> %ifdef MACHINE_XI8088 or MACHINE_FE2010A
   161                              <1> %define TURBO_MODE			; Has turbo mode
   162                              <1> %endif ; MACHINE_XI8088 or MACHINE_FE2010A
   163                              <1> 
    70                                  %include "errno.inc"
    71                              <1> ;=========================================================================
    72                              <1> ; errno.inc - POST checkpoint codes (sent to port 80h during POST)
    73                              <1> ;-------------------------------------------------------------------------
    74                              <1> ;
    75                              <1> ; Compiles with NASM 2.13.02, might work with other versions
    76                              <1> ;
    77                              <1> ; Copyright (C) 2010 - 2023 Sergey Kiselev.
    78                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
    79                              <1> ;
    80                              <1> ; This program is free software: you can redistribute it and/or modify
    81                              <1> ; it under the terms of the GNU General Public License as published by
    82                              <1> ; the Free Software Foundation, either version 3 of the License, or
    83                              <1> ; (at your option) any later version.
    84                              <1> ;
    85                              <1> ; This program is distributed in the hope that it will be useful,
    86                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
    87                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    88                              <1> ; GNU General Public License for more details.
    89                              <1> ;
    90                              <1> ; You should have received a copy of the GNU General Public License
    91                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
    92                              <1> ;
    93                              <1> ;=========================================================================
    94                              <1> 
    95                              <1> e_boot		equ	00h		; Boot the OS
    96                              <1> e_cpu_test	equ	01h		; Start of BIOS POST, CPU test
    97                              <1> e_init_cfg	equ	02h		; Initial chipset configuration:
    98                              <1> 					; initialize PPI, disable NMI
    99                              <1> 					; disable turbo mode, disable display
   100                              <1> e_init_dmac	equ	03h		; Initialize DMAC initialized
   101                              <1> e_low_ram_test	equ	04h		; Test low 32 KiB of RAM
   102                              <1> e_int_table	equ	05h		; Initialize interrupt table
   103                              <1> e_pit_init	equ	06h		; Initialize PIT (timer)
   104                              <1> 					; play power on melody
   105                              <1> e_pic_init	equ	07h		; Initialize PIC
   106                              <1> e_kbd_init	equ	08h		; Initialize KBC and keyboard
   107                              <1> e_int_ena	equ	09h		; Enable interrupts
   108                              <1> e_vid_bios_scan	equ	10h		; Locate video BIOS
   109                              <1> e_vid_bios_init	equ	11h		; Initialize video BIOS
   110                              <1> e_vid_no_bios	equ	12h		; No video BIOS, using MDA/CGA
   111                              <1> e_rtc_init	equ	20h		; Initialize RTC
   112                              <1> e_cpu_detect	equ	21h		; Detect CPU type
   113                              <1> e_fpu_detect	equ	22h		; Detect FPU
   114                              <1> e_serial_scan	equ	24h		; Detect serial ports
   115                              <1> e_parallel_scan	equ	25h		; Detect parallel ports
   116                              <1> e_ram_start	equ	30h		; Start RAM test
   117                              <1> e_ram_complete	equ	31h		; RAM test completed
   118                              <1> e_ram_esc	equ	32h		; RAM test canceled
   119                              <1> e_ext_start	equ	40h		; Start BIOS extension ROM scan
   120                              <1> e_ext_detect	equ	41h		; BIOS extension ROM found, initizalize
   121                              <1> e_ext_init_ok	equ	42h		; BIOS extension ROM initialized
   122                              <1> e_ext_complete	equ	43h		; BIOS extension scan complete
   123                              <1> e_cpu_fail	equ	52h		; CPU test failed
   124                              <1> e_low_ram_fail	equ	54h		; Low 32 KiB RAM test failed
   125                              <1> e_ram_fail	equ	55h		; RAM test failed
   126                              <1> e_kbc_flsh_fail	equ	60h		; Unable to flush KBC output buffer
   127                              <1> e_kbc_cmd_fail	equ	61h		; Unable to send command to KBC
   128                              <1> e_kbc_test_fail	equ	62h		; Keyboard controller self test failed
   129                              <1> e_kbc_int_fail	equ	63h		; Keyboard interface test failed
   130                              <1> e_kbd_bat_fail	equ	70h		; Keyboard BAT test failed
   131                              <1> e_kbd_dis_fail	equ	71h		; Keyboard disable command failed
   132                              <1> e_kbd_ena_fail	equ	72h		; Keyboard enable command failed
   133                              <1> ;-------------------------------------------------------------------------
   134                              <1> ; Minor numbers for keyboard errors
   135                              <1> e_kbd_tout_fail	equ	01h		; Keyboard timeout sending command
   136                              <1> e_kbd_resp_fail	equ	02h		; Keyboard no response
   137                              <1> e_kbd_nack_fail	equ	03h		; Acknowledge response was expected
   138                              <1> 					; but keyboard have sent something else
   139                              <1> e_kbd_rsp2_fail	equ	04h		; Keyboard no response byte 2 for BAT
   140                              <1> e_kbd_nbat_fail	equ	05h		; BAT OK response was expected
   141                              <1> 					; but keyboard have sent something else
   142                              <1> e_kbd_test_fail	equ	06h		; Keyboard controller test failed
   143                              <1> e_kbd_int_fail	equ	07h		; Keyboard interface test failed
    71                                  
    72                                  bioscseg	equ	0F000h
    73                                  biosdseg	equ	0040h
    74                                  
    75                                  pic1_reg0	equ	20h
    76                                  pic1_reg1	equ	21h
    77                                  pit_ch0_reg	equ	40h
    78                                  pit_ch1_reg	equ	41h
    79                                  pit_ch2_reg	equ	42h
    80                                  pit_ctl_reg	equ	43h
    81                                  
    82                                  ; 8255 PPI port A I/O register - Read - keyboard data
    83                                  ppi_pa_reg	equ	60h	; 8255 PPI port A I/O register
    84                                  
    85                                  ; Port 61h - 8255 PPI Port B - Write only
    86                                  ppi_pb_reg	equ	61h	; 8255 PPI port B I/O register
    87                                  iochk_disable	equ	08h	; clear and disable ~IOCHK NMI
    88                                  refresh_flag	equ	10h	; refresh flag, toggles every 15us
    89                                  iochk_enable	equ	0F7h	; enable ~IOCHK NMI
    90                                  iochk_status	equ	40h	; ~IOCHK status - 1 = ~IOCHK NMI signalled
    91                                  
    92                                  %ifdef MACHINE_XT or MACHINE_FE2010A
    93                                  ; Port 62h - 8255 PPI Port C - Read only
    94                                  ppi_pc_reg	equ	62h	; 8255 PPI port C I/O registerA
    95                                  ; XT DIP switches 1-4 (read when bit 3 of PPI Port B is 1)
    96                                  sw_post_loop	equ	01h	; XT DIP switch 1 - 1 = Loop on POST
    97                                  sw_fpu_present	equ	02h	; XT DIP switch 2 - 1 = FPU present
    98                                  sw_ram_256k	equ	00h	; XT DIP switches 3-4 - 256 KiB
    99                                  sw_ram_512k	equ	04h	; XT DIP switches 3-4 - 512 KiB
   100                                  sw_ram_576k	equ	08h	; XT DIP switches 3-4 - 576 KiB
   101                                  sw_ram_640k	equ	0Ch	; XT DIP switches 3-4 - 640 KiB
   102                                  ; XT DIP switches 5-8 (read when bit 3 of PPI Port B is 0)
   103                                  sw_vid_none	equ	00h	; XT DIP switches 5-6 - No video, EGA, or VGA
   104                                  sw_vid_color_40	equ	01h	; XT DIP switches 5-6 - CGA, 80x25
   105                                  sw_vid_color_80	equ	02h	; XT DIP switches 5-6 - CGA, 40x25
   106                                  sw_vid_mono	equ	03h	; XT DIP switches 5-6 - Monochome, 80x25
   107                                  sw_one_floppy	equ	00h	; XT DIP switches 7-8 - One floppy
   108                                  sw_two_floppies	equ	01h	; XT DIP switches 7-8 - Two floppies
   109                                  sw_three_floppies equ	02h	; XT DIP switches 7-8 - Three floppies
   110                                  sw_four_floppies  equ	03h	; XT DIP switches 7-8 - Four floppies
   111                                  %endif ; MACHINE_XT or MACHINE_FE2010A
   112                                  
   113                                  ; FE2010/FE2010 - Ports 62h-63h
   114                                  %ifdef MACHINE_FE2010A
   115                                  ; Port 62h - Chipset Control Register - Write
   116                                  fe_control_reg	equ	62h
   117                                  fe_fpu_present	equ	02h	; FPU present
   118                                  fe_ram_256k	equ	00h	; XT DIP switches 3-4 - 256 KiB
   119                                  fe_ram_512k	equ	04h	; XT DIP switches 3-4 - 512 KiB
   120                                  fe_ram_576k	equ	08h	; XT DIP switches 3-4 - 576 KiB
   121                                  fe_ram_640k	equ	0Ch	; XT DIP switches 3-4 - 640 KiB
   122                                  fe_one_floppy	equ	00h	; XT DIP switches 7-8 - One floppy
   123                                  fe_two_floppies	equ	40h	; XT DIP switches 7-8 - Two floppies
   124                                  
   125                                  ; Port 63h - Chipset Configuration Register - Write only
   126                                  fe_config_reg	equ	63h	; Chipset configuration register
   127                                  fe_par_disable	equ	01h	; Disable memory parity checking
   128                                  fe_fpu_nma_ena 	equ	02h	; Enable FPU NMI
   129                                  fe_config_lock	equ	08h	; Write lock of control register and
   130                                  				; bits 0-4 of configuration register
   131                                  fe_clk_7_norm	equ	40h	; FE2010A 7.15 MHz CPU clock frequency, normal WS
   132                                  fe_clk_7_fast	equ	60h	; FE2010A 7.15 MHz CPU clock frequency, fast WS
   133                                  fe_clk_9_norm	equ	80h	; FE2010A 9.54 MHz CPU clock frequency, normal WS
   134                                  fe_clk_9_fast	equ	0C0h	; FE2010A 9.54 MHz CPU clock frequency, fast WS
   135                                  %endif ; MACHINE_FE2010A
   136                                  
   137                                  ; IBM PC/XT - Port 63h - 8255 PPI Control Word
   138                                  %ifdef MACHINE_XT
   139                                  ppi_cwd_reg	equ	63h	; 8255 PPI control word register
   140                                  ppi_cwd_value	equ	99h	; 8255 PPI control word value for IBM XT:
   141                                  				; Port A - mode 0 (simple I/O), input
   142                                  				; Port B - mode 0 (simple I/O), output
   143                                  				; Port C - output
   144                                  %endif ; MACHINE_XT
   145                                  
   146                                  post_reg	equ	80h	; POST status output port
   147                                  nmi_mask_reg	equ	0A0h
   148                                  %ifdef SECOND_PIC
   149                                  pic2_reg0	equ	0A0h
   150                                  pic2_reg1	equ	0A1h
   151                                  %endif ; SECOND_PIC
   152                                  unused_reg	equ	0C0h	; used for hardware detection and I/O delays
   153                                  cga_mode_reg	equ	3D8h
   154                                  mda_mode_reg	equ	3B8h
   155                                  
   156                                  ; NMI mask (written to 0A0h)
   157                                  nmi_disable	equ	00h	; disable NMI
   158                                  nmi_disa_mask	equ	7Fh	; disable NMI AND mask (bit 7 = 0)
   159                                  nmi_enable	equ	80h	; enable NMI OR mask (bit 7 = 1)
   160                                  
   161                                  pic_freq	equ	1193182	; PIC input frequency - 14318180 MHz / 12
   162                                  
   163                                  ;========================================================================
   164                                  ; BIOS data area variables
   165                                  ;------------------------------------------------------------------------
   166                                  equip_serial	equ	00h	; word[4] - addresses of serial ports
   167                                  				; or 0 if port doesn't exist
   168                                  equip_parallel	equ	08h	; word[3] - addresses of parallel ports
   169                                  				; or 0 if port doesn't exist
   170                                  ebda_segment	equ	0Eh	; word - address of EBDA segment
   171                                  equipment_list	equ	10h	; word - equpment list
   172                                  equip_floppies	equ	0000000000000001b	; floppy drivers installed
   173                                  equip_fpu	equ	0000000000000010b	; FPU installed
   174                                  equip_mouse	equ	0000000000000100b
   175                                  equip_video	equ	0000000000110000b	; video type bit mask
   176                                  equip_color_40	equ	0000000000010000b	; color 40x24 (mode 1)
   177                                  equip_color_80	equ	0000000000100000b	; color 80x25 (mode 3)
   178                                  equip_mono	equ	0000000000110000b	; mono 80x25 (mode 7)
   179                                  equip_floppy2	equ	0000000001000000b	; 2nd floppy drive installed
   180                                  ;			|||||||||||||||`-- floppy drives installed
   181                                  ;			||||||||||||||`-- FPU installed
   182                                  ;			|||||||||||||`-- PS/2 mouse installed
   183                                  ;			||||||||||||`-- reserved
   184                                  ;			||||||||||`--- initial video mode
   185                                  ;			||||||||`---- number of floppy drives - 1
   186                                  ;			|||||||`---- O = DMA installed
   187                                  ;			||||`------ number of serial ports
   188                                  ;			|||`------ game adapter installed
   189                                  ;			||`------ internal modem?!
   190                                  ;			`------- number of parallel ports
   191                                  
   192                                  post_flags	equ	12h	; byte - post flags
   193                                  post_setup	equ	01h	; run NVRAM setup
   194                                  memory_size	equ	13h	; word - memory size in KiB
   195                                  kbd_flags_1	equ	17h	; byte - keyboard shift flags 1
   196                                  kbd_flags_2	equ	18h	; byte - keyboard shift flags 2
   197                                  kbd_alt_keypad	equ	19h	; byte - work area for Alt+Numpad
   198                                  kbd_buffer_head	equ	1Ah	; word - keyboard buffer head offset
   199                                  kbd_buffer_tail	equ	1Ch	; word - keyboard buffer tail offset
   200                                  kbd_buffer	equ	1Eh	; byte[32] - keyboard buffer
   201                                  fdc_calib_state	equ	3Eh	; byte - floppy drive recalibration status
   202                                  fdc_motor_state	equ	3Fh	; byte - floppy drive motor status
   203                                  fdc_motor_tout	equ	40h	; byte - floppy drive motor off timeout (ticks)
   204                                  fdc_last_error	equ	41h	; byte - status of last diskette operation
   205                                  fdc_ctrl_status	equ	42h	; byte[7] - FDC status bytes
   206                                  video_mode	equ	49h	; byte - active video mode number
   207                                  video_columns	equ	4Ah	; word - number of text columns for active mode
   208                                  video_page_size	equ	4Ch	; word - size of video page in bytes
   209                                  video_page_offt	equ	4Eh	; word - offset of the active video page
   210                                  video_cur_pos	equ	50h	; byte[16] - cursor position for each page
   211                                  video_cur_shape	equ	60h	; word - cursor shape
   212                                  video_page	equ	62h	; byte - active video page
   213                                  video_port	equ	63h	; word - I/O port for the display adapter
   214                                  video_mode_reg	equ	65h	; byte - video adapter mode register
   215                                  video_palet_reg	equ	66h	; byte - color palette
   216                                  last_irq	equ	6Bh	; byte - Last spurious IRQ number
   217                                  ticks_lo	equ	6Ch	; word - timer ticks - low word
   218                                  ticks_hi	equ	6Eh	; word - timer ticks - high word
   219                                  new_day		equ	70h	; byte - 1 = new day flag
   220                                  break_flag	equ	71h	; byte - bit 7 = 1 if Ctrl-Break was pressed
   221                                  warm_boot	equ	72h	; word - Warm boot if equals 1234h
   222                                  printer_timeout	equ	78h	; byte[3] - parallel port timeout values
   223                                  serial_timeout	equ	7Ch	; byte[4] - serial port timeout values
   224                                  kbd_buffer_start equ	80h	; word - keyboard buffer start offset
   225                                  kbd_buffer_end	equ	82h	; word - keyboard buffer end offset
   226                                  video_rows	equ	84h	; byte - number of text rows (EGA+)
   227                                  fdc_last_rate	equ	8Bh	; byte - last data rate / step rate
   228                                  fdc_info	equ	8Fh	; byte - floppy dist drive information
   229                                  fdc_media_state	equ	90h	; byte[4] - drive media state (drives 0 - 3)
   230                                  fdc_cylinder	equ	94h	; byte[2] - current cylinder (drives 0 - 1)
   231                                  kbd_flags_3	equ	96h	; byte - keyboard status flags 3
   232                                  kbd_flags_4	equ	97h	; byte - keyboard status flags 4
   233                                  vga_table_ptr	equ	0A8h	; dword - BIOS Video Save/Override Pointer
   234                                  				;       Table address
   235                                  prt_scrn_flags	equ	100h	; byte - print screen flags
   236                                  prt_scrn_ready	equ	00h	;	print screen is not in progress
   237                                  prt_scrn_run	equ	01h	; 	print screen is in progress
   238                                  prt_scrn_fail	equ	0FFh	;	last print screen attempt has failed
   239                                  
   240                                  ;=========================================================================
   241                                  ; Extended BIOS data area variables
   242                                  ;-------------------------------------------------------------------------
   243                                  ebda_size	equ	0h
   244                                  mouse_driver	equ	22h	; 4 bytes - pointer to mouse driver
   245                                  mouse_flags_1	equ	26h
   246                                  mouse_flags_2	equ	27h
   247                                  mouse_data	equ	28h	; 8 bytes - mouse data buffer
   248                                  
   249                                  	org	START		; Use only upper 32 KiB of ROM
   250                                  
   251                                  ;=========================================================================
   252                                  ; Includes
   253                                  ;-------------------------------------------------------------------------
   254                                  %include	"messages.inc"		; POST messages
   255                              <1> ;=========================================================================
   256                              <1> ; messages.inc - Messages printed by BIOS POST (Power On Self Test)
   257                              <1> ;-------------------------------------------------------------------------
   258                              <1> ;
   259                              <1> ; Compiles with NASM 2.13.02, might work with other versions
   260                              <1> ;
   261                              <1> ; Copyright (C) 2010 - 2023 Sergey Kiselev.
   262                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
   263                              <1> ;
   264                              <1> ; This program is free software: you can redistribute it and/or modify
   265                              <1> ; it under the terms of the GNU General Public License as published by
   266                              <1> ; the Free Software Foundation, either version 3 of the License, or
   267                              <1> ; (at your option) any later version.
   268                              <1> ;
   269                              <1> ; This program is distributed in the hope that it will be useful,
   270                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   271                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   272                              <1> ; GNU General Public License for more details.
   273                              <1> ;
   274                              <1> ; You should have received a copy of the GNU General Public License
   275                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   276                              <1> ;
   277                              <1> ;=========================================================================
   278                              <1> 
   279 00000000 0D0A                <1> msg_copyright	db	0Dh, 0Ah
   280                              <1> %ifdef MACHINE_XI8088
   281                              <1> 		db	"Xi 8088"
   282                              <1> %endif ; MACHINE_XI8088
   283                              <1> %ifdef MACHINE_FE2010A
   284 00000002 4D6963726F20383038- <1> 		db	"Micro 8088"
   284 0000000B 38                  <1>
   285                              <1> %endif ; MACHINE_FE2010A
   286                              <1> %ifdef MACHINE_BOOK8088
   287                              <1> 		db	"Book8088"
   288                              <1> %endif ; MACHINE_BOOK8088
   289                              <1> %ifdef MACHINE_XT
   290                              <1> 		db	"XT 8088"
   291                              <1> %endif ; MACHINE_XT
   292 0000000C 2042494F532C205665- <1> 		db	" BIOS, Version "
   292 00000015 7273696F6E20        <1>
   293 0000001B 312E302E30          <1> 		db	VERSION
   294 00000020 2E20                <1> 		db	". "
   295 00000022 436F70797269676874- <1> 		db	"Copyright (C) 2010 - 2023 Sergey Kiselev", 0Dh, 0Ah
   295 0000002B 202843292032303130- <1>
   295 00000034 202D20323032332053- <1>
   295 0000003D 6572676579204B6973- <1>
   295 00000046 656C65760D0A        <1>
   296 0000004C 446973747269627574- <1> 		db	"Distributed under the terms of "
   296 00000055 656420756E64657220- <1>
   296 0000005E 746865207465726D73- <1>
   296 00000067 206F6620            <1>
   297 0000006B 74686520474E552047- <1> 		db	"the GNU General Public License", 0Dh, 0Ah
   297 00000074 656E6572616C205075- <1>
   297 0000007D 626C6963204C696365- <1>
   297 00000086 6E73650D0A          <1>
   298 0000008B 0D0A00              <1> msg_crlf	db      0Dh, 0Ah, 00h
   299 0000008E 6E6F6E6500          <1> msg_none	db	'none', 00h
   300 00000093 3A2000              <1> msg_colon	db	': ', 00h
   301 00000096 3B2000              <1> msg_semicolon	db	'; ', 00h
   302                              <1> %ifdef TURBO_MODE
   303 00000099 43505520636C6F636B- <1> msg_cpu_clk	db	'CPU clock frequency:        ', 00h
   303 000000A2 206672657175656E63- <1>
   303 000000AB 793A20202020202020- <1>
   303 000000B4 2000                <1>
   304 000000B6 20402000            <1> msg_at		db	' @ ', 00h
   305 000000BA 342E3737204D487A20- <1> msg_clk_4_77mhz	db	'4.77 MHz ', 00h
   305 000000C3 00                  <1>
   306                              <1> %ifdef MACHINE_FE2010A
   307 000000C4 372E3136204D487A20- <1> msg_clk_7_16mhz	db	'7.16 MHz ', 00h
   307 000000CD 00                  <1>
   308 000000CE 392E3535204D487A20- <1> msg_clk_9_55mhz	db	'9.55 MHz ', 00h
   308 000000D7 00                  <1>
   309                              <1> %else ; MACHINE_FE2010A
   310                              <1> msg_clk_turbo	db	'Turbo ', 00h
   311                              <1> %endif ; MACHINE_FE2010A
   312                              <1> %endif ; TURBO_MODE
   313 000000D8 4D61696E2050726F63- <1> msg_cpu		db      'Main Processor:             ', 00h
   313 000000E1 6573736F723A202020- <1>
   313 000000EA 202020202020202020- <1>
   313 000000F3 2000                <1>
   314 000000F5 4D617468656D617469- <1> msg_fpu		db      'Mathematics Co-processor:   ', 00h
   314 000000FE 637320436F2D70726F- <1>
   314 00000107 636573736F723A2020- <1>
   314 00000110 2000                <1>
   315 00000112 496E74656C20383038- <1> msg_cpu_8088_78	db      "Intel 8088 '78", 00h
   315 0000011B 382027373800        <1>
   316 00000121 5741524E494E473A20- <1> msg_cpu_bug	db      'WARNING: This CPU does not disable interrupts '
   316 0000012A 546869732043505520- <1>
   316 00000133 646F6573206E6F7420- <1>
   316 0000013C 64697361626C652069- <1>
   316 00000145 6E7465727275707473- <1>
   316 0000014E 20                  <1>
   317 0000014F 6166746572206C6F61- <1> 		db      'after loading segment registers!', 0Dh, 0Ah, 00h
   317 00000158 64696E67207365676D- <1>
   317 00000161 656E74207265676973- <1>
   317 0000016A 74657273210D0A00    <1>
   318 00000172 496E74656C20383038- <1> msg_cpu_8088_81	db      "Intel 8088 '81 or later, "
   318 0000017B 3820273831206F7220- <1>
   318 00000184 6C617465722C20      <1>
   319 0000018B 6F72204F4B492D6465- <1> 		db      'or OKI-designed 80C88', 00h
   319 00000194 7369676E6564203830- <1>
   319 0000019D 43383800            <1>
   320 000001A1 4861727269732D6465- <1> msg_cpu_harris  db      'Harris-designed 80C88', 00h
   320 000001AA 7369676E6564203830- <1>
   320 000001B3 43383800            <1>
   321 000001B7 4E45432056323000    <1> msg_cpu_nec_v20 db      'NEC V20', 00h
   322 000001BF 496E74656C20383038- <1> msg_fpu_present db      'Intel 8087', 0Dh, 0Ah, 00h
   322 000001C8 370D0A00            <1>
   323                              <1> %ifdef MACHINE_FE2010A
   324 000001CC 436869707365743A20- <1> msg_chipset	db	'Chipset:                    ', 00h
   324 000001D5 202020202020202020- <1>
   324 000001DE 202020202020202020- <1>
   324 000001E7 2000                <1>
   325 000001E9 466172616461792046- <1> msg_fe2010a	db	'Faraday FE2010A', 0Dh, 0Ah, 00h
   325 000001F2 4532303130410D0A00  <1>
   326 000001FB 50726F746F6E205054- <1> msg_pt8010af	db	'Proton PT8010AF', 0Dh, 0Ah, 00h
   326 00000204 3830313041460D0A00  <1>
   327                              <1> %endif ; MACHINE_FE2010A
   328 0000020D 446973706C61792041- <1> msg_disp	db      'Display Adapter Type:       ', 00h
   328 00000216 646170746572205479- <1>
   328 0000021F 70653A202020202020- <1>
   328 00000228 2000                <1>
   329 0000022A 4547412F5647412028- <1> msg_disp_ega	db      'EGA/VGA (Video BIOS Present)', 0Dh, 0Ah, 00h
   329 00000233 566964656F2042494F- <1>
   329 0000023C 532050726573656E74- <1>
   329 00000245 290D0A00            <1>
   330 00000249 434741202838307832- <1> msg_disp_cga_80	db      'CGA (80x25)', 0Dh, 0Ah, 00h
   330 00000252 35290D0A00          <1>
   331 00000257 434741202834307832- <1> msg_disp_cga_40	db      'CGA (40x25)', 0Dh, 0Ah, 00h
   331 00000260 35290D0A00          <1>
   332 00000265 4D4441206F72204865- <1> msg_disp_mda	db      'MDA or Hercules', 0Dh, 0Ah, 00h
   332 0000026E 7263756C65730D0A00  <1>
   333 00000277 52544320285265616C- <1> msg_rtc		db	'RTC (Real Time Clock):      ', 00h
   333 00000280 2054696D6520436C6F- <1>
   333 00000289 636B293A2020202020- <1>
   333 00000292 2000                <1>
   334 00000294 466C6F707079206469- <1> msg_floppy	db	'Floppy disk drives:         Drive 0: ', 00h
   334 0000029D 736B20647269766573- <1>
   334 000002A6 3A2020202020202020- <1>
   334 000002AF 20447269766520303A- <1>
   334 000002B8 2000                <1>
   335 000002BA 3B2044726976652031- <1> msg_floppy_2	db	'; Drive 1: ', 00h
   335 000002C3 3A2000              <1>
   336 000002C6 333630204B422C2035- <1> msg_floppy_360	db	'360 KB, 5.25"', 00h
   336 000002CF 2E32352200          <1>
   337 000002D4 312E32204D422C2035- <1> msg_floppy_1200	db	'1.2 MB, 5.25"', 00h
   337 000002DD 2E32352200          <1>
   338 000002E2 373230204B422C2033- <1> msg_floppy_720	db	'720 KB, 3.5"', 00h
   338 000002EB 2E352200            <1>
   339 000002EF 312E3434204D422C20- <1> msg_floppy_1440	db	'1.44 MB, 3.5"', 00h
   339 000002F8 332E352200          <1>
   340 000002FD 322E3838204D422C20- <1> msg_floppy_2880	db	'2.88 MB, 3.5"', 00h
   340 00000306 332E352200          <1>
   341                              <1> %ifdef PS2_MOUSE
   342                              <1> msg_mouse	db      'PS/2 Aux Device (Mouse):    ', 00h
   343                              <1> %endif ; PS2_MOUSE
   344 0000030B 50726573656E740D0A- <1> msg_present	db      'Present', 0Dh, 0Ah, 00h
   344 00000314 00                  <1>
   345 00000315 416273656E740D0A00  <1> msg_absent	db      'Absent', 0Dh, 0Ah, 00h
   346 0000031E 53657269616C20506F- <1> msg_serial	db	'Serial Ports:               ', 00h
   346 00000327 7274733A2020202020- <1>
   346 00000330 202020202020202020- <1>
   346 00000339 2000                <1>
   347 0000033B 434F4D00            <1> msg_serial_com	db	'COM', 00h
   348 0000033F 506172616C6C656C20- <1> msg_parallel	db	'Parallel Ports:             ', 00h
   348 00000348 506F7274733A202020- <1>
   348 00000351 202020202020202020- <1>
   348 0000035A 2000                <1>
   349 0000035C 4C505400            <1> msg_parallel_lpt db	'LPT', 00h
   350 00000360 54657374696E672052- <1> msg_ram_testing	db	'Testing RAM (ESC to skip):  ', 00h
   350 00000369 414D20284553432074- <1>
   350 00000372 6F20736B6970293A20- <1>
   350 0000037B 2000                <1>
   351 0000037D 0D0A4552524F523A20- <1> msg_ram_error	db	0Dh, 0Ah, 'ERROR: Faulty memory detected at ', 00h
   351 00000386 4661756C7479206D65- <1>
   351 0000038F 6D6F72792064657465- <1>
   351 00000398 637465642061742000  <1>
   352 000003A1 0D546F74616C20436F- <1> msg_ram_total	db      0Dh, 'Total Conventional RAM:     ', 00h
   352 000003AA 6E76656E74696F6E61- <1>
   352 000003B3 6C2052414D3A202020- <1>
   352 000003BC 202000              <1>
   353                              <1> %ifdef EBDA_SIZE
   354                              <1> msg_ebda	db      'Reserved for EBDA:          ', 00h
   355                              <1> msg_ram_avail	db      'Available Conventional RAM: ', 00h
   356                              <1> %endif ; EBDA_SIZE
   357 000003BF 204B69420D0A00      <1> msg_kib		db      ' KiB', 0Dh, 0Ah, 00h
   358 000003C6 426F6F74206661696C- <1> msg_boot_failed	db      'Boot failed, press any key to try again...', 0Dh, 0Ah, 0
   358 000003CF 65642C207072657373- <1>
   358 000003D8 20616E79206B657920- <1>
   358 000003E1 746F20747279206167- <1>
   358 000003EA 61696E2E2E2E0D0A00  <1>
   359 000003F3 4E6F20524F4D204241- <1> msg_no_basic    db      'No ROM BASIC', 0Dh, 0Ah, 0
   359 000003FC 5349430D0A00        <1>
   360 00000402 466F756E642042494F- <1> msg_rom_found   db      'Found BIOS extension ROM at ', 0
   360 0000040B 5320657874656E7369- <1>
   360 00000414 6F6E20524F4D206174- <1>
   360 0000041D 2000                <1>
   361 0000041F 302C20696E69746961- <1> msg_rom_init	db	'0, initializing...', 0Dh, 0Ah, 0
   361 00000428 6C697A696E672E2E2E- <1>
   361 00000431 0D0A00              <1>
   362 00000434 426F6F74696E67204F- <1> msg_boot	db      'Booting OS...', 0Dh, 0Ah, 0
   362 0000043D 532E2E2E0D0A00      <1>
   363                              <1> %ifdef AT_RTC
   364 00000444 4552524F523A205254- <1> msg_rtc_bad	db	'ERROR: RTC battery is bad', 0Dh, 0Ah, 00h
   364 0000044D 432062617474657279- <1>
   364 00000456 206973206261640D0A- <1>
   364 0000045F 00                  <1>
   365                              <1> %endif ; AT_RTC
   366                              <1> %ifdef AT_RTC_NVRAM
   367                              <1> msg_rtc_sum	db	'ERROR: NVRAM checksum is invalid, '
   368                              <1> 		db	'loading default values to NVRAM', 0Dh, 0Ah, 00h
   369                              <1> %endif ; AT_RTC_NVRAM
   370                              <1> %ifdef BIOS_SETUP
   371 00000460 507265737320463120- <1> msg_setup	db	'Press F1 to run BIOS setup...',0Dh, 0Ah, 0Dh, 0Ah, 00h
   371 00000469 746F2072756E204249- <1>
   371 00000472 4F532073657475702E- <1>
   371 0000047B 2E2E0D0A0D0A00      <1>
   372 00000482 0D0A57656C636F6D65- <1> msg_set_welcome	db	0Dh, 0Ah, 'Welcome to the BIOS setup utility', 00h
   372 0000048B 20746F207468652042- <1>
   372 00000494 494F53207365747570- <1>
   372 0000049D 207574696C69747900  <1>
   373 000004A6 0D0A                <1> msg_set_help	db	0Dh, 0Ah
   374 000004A8 42494F532073657475- <1> 		db	'BIOS setup commands:', 0Dh, 0Ah
   374 000004B1 7020636F6D6D616E64- <1>
   374 000004BA 733A0D0A            <1>
   375 000004BE 66202D204368616E67- <1> 		db	'f - Change first floppy drive type', 0Dh, 0Ah
   375 000004C7 652066697273742066- <1>
   375 000004D0 6C6F70707920647269- <1>
   375 000004D9 766520747970650D0A  <1>
   376 000004E2 67202D204368616E67- <1> 		db	'g - Change second floppy drive type', 0Dh, 0Ah
   376 000004EB 65207365636F6E6420- <1>
   376 000004F4 666C6F707079206472- <1>
   376 000004FD 69766520747970650D- <1>
   376 00000506 0A                  <1>
   377 00000507 65202D204368616E67- <1> 		db	'e - Change BIOS extension ROM scan settings', 0Dh, 0Ah
   377 00000510 652042494F53206578- <1>
   377 00000519 74656E73696F6E2052- <1>
   377 00000522 4F4D207363616E2073- <1>
   377 0000052B 657474696E67730D0A  <1>
   378 00000534 6D202D204368616E67- <1> 		db	'm - Change memory test settings', 0Dh, 0Ah
   378 0000053D 65206D656D6F727920- <1>
   378 00000546 746573742073657474- <1>
   378 0000054F 696E67730D0A        <1>
   379                              <1> %ifdef TURBO_MODE
   380 00000555 63202D205365742064- <1> 		db	'c - Set default CPU clock frequency', 0Dh, 0Ah
   380 0000055E 656661756C74204350- <1>
   380 00000567 5520636C6F636B2066- <1>
   380 00000570 72657175656E63790D- <1>
   380 00000579 0A                  <1>
   381                              <1> %endif ; TURBO_MODE
   382                              <1> %ifdef MACHINE_FE2010A
   383 0000057A 73202D204368616E67- <1> 		db	's - Change wait state settings', 0Dh, 0Ah
   383 00000583 652077616974207374- <1>
   383 0000058C 617465207365747469- <1>
   383 00000595 6E67730D0A          <1>
   384                              <1> %endif ; MACHINE_FE2010A
   385 0000059A 00                  <1> 		db	00h
   386                              <1> %ifdef AT_RTC
   387 0000059B 74202D205365742074- <1> msg_set_rtc_help db	't - Set time', 0Dh, 0Ah
   387 000005A4 696D650D0A          <1>
   388 000005A9 64202D205365742064- <1> 		db	'd - Set date', 0Dh, 0Ah, 00h
   388 000005B2 6174650D0A00        <1>
   389                              <1> %endif ; AT_RTC
   390 000005B8 70202D205072696E74- <1> msg_set_def_help db	'p - Print current settings', 0Dh, 0Ah
   390 000005C1 2063757272656E7420- <1>
   390 000005CA 73657474696E67730D- <1>
   390 000005D3 0A                  <1>
   391 000005D4 77202D205361766520- <1> 		db	'w - Save changes and exit', 0Dh, 0Ah
   391 000005DD 6368616E6765732061- <1>
   391 000005E6 6E6420657869740D0A  <1>
   392 000005EF 71202D204578697420- <1> 		db	'q - Exit without saving changes', 0Dh, 0Ah
   392 000005F8 776974686F75742073- <1>
   392 00000601 6176696E6720636861- <1>
   392 0000060A 6E6765730D0A        <1>
   393 00000610 68202D2053686F7720- <1> 		db	'h - Show this help', 0Dh, 0Ah, 00h
   393 00000619 746869732068656C70- <1>
   393 00000622 0D0A00              <1>
   394 00000625 0D0A456E7465722063- <1> msg_set_prompt	db	0Dh, 0Ah, 'Enter command (h for help): ', 00h
   394 0000062E 6F6D6D616E64202868- <1>
   394 00000637 20666F722068656C70- <1>
   394 00000640 293A2000            <1>
   395                              <1> %ifdef TURBO_MODE
   396 00000644 0D0A                <1> msg_set_clk_help db 	0Dh, 0Ah
   397 00000646 43505520636C6F636B- <1> 		db	'CPU clock frequency options:', 0Dh, 0Ah
   397 0000064F 206672657175656E63- <1>
   397 00000658 79206F7074696F6E73- <1>
   397 00000661 3A0D0A              <1>
   398 00000664 34202D20342E373720- <1> 		db	'4 - 4.77 MHz', 0Dh, 0Ah
   398 0000066D 4D487A0D0A          <1>
   399                              <1> %ifdef MACHINE_FE2010A
   400 00000672 37202D20372E313620- <1> 		db	'7 - 7.16 MHz', 0Dh, 0Ah
   400 0000067B 4D487A0D0A          <1>
   401 00000680 39202D20392E353520- <1> 		db	'9 - 9.55 MHz', 0Dh, 0Ah, 00h
   401 00000689 4D487A0D0A00        <1>
   402                              <1> %else ; MACHINE_FE2010A
   403                              <1> 		db	't - Turbo', 0Dh, 0Ah, 00h
   404                              <1> %endif ; MACHINE_FE2010A
   405 0000068F 0D0A456E7465722043- <1> msg_set_clk_prmt db	0Dh, 0Ah, 'Enter CPU clock frequency (h for help): '
   405 00000698 505520636C6F636B20- <1>
   405 000006A1 6672657175656E6379- <1>
   405 000006AA 20286820666F722068- <1>
   405 000006B3 656C70293A20        <1>
   406 000006B9 00                  <1> 		db	00h
   407                              <1> %endif ; TURBO_MODE
   408                              <1> %ifdef AT_RTC
   409 000006BA 456E7465722074696D- <1> msg_set_time	db	'Enter time (hh:mm:ss): ', 00h
   409 000006C3 65202868683A6D6D3A- <1>
   409 000006CC 7373293A2000        <1>
   410 000006D2 456E74657220646174- <1> msg_set_date	db	'Enter date (YYYY-MM-DD): ', 00h
   410 000006DB 652028595959592D4D- <1>
   410 000006E4 4D2D4444293A2000    <1>
   411 000006EC 4552524F523A20496E- <1> msg_time_inval	db	'ERROR: Invalid time.', 0Dh, 0Ah, 00h
   411 000006F5 76616C69642074696D- <1>
   411 000006FE 652E0D0A00          <1>
   412 00000703 4552524F523A20496E- <1> msg_date_inval	db	'ERROR: Invalid date.', 0Dh, 0Ah, 00h
   412 0000070C 76616C696420646174- <1>
   412 00000715 652E0D0A00          <1>
   413                              <1> %endif ; AT_RTC
   414 0000071A 0D0A                <1> msg_set_fd_help	db	0Dh, 0Ah
   415 0000071C 466C6F707079206472- <1> 		db	'Floppy drive types:', 0Dh, 0Ah
   415 00000725 697665207479706573- <1>
   415 0000072E 3A0D0A              <1>
   416 00000731 30202D204E6F742069- <1> 		db	'0 - Not installed   3 - 720 KB, 3.5"', 0Dh, 0Ah
   416 0000073A 6E7374616C6C656420- <1>
   416 00000743 202033202D20373230- <1>
   416 0000074C 204B422C20332E3522- <1>
   416 00000755 0D0A                <1>
   417 00000757 31202D20333630204B- <1> 		db	'1 - 360 KB, 5.25"   4 - 1.44 MB, 3.5"', 0Dh, 0Ah
   417 00000760 422C20352E32352220- <1>
   417 00000769 202034202D20312E34- <1>
   417 00000772 34204D422C20332E35- <1>
   417 0000077B 220D0A              <1>
   418 0000077E 32202D20312E32204D- <1> 		db	'2 - 1.2 MB, 5.25"   6 - 2.88 MB, 3.5"', 0Dh, 0Ah, 00h
   418 00000787 422C20352E32352220- <1>
   418 00000790 202036202D20322E38- <1>
   418 00000799 38204D422C20332E35- <1>
   418 000007A2 220D0A00            <1>
   419 000007A6 536574757020636F6D- <1> msg_set_sub_help db	'Setup commands:', 0Dh, 0Ah
   419 000007AF 6D616E64733A0D0A    <1>
   420 000007B7 72202D205265747572- <1> 		db	'r - Return to the main menu', 0Dh, 0Ah
   420 000007C0 6E20746F2074686520- <1>
   420 000007C9 6D61696E206D656E75- <1>
   420 000007D2 0D0A                <1>
   421 000007D4 68202D2053686F7720- <1> 		db	'h - Show this help', 0Dh, 0Ah, 00h
   421 000007DD 746869732068656C70- <1>
   421 000007E6 0D0A00              <1>
   422 000007E9 0D0A456E7465722066- <1> msg_set_fd_prmt	db	0Dh, 0Ah, 'Enter floppy drive type (h for help): '
   422 000007F2 6C6F70707920647269- <1>
   422 000007FB 766520747970652028- <1>
   422 00000804 6820666F722068656C- <1>
   422 0000080D 70293A20            <1>
   423 00000811 00                  <1> 		db	00h
   424 00000812 5363616E2046303030- <1> msg_set_ext	db	'Scan F0000-F7FFF area for BIOS extension ROMs (y/n): '
   424 0000081B 302D46374646462061- <1>
   424 00000824 72656120666F722042- <1>
   424 0000082D 494F5320657874656E- <1>
   424 00000836 73696F6E20524F4D73- <1>
   424 0000083F 2028792F6E293A20    <1>
   425 00000847 00                  <1> 		db	00h
   426 00000848 46303030302D463746- <1> msg_ext_scan	db	'F0000-F7FFF BIOS ext. scan: ', 00h
   426 00000851 46462042494F532065- <1>
   426 0000085A 78742E207363616E3A- <1>
   426 00000863 2000                <1>
   427 00000865 456E61626C65206D65- <1> msg_set_mem_tst	db	'Enable memory test (y/n): ', 00h
   427 0000086E 6D6F72792074657374- <1>
   427 00000877 2028792F6E293A2000  <1>
   428 00000880 4D656D6F7279207465- <1> msg_mem_test	db	'Memory test:                ', 00h
   428 00000889 73743A202020202020- <1>
   428 00000892 202020202020202020- <1>
   428 0000089B 2000                <1>
   429                              <1> %ifdef MACHINE_FE2010A
   430 0000089D 466173742077616974- <1> msg_set_ws	db	'Fast wait states (y/n, h for help): ', 00h
   430 000008A6 207374617465732028- <1>
   430 000008AF 792F6E2C206820666F- <1>
   430 000008B8 722068656C70293A20- <1>
   430 000008C1 00                  <1>
   431 000008C2 0D0A                <1> msg_ws_help	db	0Dh, 0Ah
   432 000008C4 576169742073746174- <1> 		db	'Wait states configuration for FE2010A and PT8010AF:',
   432 000008CD 657320636F6E666967- <1>
   432 000008D6 75726174696F6E2066- <1>
   432 000008DF 6F7220464532303130- <1>
   432 000008E8 4120616E6420505438- <1>
   432 000008F1 30313041463A        <1>
   433 000008F7 0D0A                <1> 		db	0Dh, 0Ah
   434 000008F9 372E3135204D487A2C- <1> 		db	'7.15 MHz, normal: I/O - 4 WS; Upper memory - 2 WS'
   434 00000902 206E6F726D616C3A20- <1>
   434 0000090B 492F4F202D20342057- <1>
   434 00000914 533B20557070657220- <1>
   434 0000091D 6D656D6F7279202D20- <1>
   434 00000926 32205753            <1>
   435 0000092A 0D0A                <1> 		db	0Dh, 0Ah
   436 0000092C 372E3135204D487A2C- <1> 		db	'7.15 MHz, fast:   I/O - 4 WS; Upper memory - 0 WS'
   436 00000935 20666173743A202020- <1>
   436 0000093E 492F4F202D20342057- <1>
   436 00000947 533B20557070657220- <1>
   436 00000950 6D656D6F7279202D20- <1>
   436 00000959 30205753            <1>
   437 0000095D 0D0A                <1> 		db	0Dh, 0Ah
   438 0000095F 392E3534204D487A2C- <1> 		db	'9.54 MHz, normal: I/O - 6 WS; Upper memory - 4 WS'
   438 00000968 206E6F726D616C3A20- <1>
   438 00000971 492F4F202D20362057- <1>
   438 0000097A 533B20557070657220- <1>
   438 00000983 6D656D6F7279202D20- <1>
   438 0000098C 34205753            <1>
   439 00000990 0D0A                <1> 		db	0Dh, 0Ah
   440 00000992 392E3534204D487A2C- <1> 		db	'9.54 MHz, fast:   I/O - 4 WS; Upper memory - 2 WS'
   440 0000099B 20666173743A202020- <1>
   440 000009A4 492F4F202D20342057- <1>
   440 000009AD 533B20557070657220- <1>
   440 000009B6 6D656D6F7279202D20- <1>
   440 000009BF 32205753            <1>
   441 000009C3 0D0A00              <1> 		db	0Dh, 0Ah, 00h
   442 000009C6 466173742077616974- <1> msg_ws		db	'Fast wait states:           ', 00h
   442 000009CF 207374617465733A20- <1>
   442 000009D8 202020202020202020- <1>
   442 000009E1 2000                <1>
   443                              <1> %endif ; MACHINE_FE2010A
   444 000009E3 456E61626C656400    <1> msg_enabled	db	'Enabled', 00h
   445 000009EB 44697361626C656400  <1> msg_disabled	db	'Disabled', 00h
   446                              <1> %ifdef FLASH_NVRAM
   447 000009F4 0D0A536176696E6720- <1> msg_saving	db	0Dh, 0Ah, 'Saving configuration to Flash ROM... ', 00h
   447 000009FD 636F6E666967757261- <1>
   447 00000A06 74696F6E20746F2046- <1>
   447 00000A0F 6C61736820524F4D2E- <1>
   447 00000A18 2E2E2000            <1>
   448 00000A1C 4F4B0D0A00          <1> msg_save_ok	db	'OK', 0Dh, 0Ah, 00h
   449 00000A21 4552524F520D0A00    <1> msg_save_error	db	'ERROR', 0Dh, 0Ah, 00h
   450                              <1> %endif ; FLASH_NVRAM
   451                              <1> %endif ; BIOS_SETUP
   452 00000A29 [8E00]              <1> tbl_floppy	dw	msg_none
   453 00000A2B [C602]              <1> 		dw	msg_floppy_360
   454 00000A2D [D402]              <1> 		dw	msg_floppy_1200
   455 00000A2F [E202]              <1> 		dw	msg_floppy_720
   456 00000A31 [EF02]              <1> 		dw	msg_floppy_1440
   457 00000A33 [8E00]              <1> 		dw	msg_none
   458 00000A35 [FD02]              <1> 		dw	msg_floppy_2880
   459 00000A37 [8E00]              <1> 		dw	msg_none
   255                                  %ifndef MACHINE_XT			; No space in XT ROM for font
   256                                  %include	"fnt80-FF.inc"		; font for graphics modes
   257                              <1> ;=========================================================================
   258                              <1> ; fnt80-FF.inc - Font for graphics modes (Cyrillic font)
   259                              <1> ;       Characters from 80h to 0FFh
   260                              <1> ;-------------------------------------------------------------------------
   261                              <1> ;
   262                              <1> ; Compiles with NASM 2.13.02, might work with other versions
   263                              <1> ;
   264                              <1> ; This font is borrowed from kbd package (alt-8x8)
   265                              <1> ;
   266                              <1> ; This program is free software: you can redistribute it and/or modify
   267                              <1> ; it under the terms of the GNU General Public License as published by
   268                              <1> ; the Free Software Foundation, either version 3 of the License, or
   269                              <1> ; (at your option) any later version.
   270                              <1> ;
   271                              <1> ; This program is distributed in the hope that it will be useful,
   272                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   273                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   274                              <1> ; GNU General Public License for more details.
   275                              <1> ;
   276                              <1> ; You should have received a copy of the GNU General Public License
   277                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   278                              <1> ;
   279                              <1> ;=========================================================================
   280                              <1> int_1F:
   281 00000A39 1E3666667E666600    <1> 	db	 1Eh,  36h,  66h,  66h,  7Eh,  66h,  66h,  00h
   282 00000A41 7C60607C66667C00    <1> 	db	 7Ch,  60h,  60h,  7Ch,  66h,  66h,  7Ch,  00h
   283 00000A49 7C66667C66667C00    <1> 	db	 7Ch,  66h,  66h,  7Ch,  66h,  66h,  7Ch,  00h
   284 00000A51 7E60606060606000    <1> 	db	 7Eh,  60h,  60h,  60h,  60h,  60h,  60h,  00h
   285 00000A59 386C6C6C6C6CFEC6    <1> 	db	 38h,  6Ch,  6Ch,  6Ch,  6Ch,  6Ch, 0FEh, 0C6h
   286 00000A61 7E60607C60607E00    <1> 	db	 7Eh,  60h,  60h,  7Ch,  60h,  60h,  7Eh,  00h
   287 00000A69 DBDB7E3C7EDBDB00    <1> 	db	0DBh, 0DBh,  7Eh,  3Ch,  7Eh, 0DBh, 0DBh,  00h
   288 00000A71 3C66061C06663C00    <1> 	db	 3Ch,  66h,  06h,  1Ch,  06h,  66h,  3Ch,  00h
   289 00000A79 66666E7E76666600    <1> 	db	 66h,  66h,  6Eh,  7Eh,  76h,  66h,  66h,  00h
   290 00000A81 3C666E7E76666600    <1> 	db	 3Ch,  66h,  6Eh,  7Eh,  76h,  66h,  66h,  00h
   291 00000A89 666C7870786C6600    <1> 	db	 66h,  6Ch,  78h,  70h,  78h,  6Ch,  66h,  00h
   292 00000A91 1E36666666666600    <1> 	db	 1Eh,  36h,  66h,  66h,  66h,  66h,  66h,  00h
   293 00000A99 C6EEFEFED6C6C600    <1> 	db	0C6h, 0EEh, 0FEh, 0FEh, 0D6h, 0C6h, 0C6h,  00h
   294 00000AA1 6666667E66666600    <1> 	db	 66h,  66h,  66h,  7Eh,  66h,  66h,  66h,  00h
   295 00000AA9 3C66666666663C00    <1> 	db	 3Ch,  66h,  66h,  66h,  66h,  66h,  3Ch,  00h
   296 00000AB1 7E66666666666600    <1> 	db	 7Eh,  66h,  66h,  66h,  66h,  66h,  66h,  00h
   297 00000AB9 7C6666667C606000    <1> 	db	 7Ch,  66h,  66h,  66h,  7Ch,  60h,  60h,  00h
   298 00000AC1 3C66606060663C00    <1> 	db	 3Ch,  66h,  60h,  60h,  60h,  66h,  3Ch,  00h
   299 00000AC9 7E18181818181800    <1> 	db	 7Eh,  18h,  18h,  18h,  18h,  18h,  18h,  00h
   300 00000AD1 6666663E06663C00    <1> 	db	 66h,  66h,  66h,  3Eh,  06h,  66h,  3Ch,  00h
   301 00000AD9 7EDBDBDB7E181800    <1> 	db	 7Eh, 0DBh, 0DBh, 0DBh,  7Eh,  18h,  18h,  00h
   302 00000AE1 66663C183C666600    <1> 	db	 66h,  66h,  3Ch,  18h,  3Ch,  66h,  66h,  00h
   303 00000AE9 6666666666667F03    <1> 	db	 66h,  66h,  66h,  66h,  66h,  66h,  7Fh,  03h
   304 00000AF1 6666663E06060600    <1> 	db	 66h,  66h,  66h,  3Eh,  06h,  06h,  06h,  00h
   305 00000AF9 DBDBDBDBDBDBFF00    <1> 	db	0DBh, 0DBh, 0DBh, 0DBh, 0DBh, 0DBh, 0FFh,  00h
   306 00000B01 DBDBDBDBDBDBFF03    <1> 	db	0DBh, 0DBh, 0DBh, 0DBh, 0DBh, 0DBh, 0FFh,  03h
   307 00000B09 E060607C66667C00    <1> 	db	0E0h,  60h,  60h,  7Ch,  66h,  66h,  7Ch,  00h
   308 00000B11 C6C6C6F6DEDEF600    <1> 	db	0C6h, 0C6h, 0C6h, 0F6h, 0DEh, 0DEh, 0F6h,  00h
   309 00000B19 6060607C66667C00    <1> 	db	 60h,  60h,  60h,  7Ch,  66h,  66h,  7Ch,  00h
   310 00000B21 788C063E068C7800    <1> 	db	 78h,  8Ch,  06h,  3Eh,  06h,  8Ch,  78h,  00h
   311 00000B29 CEDBDBFBDBDBCE00    <1> 	db	0CEh, 0DBh, 0DBh, 0FBh, 0DBh, 0DBh, 0CEh,  00h
   312 00000B31 3E6666663E366600    <1> 	db	 3Eh,  66h,  66h,  66h,  3Eh,  36h,  66h,  00h
   313 00000B39 0000780C7CCC7600    <1> 	db	 00h,  00h,  78h,  0Ch,  7Ch, 0CCh,  76h,  00h
   314 00000B41 003C603C66663C00    <1> 	db	 00h,  3Ch,  60h,  3Ch,  66h,  66h,  3Ch,  00h
   315 00000B49 00007C667C667C00    <1> 	db	 00h,  00h,  7Ch,  66h,  7Ch,  66h,  7Ch,  00h
   316 00000B51 00007E6060606000    <1> 	db	 00h,  00h,  7Eh,  60h,  60h,  60h,  60h,  00h
   317 00000B59 00003C6C6C6CFEC6    <1> 	db	 00h,  00h,  3Ch,  6Ch,  6Ch,  6Ch, 0FEh, 0C6h
   318 00000B61 00003C667E603C00    <1> 	db	 00h,  00h,  3Ch,  66h,  7Eh,  60h,  3Ch,  00h
   319 00000B69 0000DB7E3C7EDB00    <1> 	db	 00h,  00h, 0DBh,  7Eh,  3Ch,  7Eh, 0DBh,  00h
   320 00000B71 00003C660C663C00    <1> 	db	 00h,  00h,  3Ch,  66h,  0Ch,  66h,  3Ch,  00h
   321 00000B79 0000666E7E766600    <1> 	db	 00h,  00h,  66h,  6Eh,  7Eh,  76h,  66h,  00h
   322 00000B81 0018666E7E766600    <1> 	db	 00h,  18h,  66h,  6Eh,  7Eh,  76h,  66h,  00h
   323 00000B89 0000666C786C6600    <1> 	db	 00h,  00h,  66h,  6Ch,  78h,  6Ch,  66h,  00h
   324 00000B91 00001E3666666600    <1> 	db	 00h,  00h,  1Eh,  36h,  66h,  66h,  66h,  00h
   325 00000B99 0000C6FEFED6C600    <1> 	db	 00h,  00h, 0C6h, 0FEh, 0FEh, 0D6h, 0C6h,  00h
   326 00000BA1 000066667E666600    <1> 	db	 00h,  00h,  66h,  66h,  7Eh,  66h,  66h,  00h
   327 00000BA9 00003C6666663C00    <1> 	db	 00h,  00h,  3Ch,  66h,  66h,  66h,  3Ch,  00h
   328 00000BB1 00007E6666666600    <1> 	db	 00h,  00h,  7Eh,  66h,  66h,  66h,  66h,  00h
   329 00000BB9 1144114411441144    <1> 	db	 11h,  44h,  11h,  44h,  11h,  44h,  11h,  44h
   330 00000BC1 55AA55AA55AA55AA    <1> 	db	 55h, 0AAh,  55h, 0AAh,  55h, 0AAh,  55h, 0AAh
   331 00000BC9 DD77DD77DD77DD77    <1> 	db	0DDh,  77h, 0DDh,  77h, 0DDh,  77h, 0DDh,  77h
   332 00000BD1 1818181818181818    <1> 	db	 18h,  18h,  18h,  18h,  18h,  18h,  18h,  18h
   333 00000BD9 181818F818181818    <1> 	db	 18h,  18h,  18h, 0F8h,  18h,  18h,  18h,  18h
   334 00000BE1 18F818F818181818    <1> 	db	 18h, 0F8h,  18h, 0F8h,  18h,  18h,  18h,  18h
   335 00000BE9 363636F636363636    <1> 	db	 36h,  36h,  36h, 0F6h,  36h,  36h,  36h,  36h
   336 00000BF1 000000FE36363636    <1> 	db	 00h,  00h,  00h, 0FEh,  36h,  36h,  36h,  36h
   337 00000BF9 00F818F818181818    <1> 	db	 00h, 0F8h,  18h, 0F8h,  18h,  18h,  18h,  18h
   338 00000C01 36F606F636363636    <1> 	db	 36h, 0F6h,  06h, 0F6h,  36h,  36h,  36h,  36h
   339 00000C09 3636363636363636    <1> 	db	 36h,  36h,  36h,  36h,  36h,  36h,  36h,  36h
   340 00000C11 00FE06F636363636    <1> 	db	 00h, 0FEh,  06h,  0F6h, 36h,  36h,  36h,  36h
   341 00000C19 36F606FE00000000    <1> 	db	 36h, 0F6h,  06h, 0FEh,  00h,  00h,  00h,  00h
   342 00000C21 363636FE00000000    <1> 	db	 36h,  36h,  36h, 0FEh,  00h,  00h,  00h,  00h
   343 00000C29 18F818F800000000    <1> 	db	 18h, 0F8h,  18h, 0F8h,  00h,  00h,  00h,  00h
   344 00000C31 000000F818181818    <1> 	db	 00h,  00h,  00h, 0F8h,  18h,  18h,  18h,  18h
   345 00000C39 1818181F00000000    <1> 	db	 18h,  18h,  18h,  1Fh,  00h,  00h,  00h,  00h
   346 00000C41 181818FF00000000    <1> 	db	 18h,  18h,  18h, 0FFh,  00h,  00h,  00h,  00h
   347 00000C49 000000FF18181818    <1> 	db	 00h,  00h,  00h, 0FFh,  18h,  18h,  18h,  18h
   348 00000C51 1818181F18181818    <1> 	db	 18h,  18h,  18h,  1Fh,  18h,  18h,  18h,  18h
   349 00000C59 000000FF00000000    <1> 	db	 00h,  00h,  00h, 0FFh,  00h,  00h,  00h,  00h
   350 00000C61 181818FF18181818    <1> 	db	 18h,  18h,  18h,  0FFh, 18h,  18h,  18h,  18h
   351 00000C69 181F181F18181818    <1> 	db	 18h,  1Fh,  18h,  1Fh,  18h,  18h,  18h,  18h
   352 00000C71 3636363736363636    <1> 	db	 36h,  36h,  36h,  37h,  36h,  36h,  36h,  36h
   353 00000C79 3637303F00000000    <1> 	db	 36h,  37h,  30h,  3Fh,  00h,  00h,  00h,  00h
   354 00000C81 003F303736363636    <1> 	db	 00h,  3Fh,  30h,  37h,  36h,  36h,  36h,  36h
   355 00000C89 36F700FF00000000    <1> 	db	 36h, 0F7h,  00h, 0FFh,  00h,  00h,  00h,  00h
   356 00000C91 00FF00F736363636    <1> 	db	 00h, 0FFh,  00h, 0F7h,  36h,  36h,  36h,  36h
   357 00000C99 3637303736363636    <1> 	db	 36h,  37h,  30h,  37h,  36h,  36h,  36h,  36h
   358 00000CA1 00FF00FF00000000    <1> 	db	 00h, 0FFh,  00h, 0FFh,  00h,  00h,  00h,  00h
   359 00000CA9 36F700F736363636    <1> 	db	 36h, 0F7h,  00h, 0F7h,  36h,  36h,  36h,  36h
   360 00000CB1 18FF00FF00000000    <1> 	db	 18h, 0FFh,  00h, 0FFh,  00h,  00h,  00h,  00h
   361 00000CB9 363636FF00000000    <1> 	db	 36h,  36h,  36h, 0FFh,  00h,  00h,  00h,  00h
   362 00000CC1 00FF00FF18181818    <1> 	db	 00h, 0FFh,  00h, 0FFh,  18h,  18h,  18h,  18h
   363 00000CC9 000000FF36363636    <1> 	db	 00h,  00h,  00h, 0FFh,  36h,  36h,  36h,  36h
   364 00000CD1 3636363F00000000    <1> 	db	 36h,  36h,  36h,  3Fh,  00h,  00h,  00h,  00h
   365 00000CD9 181F181F00000000    <1> 	db	 18h,  1Fh,  18h,  1Fh,  00h,  00h,  00h,  00h
   366 00000CE1 001F181F18181818    <1> 	db	 00h,  1Fh,  18h,  1Fh,  18h,  18h,  18h,  18h
   367 00000CE9 0000003F36363636    <1> 	db	 00h,  00h,  00h,  3Fh,  36h,  36h,  36h,  36h
   368 00000CF1 363636FF36363636    <1> 	db	 36h,  36h,  36h, 0FFh,  36h,  36h,  36h,  36h
   369 00000CF9 18FF18FF18181818    <1> 	db	 18h, 0FFh,  18h, 0FFh,  18h,  18h,  18h,  18h
   370 00000D01 181818F800000000    <1> 	db	 18h,  18h,  18h, 0F8h,  00h,  00h,  00h,  00h
   371 00000D09 0000001F18181818    <1> 	db	 00h,  00h,  00h,  1Fh,  18h,  18h,  18h,  18h
   372 00000D11 FFFFFFFFFFFFFFFF    <1> 	db	0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh
   373 00000D19 000000FFFFFFFFFF    <1> 	db	 00h,  00h,  00h, 0FFh, 0FFh, 0FFh, 0FFh, 0FFh
   374 00000D21 F0F0F0F0F0F0F0F0    <1> 	db	0F0h, 0F0h, 0F0h, 0F0h, 0F0h, 0F0h, 0F0h, 0F0h
   375 00000D29 0F0F0F0F0F0F0F0F    <1> 	db	 0Fh,  0Fh,  0Fh,  0Fh,  0Fh,  0Fh,  0Fh,  0Fh
   376 00000D31 FFFFFF0000000000    <1> 	db	0FFh, 0FFh, 0FFh,  00h,  00h,  00h,  00h,  00h
   377 00000D39 00007C66667C6000    <1> 	db	 00h,  00h,  7Ch,  66h,  66h,  7Ch,  60h,  00h
   378 00000D41 00003C6660663C00    <1> 	db	 00h,  00h,  3Ch,  66h,  60h,  66h,  3Ch,  00h
   379 00000D49 00007E1818181800    <1> 	db	 00h,  00h,  7Eh,  18h,  18h,  18h,  18h,  00h
   380 00000D51 000066663E063C00    <1> 	db	 00h,  00h,  66h,  66h,  3Eh,  06h,  3Ch,  00h
   381 00000D59 00007EDBDB7E1800    <1> 	db	 00h,  00h,  7Eh, 0DBh, 0DBh,  7Eh,  18h,  00h
   382 00000D61 0000663C183C6600    <1> 	db	 00h,  00h,  66h,  3Ch,  18h,  3Ch,  66h,  00h
   383 00000D69 0000666666667F03    <1> 	db	 00h,  00h,  66h,  66h,  66h,  66h,  7Fh,  03h
   384 00000D71 000066663E060600    <1> 	db	 00h,  00h,  66h,  66h,  3Eh,  06h,  06h,  00h
   385 00000D79 0000DBDBDBDBFF00    <1> 	db	 00h,  00h, 0DBh, 0DBh, 0DBh, 0DBh, 0FFh,  00h
   386 00000D81 0000DBDBDBDBFF03    <1> 	db	 00h,  00h, 0DBh, 0DBh, 0DBh, 0DBh, 0FFh,  03h
   387 00000D89 0000E0607C667C00    <1> 	db	 00h,  00h, 0E0h,  60h,  7Ch,  66h,  7Ch,  00h
   388 00000D91 0000C6C6F6DEF600    <1> 	db	 00h,  00h, 0C6h, 0C6h, 0F6h, 0DEh, 0F6h,  00h
   389 00000D99 000060607C667C00    <1> 	db	 00h,  00h,  60h,  60h,  7Ch,  66h,  7Ch,  00h
   390 00000DA1 00007C063E067C00    <1> 	db	 00h,  00h,  7Ch,  06h,  3Eh,  06h,  7Ch,  00h
   391 00000DA9 0000CEDBFBDBCE00    <1> 	db	 00h,  00h, 0CEh, 0DBh, 0FBh, 0DBh, 0CEh,  00h
   392 00000DB1 00003E663E366600    <1> 	db	 00h,  00h,  3Eh,  66h,  3Eh,  36h,  66h,  00h
   393 00000DB9 66007E607C607E00    <1> 	db	 66h,  00h,  7Eh,  60h,  7Ch,  60h,  7Eh,  00h
   394 00000DC1 24003C667E603C00    <1> 	db	 24h,  00h,  3Ch,  66h,  7Eh,  60h,  3Ch,  00h
   395 00000DC9 0030180C060C1830    <1> 	db	 00h,  30h,  18h,  0Ch,  06h,  0Ch,  18h,  30h
   396 00000DD1 000C18306030180C    <1> 	db	 00h,  0Ch,  18h,  30h,  60h,  30h,  18h,  0Ch
   397 00000DD9 0E1B1B1818181818    <1> 	db	 0Eh,  1Bh,  1Bh,  18h,  18h,  18h,  18h,  18h
   398 00000DE1 1818181818D8D870    <1> 	db	 18h,  18h,  18h,  18h,  18h, 0D8h, 0D8h,  70h
   399 00000DE9 001818007E001818    <1> 	db	 00h,  18h,  18h,  00h,  7Eh,  00h,  18h,  18h
   400 00000DF1 0076DC0076DC0000    <1> 	db	 00h,  76h, 0DCh,  00h,  76h, 0DCh,  00h,  00h
   401 00000DF9 00386C6C38000000    <1> 	db	 00h,  38h,  6Ch,  6Ch,  38h,  00h,  00h,  00h
   402 00000E01 0000000018000000    <1> 	db	 00h,  00h,  00h,  00h,  18h,  00h,  00h,  00h
   403 00000E09 0000003838000000    <1> 	db	 00h,  00h,  00h,  38h,  38h,  00h,  00h,  00h
   404 00000E11 03020604CC683810    <1> 	db	 03h,  02h,  06h,  04h, 0CCh,  68h,  38h,  10h
   405 00000E19 3C4299A1A199423C    <1> 	db	 3Ch,  42h,  99h, 0A1h, 0A1h,  99h,  42h,  3Ch
   406 00000E21 3048102078000000    <1> 	db	 30h,  48h,  10h,  20h,  78h,  00h,  00h,  00h
   407 00000E29 00007C7C7C7C0000    <1> 	db	 00h,  00h,  7Ch,  7Ch,  7Ch,  7Ch,  00h,  00h
   408 00000E31 0000000000427E00    <1> 	db	 00h,  00h,  00h,  00h,  00h,  42h,  7Eh,  00h
   257                                  %endif ; MACHINE_XT
   258                                  ;%include	"inttrace.inc"		; Uncomment for interrupt debugging
   259                                  %ifdef AT_RTC
   260                                  %include	"rtc.inc"		; RTC and CMOS read / write functions
   261                              <1> ;=========================================================================
   262                              <1> ; rtc.inc - RTC/CMOS read and write functions
   263                              <1> ;-------------------------------------------------------------------------
   264                              <1> ;
   265                              <1> ; Compiles with NASM 2.13.02, might work with other versions
   266                              <1> ;
   267                              <1> ; Copyright (C) 2010 - 2023 Sergey Kiselev.
   268                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
   269                              <1> ;
   270                              <1> ; This program is free software: you can redistribute it and/or modify
   271                              <1> ; it under the terms of the GNU General Public License as published by
   272                              <1> ; the Free Software Foundation, either version 3 of the License, or
   273                              <1> ; (at your option) any later version.
   274                              <1> ;
   275                              <1> ; This program is distributed in the hope that it will be useful,
   276                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   277                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   278                              <1> ; GNU General Public License for more details.
   279                              <1> ;
   280                              <1> ; You should have received a copy of the GNU General Public License
   281                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   282                              <1> ;
   283                              <1> ;=========================================================================
   284                              <1> 
   285                              <1> ;-------------------------------------------------------------------------
   286                              <1> ; RTC ports
   287                              <1> rtc_addr_reg	equ	70h	; RTC address port
   288                              <1> rtc_data_reg	equ	71h	; RTC data port
   289                              <1> 
   290                              <1> ;-------------------------------------------------------------------------
   291                              <1> ; locations in RTC and NVRAM
   292                              <1> cmos_seconds	equ	00h	; seconds location in RTC
   293                              <1> cmos_alarm_secs	equ	01h	; alarm seconds location in RTC
   294                              <1> cmos_minutes	equ	02h	; minutes location in RTC
   295                              <1> cmos_alarm_mins	equ	03h	; alarm minutes location in RTC
   296                              <1> cmos_hours	equ	04h	; hours locaiton in RTC
   297                              <1> cmos_alarm_hrs	equ	05h	; alarm hours location in RTC
   298                              <1> cmos_day	equ	06h	; day location in RTC
   299                              <1> cmos_date	equ	07h	; date location in RTC
   300                              <1> cmos_month	equ	08h	; month location in RTC
   301                              <1> cmos_year	equ	09h	; year location in RTC
   302                              <1> cmos_floppy	equ	10h	; floppy type byte
   303                              <1> cmos_equip	equ	14h	; equipment byte
   304                              <1> cmos_config_a	equ	2Dh	; BIOS configuration byte A
   305                              <1> cmos_sum_hi	equ	2Eh	; checksum of bytes 10h - 20h - high byte
   306                              <1> cmos_sum_lo	equ	2Fh	; checksum of bytes 10h - 20h - low byte 
   307                              <1> cmos_century	equ	32h	; centry location in RTC (DS12C887 only)
   308                              <1> 
   309                              <1> ;-------------------------------------------------------------------------
   310                              <1> ; RTC control register and their bits
   311                              <1> cmos_control_a	equ	0Ah	; RTC control A register
   312                              <1> cmos_uip	equ	80h	; RTC update in progress bit
   313                              <1> cmos_control_b	equ	0Bh	; RTC control B register
   314                              <1> cmos_dse	equ	01h	; RTC daylight savings enable bit
   315                              <1> cmos_24hours	equ	02h	; RTC 24 hours format (1 = 24 hours, 0 = 12)
   316                              <1> cmos_uie	equ	10h	; RTC update ended interrupt enable bit
   317                              <1> cmos_aie	equ	20h	; RTC alarm interrupt enable bit
   318                              <1> cmos_pie	equ	40h	; RTC periodic interrupt enable bit
   319                              <1> cmos_set	equ	80h	; RTC set bit (0 = normal operation, 1 = set)
   320                              <1> cmos_control_c	equ	0Ch	; RTC control C register
   321                              <1> cmos_uf		equ	20h	; RTC update ended interrupt flag
   322                              <1> cmos_af		equ	40h	; RTC alarm interrupt flag
   323                              <1> cmos_pf		equ	80h	; RTC periodic interrupt flag
   324                              <1> cmos_control_d	equ	0Dh	; RTC control D register
   325                              <1> cmos_vrt	equ	80h	; RTC vrt bit (1 = battery is OK)
   326                              <1> 
   327                              <1> ;=========================================================================
   328                              <1> ; rtc_read - Read byte from RTC or CMOS memory
   329                              <1> ; Input:
   330                              <1> ;	AL - address and NMI enable bit
   331                              <1> ;		bits 6-0 - address of byte to read
   332                              <1> ;		bit 7    - 0 = disable NMI, 1 = enable NMI
   333                              <1> ; Output:
   334                              <1> ;	AL = byte from RTC
   335                              <1> ;-------------------------------------------------------------------------
   336                              <1> rtc_read:
   337 00000E39 FA                  <1> 	cli
   338 00000E3A E670                <1> 	out	rtc_addr_reg,al
   339 00000E3C EB00                <1> 	jmp	$+2
   340 00000E3E EB00                <1> 	jmp	$+2
   341 00000E40 EB00                <1> 	jmp	$+2
   342 00000E42 EB00                <1> 	jmp	$+2
   343 00000E44 E471                <1> 	in	al,rtc_data_reg
   344 00000E46 FB                  <1> 	sti
   345 00000E47 C3                  <1> 	ret
   346                              <1> 
   347                              <1> ;=========================================================================
   348                              <1> ; rtc_write - Read byte to RTC or CMOS memory
   349                              <1> ; Input:
   350                              <1> ;	AL - address and NMI enable bit
   351                              <1> ;		bits 6-0 - address of byte to read
   352                              <1> ;		bit 7    - 0 = disable NMI, 1 = enable NMI
   353                              <1> ;	AH = byte to write to RTC
   354                              <1> ;-------------------------------------------------------------------------
   355                              <1> rtc_write:
   356 00000E48 FA                  <1> 	cli
   357 00000E49 E670                <1> 	out	rtc_addr_reg,al
   358 00000E4B EB00                <1> 	jmp	$+2
   359 00000E4D EB00                <1> 	jmp	$+2
   360 00000E4F EB00                <1> 	jmp	$+2
   361 00000E51 EB00                <1> 	jmp	$+2
   362 00000E53 86E0                <1> 	xchg	ah,al
   363 00000E55 E671                <1> 	out	rtc_data_reg,al
   364 00000E57 86E0                <1> 	xchg	ah,al
   365 00000E59 FB                  <1> 	sti
   366 00000E5A C3                  <1> 	ret
   367                              <1> 
   368                              <1> ;=========================================================================
   369                              <1> ; set_system_timer - set timer variables to RTC time
   370                              <1> ;-------------------------------------------------------------------------
   371                              <1> set_system_timer:
   372 00000E5B 50                  <1> 	push	ax
   373 00000E5C 53                  <1> 	push	bx
   374 00000E5D 51                  <1> 	push	cx
   375 00000E5E 52                  <1> 	push	dx
   376 00000E5F 56                  <1> 	push	si
   377 00000E60 57                  <1> 	push	di
   378                              <1> 
   379 00000E61 B402                <1> 	mov	ah,02h			; int 1Ah, function 02h - get RTC time
   380 00000E63 CD1A                <1> 	int	1Ah
   381                              <1> 
   382                              <1> ; convert time to ticks * 2^11
   383                              <1> 
   384                              <1> ; ticks = seconds * 37287
   385 00000E65 88F0                <1> 	mov	al,dh
   386 00000E67 E8B000              <1> 	call	bcd_to_binary		; convert seconds to binary
   387                              <1> 
   388 00000E6A BAA791              <1> 	mov	dx,37287
   389 00000E6D F7E2                <1> 	mul	dx			; DX:AX = seconds * 37287
   390                              <1> 
   391 00000E6F 89C6                <1> 	mov	si,ax
   392 00000E71 89D7                <1> 	mov	di,dx
   393                              <1> 
   394                              <1> ; ticks += minutes * 2237216 = minutes * 8992 + minutes * 34 * 2^16
   395 00000E73 88C8                <1> 	mov	al,cl
   396 00000E75 E8A200              <1> 	call	bcd_to_binary		; convert minutes to binary
   397                              <1> 
   398 00000E78 89C3                <1> 	mov	bx,ax
   399 00000E7A BA2023              <1> 	mov	dx,8992
   400 00000E7D F7E2                <1> 	mul	dx			; DX:AX = minutes * 8992
   401                              <1> 
   402 00000E7F 01C6                <1> 	add	si,ax
   403 00000E81 11D7                <1> 	adc	di,dx
   404                              <1> 
   405 00000E83 89D8                <1> 	mov	ax,bx
   406 00000E85 BA2200              <1> 	mov	dx,34
   407 00000E88 F7E2                <1> 	mul	dx
   408                              <1> 
   409 00000E8A 01C7                <1> 	add	di,ax
   410                              <1> 
   411                              <1> ; ticks += hours * 134232938 = hours * 15210 + hours * 2048 * 2^16
   412 00000E8C 88E8                <1> 	mov	al,ch
   413 00000E8E E88900              <1> 	call	bcd_to_binary		; convert hours to binary
   414                              <1> 
   415 00000E91 89C3                <1> 	mov	bx,ax
   416 00000E93 BA6A3B              <1> 	mov	dx,15210
   417 00000E96 F7E2                <1> 	mul	dx			; DX:AX = hours * 15210
   418                              <1> 
   419 00000E98 01C6                <1> 	add	si,ax
   420 00000E9A 11D7                <1> 	adc	di,dx
   421                              <1> 
   422 00000E9C 89D8                <1> 	mov	ax,bx
   423 00000E9E BA0008              <1> 	mov	dx,2048
   424 00000EA1 F7E2                <1> 	mul	dx			; AX = hours * 2048
   425                              <1> 
   426 00000EA3 01C7                <1> 	add	di,ax
   427                              <1> 
   428                              <1> ; CX:DX = DI:SI / 2048
   429 00000EA5 B10B                <1> 	mov	cl,11
   430 00000EA7 D3EE                <1> 	shr	si,cl
   431 00000EA9 89FA                <1> 	mov	dx,di
   432 00000EAB B105                <1> 	mov	cl,5
   433 00000EAD D3E2                <1> 	shl	dx,cl
   434 00000EAF 09F2                <1> 	or	dx,si
   435                              <1> 
   436 00000EB1 B10B                <1> 	mov	cl,11
   437 00000EB3 D3EF                <1> 	shr	di,cl
   438 00000EB5 89F9                <1> 	mov	cx,di
   439                              <1> 
   440                              <1> 					; CX = high word of tick count
   441                              <1> 					; DX = low word of tick count
   442                              <1> 	
   443 00000EB7 B401                <1> 	mov	ah,01h			; int 1Ah, function 01h - set time
   444 00000EB9 CD1A                <1> 	int	1Ah
   445 00000EBB 5F                  <1> 	pop	di
   446 00000EBC 5E                  <1> 	pop	si
   447 00000EBD 5A                  <1> 	pop	dx
   448 00000EBE 59                  <1> 	pop	cx
   449 00000EBF 5B                  <1> 	pop	bx
   450 00000EC0 58                  <1> 	pop	ax
   451 00000EC1 C3                  <1> 	ret
   452                              <1> 
   453                              <1> ;=========================================================================
   454                              <1> ; rtc_init - Initialize RTC
   455                              <1> ; Notes:
   456                              <1> ;	- makes sure RTC battery is OK, resets time if not
   457                              <1> ;	- disables RTC interrupts
   458                              <1> ;	- validates NVRAM checksum, loads default values if invalid
   459                              <1> ;-------------------------------------------------------------------------
   460                              <1> rtc_init:
   461 00000EC2 50                  <1> 	push	ax
   462 00000EC3 53                  <1> 	push	bx
   463 00000EC4 51                  <1> 	push	cx
   464 00000EC5 52                  <1> 	push	dx
   465 00000EC6 56                  <1> 	push	si
   466 00000EC7 B020                <1> 	mov	al,e_rtc_init
   467 00000EC9 E680                <1> 	out	post_reg,al
   468 00000ECB B00A                <1> 	mov	al,cmos_control_a	; select control A register
   469 00000ECD B426                <1> 	mov	ah,26h			; turn on oscillator and time keeping
   470                              <1> 					; set SQW frequency to 1.024 KHz
   471 00000ECF E876FF              <1> 	call	rtc_write		; write control register A
   472                              <1> 
   473                              <1> %ifdef AT_RTC_AUTODETECT
   474 00000ED2 E864FF              <1> 	call	rtc_read		; read back control A register
   475 00000ED5 3C26                <1> 	cmp	al,26h
   476 00000ED7 753B                <1> 	jne	.exit			; RTC is not responding, exit
   477                              <1> %endif ; AT_RTC_AUTODETECT
   478                              <1> 
   479 00000ED9 B00B                <1> 	mov	al,cmos_control_b
   480 00000EDB E85BFF              <1> 	call	rtc_read
   481 00000EDE 88C4                <1> 	mov	ah,al
   482 00000EE0 80E401              <1> 	and	ah,cmos_dse		; clear all bits except of DSE
   483 00000EE3 80CC02              <1> 	or	ah,cmos_24hours		; set 24 hours bit, keep BCD format and
   484                              <1> 					; interrupts disabled
   485 00000EE6 B00B                <1> 	mov	al,cmos_control_b
   486 00000EE8 E85DFF              <1> 	call	rtc_write		; write control register B
   487                              <1> 
   488 00000EEB B00C                <1> 	mov	al,cmos_control_c
   489 00000EED E849FF              <1> 	call	rtc_read		; read control register C - reset
   490                              <1> 					; interrupt flags
   491                              <1> 
   492 00000EF0 B00D                <1> 	mov	al,cmos_control_d
   493 00000EF2 E844FF              <1> 	call	rtc_read		; read control register D
   494 00000EF5 A880                <1> 	test	al,cmos_vrt
   495 00000EF7 7518                <1> 	jnz	.1			; RTC battery is OK
   496 00000EF9 BE[4404]            <1> 	mov	si,msg_rtc_bad
   497 00000EFC E81719              <1> 	call	print
   498                              <1> ; RTC is bad, set initial time
   499 00000EFF B403                <1> 	mov	ah,03h			; int 1Ah, function 03h - set RTC time
   500 00000F01 31C9                <1> 	xor	cx,cx
   501 00000F03 31D2                <1> 	xor	dx,dx
   502 00000F05 CD1A                <1> 	int	1Ah
   503 00000F07 B405                <1> 	mov	ah,05h			; int 1Ah, function 05h - set RTC date
   504 00000F09 B91020              <1> 	mov	cx,2010h		; year 2010
   505 00000F0C BA0101              <1> 	mov	dx,0101h		; January 1st
   506 00000F0F CD1A                <1> 	int	1Ah
   507                              <1> 
   508                              <1> .1:
   509                              <1> 
   510 00000F11 E847FF              <1> 	call	set_system_timer		; set timer variables to RTC time
   511                              <1> 
   512                              <1> %ifdef AT_RTC_NVRAM
   513                              <1> ; compare NVRAM checksum with stored value
   514                              <1> 
   515                              <1> 	call	nvram_checksum
   516                              <1> 
   517                              <1> 	mov	al,cmos_sum_hi
   518                              <1> 	call	rtc_read
   519                              <1> 	mov	ah,al
   520                              <1> 	mov	al,cmos_sum_lo
   521                              <1> 	call	rtc_read
   522                              <1> 	cmp	bx,ax
   523                              <1> 	je	.update_equipment
   524                              <1> 
   525                              <1> 	mov	si,msg_rtc_sum
   526                              <1> 	call	print
   527                              <1> 
   528                              <1> ; clear NVRAM
   529                              <1> 
   530                              <1> 	mov	ax,0010h		; start from 10h, load 00h
   531                              <1> 
   532                              <1> .nvram_clear_loop:
   533                              <1> 	call	rtc_write
   534                              <1> 	inc	al
   535                              <1> 	cmp	al,20h			; last address is 20h
   536                              <1> 	jbe	.nvram_clear_loop
   537                              <1> 
   538                              <1> 	mov	al,cmos_floppy		; write default floppy type
   539                              <1>     cs	mov	ah,byte [default_floppy]
   540                              <1> 	call	rtc_write
   541                              <1> 
   542                              <1> 	mov	al,cmos_equip		; write default equipment byte
   543                              <1>     cs	mov	ah,byte [default_equip]
   544                              <1> 	call	rtc_write
   545                              <1> 
   546                              <1> ; update checksum
   547                              <1> 
   548                              <1> 	call	nvram_checksum
   549                              <1> 
   550                              <1> 	mov	al,cmos_sum_hi
   551                              <1> 	mov	ah,bh
   552                              <1> 	call	rtc_write
   553                              <1> 
   554                              <1> 	inc	al			; AL = cmos_sum_lo
   555                              <1> 	mov	ah,bl
   556                              <1> 	call	rtc_write
   557                              <1> 
   558                              <1> ; read equipment byte from NVRAM and set it in BIOS data area
   559                              <1> 
   560                              <1> .update_equipment:
   561                              <1> 	mov	al,cmos_equip
   562                              <1> 	call	rtc_read
   563                              <1> 	and	al,~(equip_video|equip_mouse)   ; these are autodetected
   564                              <1> 	and	byte [equipment_list],equip_video|equip_mouse
   565                              <1> 	or	byte [equipment_list],al
   566                              <1> 
   567                              <1> %endif ; AT_RTC_NVRAM
   568                              <1> 
   569                              <1> .exit:
   570 00000F14 5E                  <1> 	pop	si
   571 00000F15 5A                  <1> 	pop	dx
   572 00000F16 59                  <1> 	pop	cx
   573 00000F17 5B                  <1> 	pop	bx
   574 00000F18 58                  <1> 	pop	ax
   575 00000F19 C3                  <1> 	ret
   576                              <1> 
   577                              <1> bcd_to_binary:
   578 00000F1A 51                  <1> 	push	cx
   579 00000F1B 88C5                <1> 	mov	ch,al
   580 00000F1D 80E50F              <1> 	and	ch,0Fh
   581 00000F20 B104                <1> 	mov	cl,4
   582 00000F22 D2E8                <1> 	shr	al,cl
   583 00000F24 B10A                <1> 	mov	cl,10
   584 00000F26 F6E1                <1> 	mul	cl
   585 00000F28 00E8                <1> 	add	al,ch
   586 00000F2A 59                  <1> 	pop	cx
   587 00000F2B C3                  <1> 	ret
   588                              <1> 
   589                              <1> %ifdef AT_RTC_NVRAM
   590                              <1> ;=========================================================================
   591                              <1> ; nvram_checksum - calculate NVRAM checksum
   592                              <1> ; Input:
   593                              <1> ;	none
   594                              <1> ; Output:
   595                              <1> ;	BX = NVRAM checksum
   596                              <1> ;-------------------------------------------------------------------------
   597                              <1> nvram_checksum:
   598                              <1> 	push	ax
   599                              <1> 	xor	bx,bx
   600                              <1> 	mov	ah,10h			; start from 10h
   601                              <1> 
   602                              <1> .checksum_loop:
   603                              <1> 	mov	al,ah
   604                              <1> 	call	rtc_read
   605                              <1> 	add	bl,al			; BX += AL
   606                              <1> 	adc	bh,0
   607                              <1> 	inc	ah
   608                              <1> 	cmp	ah,20h			; last address is 20h
   609                              <1> 	jbe	.checksum_loop
   610                              <1> 	pop	ax
   611                              <1> 	ret
   612                              <1> 
   613                              <1> ;=========================================================================
   614                              <1> ; nvram_save - Save configuration to CMOS memory
   615                              <1> ; Input:
   616                              <1> ;	CH - CPU Clock speed
   617                              <1> ;	     0 - 4.77 Mhz / Normal
   618                              <1> ;	     1 - 7.16 Mhz / Turbo
   619                              <1> ;	     2 - 9.55 Mhz (FE2010A only)
   620                              <1> ;
   621                              <1> ;	CL - CMOS floppy drive type
   622                              <1> ;	     7-4 - first floppy drive type
   623                              <1> ;	     3-0 - second floppy drive type
   624                              <1> ;-------------------------------------------------------------------------
   625                              <1> nvram_save:
   626                              <1> 	push	ax
   627                              <1> 	push	bx
   628                              <1> 
   629                              <1> 	mov	al,cmos_config_a
   630                              <1> 	mov	ah,ch
   631                              <1> 	call	rtc_write
   632                              <1> 
   633                              <1> 	mov	al,cmos_floppy
   634                              <1> 	mov	ah,cl
   635                              <1> 	call	rtc_write
   636                              <1> 
   637                              <1> 	mov	ah,byte [equipment_list]
   638                              <1> 	and	ah,03Eh			; mask floppy bits
   639                              <1> 
   640                              <1> 	test	cl,70h
   641                              <1> 	jz	.second_floppy		; jump if first floppy is not installed
   642                              <1> 	or	ah,01h			; first floppy is installed
   643                              <1> 
   644                              <1> .second_floppy:
   645                              <1> 	test	cl,07h
   646                              <1> 	jz	.save_equipment		; jump if second floppy is not installed
   647                              <1> 	or	ah,41h			; indicate two floppies
   648                              <1> 					; (even if the first one is missing)
   649                              <1> 
   650                              <1> .save_equipment:
   651                              <1> 	mov	byte [equipment_list],ah
   652                              <1> 	mov	al,cmos_equip
   653                              <1> 	call	rtc_write
   654                              <1> 
   655                              <1> 	call	nvram_checksum
   656                              <1> 
   657                              <1> 	mov	al,cmos_sum_hi
   658                              <1> 	mov	ah,bh
   659                              <1> 	call	rtc_write
   660                              <1> 
   661                              <1> 	inc	al			; AL = cmos_sum_lo
   662                              <1> 	mov	ah,bl
   663                              <1> 	call	rtc_write
   664                              <1> 
   665                              <1> 	pop	bx
   666                              <1> 	pop	ax
   667                              <1> 	ret
   668                              <1> 
   669                              <1> ;=========================================================================
   670                              <1> ; get_config_a - Return BIOS configuration byte A from NVRAM
   671                              <1> ; Input:
   672                              <1> ;	none
   673                              <1> ; Output:
   674                              <1> ;	AL - NVRAM CPU clock frequency configuration setting
   675                              <1> ;		0 - 4.77 MHz / Normal
   676                              <1> ;		1 - 7.16 MHz / Turbo
   677                              <1> ;		2 - 9.55 MHz (FE2010 only)
   678                              <1> ;-------------------------------------------------------------------------
   679                              <1> get_config_a:
   680                              <1> 	mov	al,cmos_config_a	; read BIOS configuration byte A
   681                              <1> 	call	rtc_read
   682                              <1> 	ret
   683                              <1>   
   684                              <1> ;=========================================================================
   685                              <1> ; get_floppy - Return floppy drive type from NVRAM
   686                              <1> ; Input:
   687                              <1> ;	none
   688                              <1> ; Output:
   689                              <1> ;	AL = floppy drive type
   690                              <1> ;-------------------------------------------------------------------------
   691                              <1> get_floppy:
   692                              <1> 	mov     al,cmos_floppy
   693                              <1> 	call    rtc_read		; read currently configured floppies
   694                              <1> 	ret
   695                              <1> 
   696                              <1> %endif ; AT_RTC_NVRAM
   697                              <1> 
   698                              <1> ;=========================================================================
   699                              <1> ; print_rtc - print current RTC date and time
   700                              <1> ; Input:
   701                              <1> ;	none
   702                              <1> ; Output:
   703                              <1> ;	date and time are printed in YYYY-MM-DD hh:mm:ss format
   704                              <1> ; Notes:
   705                              <1> ;	There is a slight probability of getting inconsistent printout.
   706                              <1> ;	In case the function is called just before midnight, it could
   707                              <1> ;	print the previos day's date and next day's time.
   708                              <1> ;-------------------------------------------------------------------------
   709                              <1> print_rtc:
   710 00000F2C 50                  <1> 	push	ax
   711 00000F2D 53                  <1> 	push	bx
   712 00000F2E 51                  <1> 	push	cx
   713 00000F2F 52                  <1> 	push	dx
   714 00000F30 56                  <1> 	push	si
   715 00000F31 BE[7702]            <1> 	mov	si,msg_rtc
   716 00000F34 E8DF18              <1> 	call	print
   717                              <1> 
   718                              <1> %ifdef AT_RTC_AUTODETECT
   719 00000F37 E86400              <1> 	call	rtc_detect
   720 00000F3A 7308                <1> 	jnc	.rtc_present
   721 00000F3C BE[1503]            <1> 	mov	si,msg_absent
   722 00000F3F E8D418              <1> 	call	print
   723 00000F42 EB54                <1> 	jmp	.exit
   724                              <1> .rtc_present:
   725                              <1> %endif ; AT_RTC_AUTODETECT
   726                              <1> 
   727                              <1> ; print date
   728 00000F44 B404                <1> 	mov	ah,04h
   729 00000F46 CD1A                <1> 	int	1Ah			; read RTC date
   730                              <1> 					; CH = BCD century
   731                              <1> 					; CL = BCD year
   732                              <1> 					; DH = BCD month
   733                              <1> 					; DL = BCD date (day of month)
   734 00000F48 89C8                <1> 	mov	ax,cx
   735 00000F4A E8E418              <1> 	call	print_hex		; print 4-digit year
   736 00000F4D B82D0E              <1> 	mov	ax,(0Eh << 8) + '-'
   737 00000F50 BB0700              <1> 	mov	bx,0007h
   738 00000F53 CD10                <1> 	int	10h			; print dash (-)
   739                              <1> 
   740 00000F55 88F0                <1> 	mov	al,dh
   741 00000F57 E8E218              <1> 	call	print_byte		; print 2-digit month
   742 00000F5A B82D0E              <1> 	mov	ax,(0Eh << 8) + '-'
   743 00000F5D BB0700              <1> 	mov	bx,0007h
   744 00000F60 CD10                <1> 	int	10h			; print dash (-)
   745                              <1> 
   746 00000F62 88D0                <1> 	mov	al,dl
   747 00000F64 E8D518              <1> 	call	print_byte		; print 2-digit date (day of month)
   748                              <1> 
   749 00000F67 B8200E              <1> 	mov	ax,(0Eh << 8) + ' '
   750 00000F6A BB0700              <1> 	mov	bx,0007h
   751 00000F6D CD10                <1> 	int	10h			; print space ( )
   752                              <1> 
   753                              <1> ; print time
   754 00000F6F B402                <1> 	mov	ah,02h
   755 00000F71 CD1A                <1> 	int	1Ah			; read RTC time
   756                              <1> 					; CH = BCD hours
   757                              <1> 					; CL = BCD minutes
   758                              <1> 					; DH = BCD seconds
   759                              <1> 					; DL = daylight saving flag
   760 00000F73 88E8                <1> 	mov	al,ch
   761 00000F75 E8C418              <1> 	call	print_byte		; print 2-digit hours
   762                              <1> 	
   763 00000F78 B83A0E              <1> 	mov	ax,(0Eh << 8) + ':'
   764 00000F7B BB0700              <1> 	mov	bx,0007h
   765 00000F7E CD10                <1> 	int	10h			; print colon (:)
   766                              <1> 
   767 00000F80 88C8                <1> 	mov	al,cl
   768 00000F82 E8B718              <1> 	call	print_byte		; print 2-digit minutes
   769                              <1> 	
   770 00000F85 B83A0E              <1> 	mov	ax,(0Eh << 8) + ':'
   771 00000F88 BB0700              <1> 	mov	bx,0007h
   772 00000F8B CD10                <1> 	int	10h			; print colon (:)
   773                              <1> 
   774 00000F8D 88F0                <1> 	mov	al,dh
   775 00000F8F E8AA18              <1> 	call	print_byte		; print 2-digit seconds
   776 00000F92 BE[8B00]            <1> 	mov	si,msg_crlf
   777 00000F95 E87E18              <1> 	call	print
   778                              <1> 
   779                              <1> .exit:
   780 00000F98 5E                  <1> 	pop	si
   781 00000F99 5A                  <1> 	pop	dx
   782 00000F9A 59                  <1> 	pop	cx
   783 00000F9B 5B                  <1> 	pop	bx
   784 00000F9C 58                  <1> 	pop	ax
   785 00000F9D C3                  <1> 	ret
   786                              <1> 
   787                              <1> %ifdef AT_RTC_AUTODETECT
   788                              <1> ;=========================================================================
   789                              <1> ; rtc_detect - Check RTC is present at 0x70 port
   790                              <1> ; Input:
   791                              <1> ;	none
   792                              <1> ; Output:
   793                              <1> ;	CF == 0 - RTC is present
   794                              <1> ;	CF == 1 - RTC is not detected
   795                              <1> ;-------------------------------------------------------------------------
   796                              <1> rtc_detect:
   797 00000F9E 50                  <1> 	push ax
   798 00000F9F B00A                <1> 	mov	al,cmos_control_a	; select control A register
   799 00000FA1 E895FE              <1> 	call    rtc_read		; check if RTC is present
   800 00000FA4 3C26                <1> 	cmp     al,26h
   801 00000FA6 7403                <1> 	je	.rtc_present
   802 00000FA8 F9                  <1> 	stc				; no RTC - set CF
   803 00000FA9 EB01                <1> 	jmp	.exit
   804                              <1> 
   805                              <1> .rtc_present:
   806 00000FAB F8                  <1> 	clc				; RTC detected - clear CF
   807                              <1> 
   808                              <1> .exit:
   809 00000FAC 58                  <1> 	pop ax
   810 00000FAD C3                  <1> 	ret
   811                              <1> %endif ; AT_RTC_AUTODETECT
   261                                  %endif ; AT_RTC
   262                                  %ifdef FLASH_NVRAM
   263                                  %include	"flash.inc"		; Flash ROM configuration functions
   264                              <1> ;=========================================================================
   265                              <1> ; flash.inc - Flash ROM programming functions
   266                              <1> ;-------------------------------------------------------------------------
   267                              <1> ;
   268                              <1> ; Compiles with NASM 2.13.02, might work with other versions
   269                              <1> ;
   270                              <1> ; Copyright (C) 2010 - 2023 Sergey Kiselev.
   271                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
   272                              <1> ;
   273                              <1> ; This program is free software: you can redistribute it and/or modify
   274                              <1> ; it under the terms of the GNU General Public License as published by
   275                              <1> ; the Free Software Foundation, either version 3 of the License, or
   276                              <1> ; (at your option) any later version.
   277                              <1> ;
   278                              <1> ; This program is distributed in the hope that it will be useful,
   279                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   280                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   281                              <1> ; GNU General Public License for more details.
   282                              <1> ;
   283                              <1> ; You should have received a copy of the GNU General Public License
   284                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   285                              <1> ;
   286                              <1> ;=========================================================================
   287                              <1> 
   288                              <1> config_segment	equ	0000h
   289                              <1> config_space	equ	8000h		; offset of the configuration
   290                              <1> flash_floppy	equ	config_space
   291                              <1> flash_config_a	equ	config_space+01h ; BIOS configuration byte A
   292                              <1> flash_checksum	equ	config_space+0Eh ; 16-bit checksum
   293                              <1> temp_segment	equ	07C0h		; segment for flash writing code
   294                              <1> flash_write	equ	0		; offset for flash writing code
   295                              <1> ;=========================================================================
   296                              <1> ; get_config_a - Return BIOS configuration byte A from Flash ROM
   297                              <1> ;		 configuration area
   298                              <1> ; Input:
   299                              <1> ;	none
   300                              <1> ; Output:
   301                              <1> ;	AL - NVRAM CPU clock frequency configuration setting
   302                              <1> ;		0 - 4.77 MHz / Normal
   303                              <1> ;		1 - 7.16 MHz / Turbo
   304                              <1> ;		2 - 9.55 MHz (FE2010A only)
   305                              <1> ;-------------------------------------------------------------------------
   306                              <1> get_config_a:
   307 00000FAE E81D00              <1> 	call	flash_verify_checksum
   308 00000FB1 7506                <1> 	jnz	.checksum_error		; ZF == 1 - checksum is invalid
   309                              <1> 
   310 00000FB3 2EA00180            <1>     cs	mov	al,byte [flash_config_a] ; return CPU clock configuration
   311 00000FB7 EB04                <1> 	jmp	.exit
   312                              <1> 
   313                              <1> .checksum_error:
   314 00000FB9 2EA0[7D11]          <1>     cs	mov	al,byte [default_config_a] ; load the default configuration
   315                              <1> 
   316                              <1> .exit:
   317 00000FBD C3                  <1> 	ret
   318                              <1>   
   319                              <1> ;=========================================================================
   320                              <1> ; get_floppy - Return floppy drive type from Flash ROM configuration area
   321                              <1> ; Input:
   322                              <1> ;	none
   323                              <1> ; Output:
   324                              <1> ;	AL = floppy drive type
   325                              <1> ;-------------------------------------------------------------------------
   326                              <1> get_floppy:
   327 00000FBE E80D00              <1> 	call	flash_verify_checksum
   328 00000FC1 7506                <1> 	jnz	.checksum_error		; ZF == 0 - checksum is invalid
   329                              <1> 
   330 00000FC3 2EA00080            <1>     cs	mov	al,byte [flash_floppy]	; return floppy type
   331 00000FC7 EB04                <1> 	jmp	.exit
   332                              <1> 
   333                              <1> .checksum_error:
   334 00000FC9 2EA0[7B11]          <1>     cs  mov	al,byte [default_floppy] ; load the default configuration
   335                              <1> 
   336                              <1> .exit:
   337 00000FCD C3                  <1> 	ret
   338                              <1> 
   339                              <1> ;=========================================================================
   340                              <1> ; flash_verify_checksum - Verify that checksum is correct
   341                              <1> ; Input:
   342                              <1> ;	none
   343                              <1> ; Output:
   344                              <1> ;	ZF == 1 - checksum is valid
   345                              <1> ;	ZF == 0 - checksum is invalid
   346                              <1> ;-------------------------------------------------------------------------
   347                              <1> flash_verify_checksum:
   348 00000FCE 51                  <1> 	push	cx
   349 00000FCF 52                  <1> 	push	dx
   350 00000FD0 57                  <1> 	push	di
   351 00000FD1 31D2                <1> 	xor	dx,dx
   352 00000FD3 BF0080              <1> 	mov	di,config_space
   353 00000FD6 B90E00              <1> 	mov	cx,000Eh
   354                              <1> 
   355                              <1> .checksum_loop:				; calculate the 16-bit checksum
   356 00000FD9 2E0215              <1>     cs	add	dl,byte [di]
   357 00000FDC 80D600              <1> 	adc	dh,0
   358 00000FDF 47                  <1> 	inc	di
   359 00000FE0 E2F7                <1> 	loop	.checksum_loop
   360                              <1> 
   361 00000FE2 2E39160E80          <1>     cs	cmp	word [flash_checksum],dx ; compare checksum to the stored value
   362 00000FE7 5F                  <1> 	pop	di
   363 00000FE8 5A                  <1> 	pop	dx
   364 00000FE9 59                  <1> 	pop	cx
   365 00000FEA C3                  <1> 	ret
   366                              <1> 
   367                              <1> ;=========================================================================
   368                              <1> ; flash_save - Save configuration to Flash ROM
   369                              <1> ; Input:
   370                              <1> ;	CH - CPU Clock speed
   371                              <1> ;	     0 - 4.77 Mhz / Normal
   372                              <1> ;	     1 - 7.16 Mhz / Turbo
   373                              <1> ;	     2 - 9.55 Mhz (FE2010A only)
   374                              <1> ;
   375                              <1> ;	CL - CMOS floppy drive type
   376                              <1> ;	     7-4 - first floppy drive type
   377                              <1> ;	     3-0 - second floppy drive type
   378                              <1> ;-------------------------------------------------------------------------
   379                              <1> flash_save:
   380 00000FEB 50                  <1> 	push	ax
   381 00000FEC 52                  <1> 	push	dx
   382 00000FED 56                  <1> 	push	si
   383 00000FEE 57                  <1> 	push	di
   384 00000FEF 1E                  <1> 	push	ds
   385 00000FF0 06                  <1> 	push	es
   386 00000FF1 51                  <1> 	push	cx
   387                              <1> 
   388 00000FF2 BE[F409]            <1> 	mov	si,msg_saving
   389 00000FF5 E81E18              <1> 	call	print
   390                              <1> 
   391 00000FF8 8CC8                <1> 	mov	ax,cs			; ROM segment
   392 00000FFA 8ED8                <1> 	mov	ds,ax
   393 00000FFC B8C007              <1> 	mov	ax,temp_segment		; copy flash_write_code here
   394 00000FFF 8EC0                <1> 	mov	es,ax
   395                              <1> 
   396 00001001 BE[6710]            <1> 	mov	si,flash_write_code
   397 00001004 BF0000              <1> 	mov	di,flash_write
   398 00001007 B91401              <1> 	mov	cx,flash_write_size
   399                              <1> 
   400 0000100A FC                  <1> 	cld
   401 0000100B F3A4                <1>     rep movsb				; copy the flash_write_code
   402                              <1> 
   403 0000100D B80000              <1> 	mov	ax,config_segment	; copy current flash content here
   404 00001010 8EC0                <1> 	mov	es,ax
   405                              <1> 
   406 00001012 BE0080              <1> 	mov	si,config_space
   407 00001015 89F7                <1> 	mov	di,si			; use the same offset
   408 00001017 B90040              <1> 	mov	cx,16384		; maximal flash segment size (Am29F010)
   409                              <1> 
   410 0000101A FC                  <1> 	cld
   411 0000101B F3A4                <1>     rep movsb
   412                              <1> 
   413 0000101D 59                  <1> 	pop	cx			; load the original CX value
   414 0000101E 51                  <1> 	push	cx
   415 0000101F 26882E0180          <1>     es  mov	byte [flash_config_a],ch ; set new BIOS configuration byte A
   416 00001024 26880E0080          <1>     es  mov	byte [flash_floppy],cl	; set new floppy drive type    
   417                              <1>     
   418 00001029 B000                <1> 	mov	al,00h			; zero the rest of
   419 0000102B BF0280              <1> 	mov	di,config_space+2	; the configuration space
   420 0000102E B90C00              <1> 	mov	cx,000Ch
   421                              <1> 
   422 00001031 FC                  <1> 	cld
   423 00001032 F3AA                <1>     rep	stosb
   424                              <1> 
   425 00001034 31D2                <1> 	xor	dx,dx
   426 00001036 BF0080              <1> 	mov	di,config_space
   427 00001039 B90E00              <1> 	mov	cx,000Eh
   428                              <1> 
   429                              <1> .checksum_loop:				; calculate the 16-bit checksum
   430 0000103C 260215              <1>     es	add	dl,byte [di]
   431 0000103F 80D600              <1> 	adc	dh,0
   432 00001042 47                  <1> 	inc	di
   433 00001043 E2F7                <1> 	loop	.checksum_loop
   434 00001045 2689160E80          <1>     es	mov	word [flash_checksum],dx ; store it to the configuration space
   435                              <1> 
   436 0000104A 9A0000C007          <1> 	call	temp_segment:flash_write
   437                              <1> 
   438 0000104F 7208                <1> 	jc	.error
   439                              <1> 
   440 00001051 BE[1C0A]            <1> 	mov	si,msg_save_ok
   441 00001054 E8BF17              <1> 	call	print
   442 00001057 EB06                <1> 	jmp	.exit
   443                              <1> 
   444                              <1> .error:
   445 00001059 BE[210A]            <1> 	mov	si,msg_save_error
   446 0000105C E8B717              <1> 	call	print
   447                              <1> 
   448                              <1> .exit:
   449 0000105F 59                  <1> 	pop	cx
   450 00001060 07                  <1> 	pop	es
   451 00001061 1F                  <1> 	pop	ds
   452 00001062 5F                  <1> 	pop	di
   453 00001063 5E                  <1> 	pop	si
   454 00001064 5A                  <1> 	pop	dx
   455 00001065 58                  <1> 	pop	ax
   456 00001066 C3                  <1> 	ret
   457                              <1> 
   458                              <1> 
   459                              <1> ;=========================================================================
   460                              <1> ; flash_write - Write configuration to Flash ROM
   461                              <1> ;		Must be copied to RAM and run from it
   462                              <1> ; Input:
   463                              <1> ;	Data to write stored at ES:config_space
   464                              <1> ; Output:
   465                              <1> ;	CF clear on success
   466                              <1> ;	CF set on error
   467                              <1> ;	AX,CX,DX,DS,SI,DI trashed
   468                              <1> ;-------------------------------------------------------------------------
   469                              <1> flash_write_code:
   470 00001067 B800F0              <1> 	mov	ax,bioscseg
   471 0000106A 8ED8                <1> 	mov	ds,ax
   472                              <1> 
   473 0000106C FA                  <1> 	cli				; no interrupts while writing flash
   474 0000106D B000                <1> 	mov	al,nmi_disable
   475 0000106F E6A0                <1> 	out	nmi_mask_reg,al		; disable NMIs too
   476                              <1> 
   477 00001071 A10000              <1> 	mov	ax,word [0]		; get data from first two bytes of flash
   478                              <1> 
   479                              <1> ; try to identify Flash ROM using 5555h and 0AAAAh addresses for commands
   480 00001074 BE5555              <1> 	mov	si,5555h
   481 00001077 BFAAAA              <1> 	mov	di,0AAAAh
   482 0000107A C604AA              <1> 	mov	byte [si],0AAh
   483 0000107D C60555              <1> 	mov	byte [di],55h
   484 00001080 C60490              <1> 	mov	byte [si],90h		; enter ID mode command
   485 00001083 B90010              <1> 	mov	cx,1000h
   486                              <1> .delay1:
   487 00001086 E2FE                <1> 	loop	.delay1			; some ICs need 10ms delay
   488 00001088 8B0E0000            <1> 	mov	cx,word [0]		; get device ID
   489 0000108C 39C1                <1> 	cmp	cx,ax			; is it really an ID?
   490 0000108E 7523                <1> 	jne	.select_flash		; yes, try to select the flash type
   491                              <1> 
   492                              <1> ; try to identify Flash ROM using 0555h and 0AAAh addresses for commands
   493 00001090 BE5505              <1> 	mov	si,0555h
   494 00001093 BFAA0A              <1> 	mov	di,0AAAh
   495 00001096 C604AA              <1> 	mov	byte [si],0AAh
   496 00001099 C60555              <1> 	mov	byte [di],55h
   497 0000109C C60490              <1> 	mov	byte [si],90h		; enter ID mode command
   498 0000109F B90010              <1> 	mov	cx,1000h
   499                              <1> .delay2:
   500 000010A2 E2FE                <1> 	loop	.delay2			; some ICs need 10ms delay
   501 000010A4 8B0E0000            <1> 	mov	cx,word [0]		; get device ID
   502 000010A8 39C1                <1> 	cmp	cx,ax			; is it really an ID?
   503 000010AA 7507                <1> 	jne	.select_flash		; yes, try to select the flash type
   504                              <1> 
   505                              <1> ; unable to get Flash ROM ID, return with error
   506                              <1> 
   507                              <1> .error:
   508 000010AC F9                  <1> 	stc
   509 000010AD B080                <1> 	mov	al,nmi_enable
   510 000010AF E6A0                <1> 	out	nmi_mask_reg,al		; enable NMIs
   511 000010B1 FB                  <1> 	sti
   512 000010B2 CB                  <1> 	retf
   513                              <1> 
   514                              <1> .select_flash:
   515 000010B3 C604AA              <1> 	mov	byte[si],0AAh
   516 000010B6 C60555              <1> 	mov	byte[di],55h
   517 000010B9 C604F0              <1> 	mov	byte[si],0F0h		; exit ID mode command
   518                              <1> 
   519                              <1> .try_at29c010:
   520 000010BC 81F91FD5            <1> 	cmp	cx,0D51Fh		; 1F = Atmel, D5 = AT29C010A
   521 000010C0 7505                <1> 	jne	.try_sst29ee010
   522 000010C2 B98000              <1> 	mov	cx,128			; sector size is 128 bytes
   523 000010C5 EB42                <1> 	jmp	short .write_auto_sector
   524                              <1> 
   525                              <1> .try_sst29ee010:
   526 000010C7 81F9BF07            <1> 	cmp	cx,07BFh		; BF = SST, 07 = SST29EE010/GLS29EE010
   527 000010CB 7505                <1> 	jne	.try_w29ee011
   528 000010CD B98000              <1> 	mov	cx,128			; sector size is 128 bytes
   529 000010D0 EB37                <1> 	jmp	short .write_auto_sector
   530                              <1> 
   531                              <1> .try_w29ee011:
   532 000010D2 81F9DAC1            <1> 	cmp	cx,0C1DAh		; DA = Winbond, C1 = W29EE011
   533 000010D6 7505                <1> 	jne	.try_sst39sf010
   534 000010D8 B98000              <1> 	mov	cx,128			; sector size is 128 bytes
   535 000010DB EB2C                <1> 	jmp	short .write_auto_sector
   536                              <1> 
   537                              <1> .try_sst39sf010:
   538 000010DD 81F9BFB5            <1> 	cmp	cx,0B5BFh		; BF = SST, B5 = SST39SF010
   539 000010E1 7505                <1> 	jne	.try_sst39sf020
   540 000010E3 B90010              <1> 	mov	cx,4096			; sector size is 4 KiB
   541 000010E6 EB42                <1> 	jmp	short .write_erase_byte
   542                              <1> 
   543                              <1> .try_sst39sf020:
   544 000010E8 81F9BFB6            <1> 	cmp	cx,0B6BFh		; BF = SST, B6 = SST39SF020
   545 000010EC 7505                <1> 	jne	.try_sst39sf040
   546 000010EE B90010              <1> 	mov	cx,4096			; sector size is 4 KiB
   547 000010F1 EB37                <1> 	jmp	short .write_erase_byte
   548                              <1> 
   549                              <1> .try_sst39sf040:
   550 000010F3 81F9BFB7            <1> 	cmp	cx,0B7BFh		; BF = SST, B7 = SST39SF040
   551 000010F7 7505                <1> 	jne	.try_am29f010
   552 000010F9 B90010              <1> 	mov	cx,4096			; sector size is 4 KiB
   553 000010FC EB2C                <1> 	jmp	short .write_erase_byte
   554                              <1> 
   555                              <1> .try_am29f010:
   556 000010FE 81F90120            <1> 	cmp	cx,2001h		; 01 = AMD, 20 = Am29F010
   557 00001102 75A8                <1> 	jne	.error
   558 00001104 B90040              <1> 	mov	cx,16384		; sector size is 16 KiB
   559 00001107 EB21                <1> 	jmp	short .write_erase_byte
   560                              <1> 
   561                              <1> ; write Flash that auto erases itself and programmed sector by sector
   562                              <1> 
   563                              <1> .write_auto_sector:
   564 00001109 BB0080              <1> 	mov	bx,config_space
   565 0000110C C604AA              <1> 	mov	byte [si],0AAh
   566 0000110F C60555              <1> 	mov	byte [di],55h
   567 00001112 C604A0              <1> 	mov	byte [si],0A0h		; enter write mode
   568                              <1> 
   569                              <1> .write_auto_sector1:
   570 00001115 268A07              <1>     es	mov	al,byte [bx]		; read byte to write
   571 00001118 8807                <1> 	mov	byte [bx],al		; write it to flash
   572 0000111A 43                  <1> 	inc	bx
   573 0000111B E2F8                <1> 	loop	.write_auto_sector1	; write next byte
   574                              <1> 
   575 0000111D 31C9                <1> 	xor	cx,cx
   576 0000111F 4B                  <1> 	dec	bx
   577                              <1> 
   578                              <1> .write_auto_sector2:
   579 00001120 3A07                <1> 	cmp	al,byte [bx]		; wait for write operation to complete
   580 00001122 E0FC                <1> 	loopne	.write_auto_sector2
   581 00001124 09C9                <1> 	or	cx,cx			; CX ?= 0
   582 00001126 7484                <1> 	jz	.error			; write timed out
   583 00001128 EB4A                <1> 	jmp	short .exit
   584                              <1> 
   585                              <1> ; write Flash that requires block erase prior to write, and writen byte by byte
   586                              <1> 	
   587                              <1> .write_erase_byte:
   588 0000112A BB0080              <1> 	mov	bx,config_space
   589 0000112D C604AA              <1> 	mov	byte [si],0AAh
   590 00001130 C60555              <1> 	mov	byte [di],55h
   591 00001133 C60480              <1> 	mov	byte [si],80h		; erase command
   592 00001136 C604AA              <1> 	mov	byte [si],0AAh
   593 00001139 C60555              <1> 	mov	byte [di],055h
   594 0000113C C60730              <1> 	mov	byte [bx],30h		; erase sector command
   595 0000113F 89CA                <1> 	mov	dx,cx			; save sector size to DX
   596 00001141 31C9                <1> 	xor	cx,cx
   597                              <1> 
   598                              <1> .write_erase_byte1:
   599 00001143 B020                <1> 	mov	al,20h			; additional delay
   600                              <1> 					; Am29F010 is slow to erase...
   601                              <1> .write_erase_byte2:
   602 00001145 FEC8                <1> 	dec	al
   603 00001147 75FC                <1> 	jnz	.write_erase_byte2
   604 00001149 803FFF              <1> 	cmp	byte [bx],0FFh		; is it erased yet?
   605 0000114C E0F5                <1> 	loopne	.write_erase_byte1
   606 0000114E 09C9                <1> 	or	cx,cx			; CX ?= 0
   607 00001150 7503E957FF          <1> 	jz	.error			; erase timed out
   608                              <1> 
   609                              <1> .write_erase_byte3:
   610 00001155 C604AA              <1> 	mov	byte [si],0AAh
   611 00001158 C60555              <1> 	mov	byte [di],55h
   612 0000115B C604A0              <1> 	mov	byte [si],0A0h		; enter write mode
   613                              <1> 
   614 0000115E 268A07              <1>     es	mov	al,byte [bx]		; read byte to write
   615 00001161 8807                <1> 	mov	byte [bx],al		; write it to flash
   616 00001163 31C9                <1> 	xor	cx,cx
   617                              <1> 
   618                              <1> .write_erase_byte4:
   619 00001165 3A07                <1> 	cmp	al,byte [bx]		; wait for write operation to complete
   620 00001167 E0FC                <1> 	loopne	.write_erase_byte4
   621 00001169 09C9                <1> 	or	cx,cx			; CX ?= 0
   622 0000116B 7503E93CFF          <1> 	jz	.error			; write timed out
   623                              <1> 
   624 00001170 43                  <1> 	inc	bx
   625 00001171 4A                  <1> 	dec	dx
   626 00001172 75E1                <1> 	jnz	.write_erase_byte3
   627                              <1> 
   628                              <1> .exit:
   629 00001174 F8                  <1> 	clc
   630 00001175 B080                <1> 	mov	al,nmi_enable
   631 00001177 E6A0                <1> 	out	nmi_mask_reg,al		; enable NMIs
   632 00001179 FB                  <1> 	sti
   633 0000117A CB                  <1> 	retf
   634                              <1> 
   635                              <1> flash_write_size	equ	($-flash_write_code)
   636                              <1> %if flash_write_size > ((config_segment << 4) + config_space - (temp_segment << 4))
   637                              <1> %error "flash_write code is too big - try increasing changing config_segment"
   638                              <1> %endif
   264                                  %endif ; FLASH_NVRAM
   265                                  %ifdef BIOS_SETUP
   266                                  %include	"setup.inc"		; NVRAM setup functions
   267                              <1> ;=========================================================================
   268                              <1> ; setup.inc - NVRAM setup functions
   269                              <1> ; Works either with AT-style RTC/NVRAM or with Flash ROM
   270                              <1> ;-------------------------------------------------------------------------
   271                              <1> ;
   272                              <1> ; Compiles with NASM 2.13.02, might work with other versions
   273                              <1> ;
   274                              <1> ; Copyright (C) 2010 - 2023 Sergey Kiselev.
   275                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
   276                              <1> ;
   277                              <1> ; This program is free software: you can redistribute it and/or modify
   278                              <1> ; it under the terms of the GNU General Public License as published by
   279                              <1> ; the Free Software Foundation, either version 3 of the License, or
   280                              <1> ; (at your option) any later version.
   281                              <1> ;
   282                              <1> ; This program is distributed in the hope that it will be useful,
   283                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   284                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   285                              <1> ; GNU General Public License for more details.
   286                              <1> ;
   287                              <1> ; You should have received a copy of the GNU General Public License
   288                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   289                              <1> ;
   290                              <1> ;=========================================================================
   291                              <1> 
   292 0000117B 40                  <1> default_floppy	db	type_1440 << 4	; one 1.44 MB floppy drive
   293 0000117C 21                  <1> default_equip	db	21h		; CGA 80x25, one floppy drive
   294                              <1> %ifdef BIOS_SETUP
   295 0000117D 00                  <1> default_config_a db	00000000b	; NVRAM BIOS configuration byte A
   296                              <1> ;			||||||`---------; 00 = 4.77 MHz / Turbo off
   297                              <1> ;			|||||`----------; 0 = F0000-F7FFF ROM scan enabled
   298                              <1> ;			||||`-----------; 0 = Memory test enabled
   299                              <1> ;                       |||`------------; 0 = Fast wait states for FE2010A
   300                              <1> ;			`---------------; reserved
   301                              <1> nvram_trbo_mask equ	03h		; turbo mask
   302                              <1> nvram_ext_scan	equ	04h		; F0000-F7FFF BIOS extension scan bit
   303                              <1> 					; (0 - enabled, 1 - disabled)
   304                              <1> nvram_mem_test	equ	08h		; Memory test bit
   305                              <1> 					; (0 - enabled, 1 - disabled)
   306                              <1> nvram_fast_ws	equ	10h		; Less wait states for FE2010A 
   307                              <1> 					; (0 - enabled, 1 - disabled)
   308                              <1> %endif ; BIOS_SETUP
   309                              <1> 
   310                              <1> ;=========================================================================
   311                              <1> ; nvram_setup - NVRAM configuration utility
   312                              <1> ; Input:
   313                              <1> ;	none
   314                              <1> ; Output:
   315                              <1> ;	none
   316                              <1> ;-------------------------------------------------------------------------
   317                              <1> nvram_setup:
   318 0000117E 50                  <1> 	push	ax
   319 0000117F 53                  <1> 	push	bx
   320 00001180 51                  <1> 	push	cx
   321 00001181 52                  <1> 	push	dx
   322 00001182 56                  <1> 	push	si
   323                              <1> 
   324 00001183 E828FE              <1> 	call	get_config_a		; read BIOS configuration byte A
   325 00001186 88C5                <1> 	mov	ch,al			; save it to CH
   326 00001188 E833FE              <1> 	call	get_floppy		; read currently configured floppies
   327 0000118B 88C1                <1> 	mov	cl,al			; save it to CL
   328                              <1> 	
   329 0000118D BE[8204]            <1> 	mov	si,msg_set_welcome
   330 00001190 E88316              <1> 	call	print
   331                              <1> 
   332                              <1> .menu_loop:
   333 00001193 BE[2506]            <1> 	mov	si,msg_set_prompt
   334 00001196 E87D16              <1> 	call	print
   335                              <1> 
   336                              <1> .menu_input:
   337 00001199 B400                <1> 	mov	ah,00h
   338 0000119B CD16                <1> 	int	16h
   339 0000119D 0C20                <1> 	or	al,20h			; convert to lower case
   340 0000119F B200                <1> 	mov	dl,0			; floppy 0
   341 000011A1 3C66                <1> 	cmp	al,'f'
   342 000011A3 7471                <1> 	je	.set_floppy
   343 000011A5 FEC2                <1> 	inc	dl			; floppy 1
   344 000011A7 3C67                <1> 	cmp	al,'g'
   345 000011A9 746B                <1> 	je	.set_floppy
   346 000011AB 3C70                <1> 	cmp	al,'p'
   347 000011AD 7503E93F01          <1> 	je	.print_settings
   348                              <1> %ifdef TURBO_MODE
   349 000011B2 3C63                <1> 	cmp	al,'c'
   350 000011B4 7503E9C300          <1> 	je	.set_cpu_clk
   351                              <1> %endif ; TURBO_MODE
   352                              <1> %ifdef MACHINE_FE2010A
   353 000011B9 3C73                <1> 	cmp	al,'s'
   354 000011BB 7503E97B03          <1> 	je	.set_ws
   355                              <1> %endif ; MACHINE_FE2010A
   356                              <1> %ifdef AT_RTC
   357                              <1> 	%ifdef AT_RTC_AUTODETECT
   358 000011C0 E8DBFD              <1> 		call	rtc_detect
   359 000011C3 720E                <1> 		jc	.rtc_absent_2
   360                              <1> 	%endif ; AT_RTC_AUTODETECT
   361 000011C5 3C74                <1> 	cmp	al,'t'
   362 000011C7 7503E99C01          <1> 	je	.set_time
   363 000011CC 3C64                <1> 	cmp	al,'d'
   364 000011CE 7503E91002          <1> 	je	.set_date
   365                              <1> 	
   366                              <1> .rtc_absent_2:
   367                              <1> %endif ; AT_RTC
   368 000011D3 3C65                <1> 	cmp	al,'e'
   369 000011D5 7503E9D102          <1> 	je	.set_ext_scan
   370 000011DA 3C6D                <1> 	cmp	al,'m'
   371 000011DC 7503E91203          <1> 	je	.set_mem_test
   372 000011E1 3C77                <1> 	cmp	al,'w'
   373 000011E3 7503E9AE03          <1> 	je	.save
   374 000011E8 3C71                <1> 	cmp	al,'q'
   375 000011EA 7503E9B603          <1> 	je	.no_save
   376 000011EF 3C68                <1> 	cmp	al,'h'
   377 000011F1 7402                <1> 	je	.help
   378 000011F3 EBA4                <1> 	jmp	.menu_input
   379                              <1> 
   380                              <1> .help:
   381 000011F5 B40E                <1> 	mov	ah,0Eh			; echo
   382 000011F7 BB0700              <1> 	mov	bx,0007h
   383 000011FA CD10                <1> 	int	10h
   384 000011FC BE[A604]            <1> 	mov	si,msg_set_help
   385 000011FF E81416              <1> 	call	print
   386                              <1> 
   387                              <1> %ifdef AT_RTC
   388                              <1> 	
   389                              <1> %ifdef AT_RTC_AUTODETECT
   390 00001202 E899FD              <1> 	call	rtc_detect
   391 00001205 7206                <1> 	jc	.rtc_absent
   392                              <1> %endif ; AT_RTC_AUTODETECT
   393                              <1> 
   394 00001207 BE[9B05]            <1> 	mov	si,msg_set_rtc_help
   395 0000120A E80916              <1> 	call	print
   396                              <1> 
   397                              <1> .rtc_absent:
   398                              <1> %endif ; AT_RTC
   399                              <1> 
   400 0000120D BE[B805]            <1> 	mov	si,msg_set_def_help
   401 00001210 E80316              <1> 	call	print
   402 00001213 E97DFF              <1> 	jmp	.menu_loop
   403                              <1> 
   404                              <1> .set_floppy:
   405 00001216 B40E                <1> 	mov	ah,0Eh			; echo
   406 00001218 BB0700              <1> 	mov	bx,0007h
   407 0000121B CD10                <1> 	int	10h
   408                              <1> 
   409                              <1> .set_floppy_prompt:
   410 0000121D BE[E907]            <1> 	mov	si,msg_set_fd_prmt
   411 00001220 E8F315              <1> 	call	print
   412                              <1> 
   413                              <1> .floppy_input:
   414 00001223 B400                <1> 	mov	ah,00h
   415 00001225 CD16                <1> 	int	16h
   416 00001227 0C20                <1> 	or	al,20h			; convert to lower case
   417 00001229 3C72                <1> 	cmp	al,'r'
   418 0000122B 7430                <1> 	je	.floppy_exit
   419 0000122D 3C68                <1> 	cmp	al,'h'
   420 0000122F 7436                <1> 	je	.floppy_help
   421 00001231 3C30                <1> 	cmp	al,'0'
   422 00001233 72EE                <1> 	jb	.floppy_input
   423 00001235 3C36                <1> 	cmp	al,'6'
   424 00001237 77EA                <1> 	ja	.floppy_input
   425 00001239 3C35                <1> 	cmp	al,'5'
   426 0000123B 74E6                <1> 	je	.floppy_input
   427 0000123D B40E                <1> 	mov	ah,0Eh			; echo
   428 0000123F BB0700              <1> 	mov	bx,0007h
   429 00001242 CD10                <1> 	int	10h
   430 00001244 2C30                <1> 	sub	al,'0'
   431 00001246 B6F0                <1> 	mov	dh,0F0h
   432 00001248 08D2                <1> 	or	dl,dl			; drive	0?
   433 0000124A 750A                <1> 	jnz	.drive_1
   434 0000124C D0E0                <1> 	shl	al,1
   435 0000124E D0E0                <1> 	shl	al,1
   436 00001250 D0E0                <1> 	shl	al,1
   437 00001252 D0E0                <1> 	shl	al,1
   438 00001254 B60F                <1> 	mov	dh,0Fh
   439                              <1> .drive_1:
   440 00001256 20F1                <1> 	and	cl,dh
   441 00001258 08C1                <1> 	or	cl,al
   442 0000125A E936FF              <1> 	jmp	.menu_loop
   443                              <1> 
   444                              <1> .floppy_exit:
   445 0000125D B40E                <1> 	mov	ah,0Eh			; echo
   446 0000125F BB0700              <1> 	mov	bx,0007h
   447 00001262 CD10                <1> 	int	10h
   448 00001264 E92CFF              <1> 	jmp	.menu_loop
   449                              <1> 
   450                              <1> .floppy_help:
   451 00001267 B40E                <1> 	mov	ah,0Eh			; echo
   452 00001269 BB0700              <1> 	mov	bx,0007h
   453 0000126C CD10                <1> 	int	10h
   454 0000126E BE[1A07]            <1> 	mov	si,msg_set_fd_help
   455 00001271 E8A215              <1> 	call	print
   456 00001274 BE[A607]            <1> 	mov	si,msg_set_sub_help
   457 00001277 E89C15              <1> 	call	print
   458 0000127A EBA1                <1> 	jmp	.set_floppy_prompt
   459                              <1> 
   460                              <1> %ifdef TURBO_MODE
   461                              <1> .set_cpu_clk:
   462 0000127C B40E                <1> 	mov	ah,0Eh			; echo
   463 0000127E BB0700              <1> 	mov	bx,0007h
   464 00001281 CD10                <1> 	int	10h
   465                              <1> 
   466                              <1> .set_cpu_clk_prompt:
   467 00001283 BE[8F06]            <1> 	mov	si,msg_set_clk_prmt
   468 00001286 E88D15              <1> 	call	print
   469                              <1> 
   470                              <1> .cpu_clk_input:
   471 00001289 B400                <1> 	mov	ah,00h
   472 0000128B CD16                <1> 	int	16h
   473 0000128D 0C20                <1> 	or	al,20h			; convert to lower case
   474 0000128F 3C72                <1> 	cmp	al,'r'
   475 00001291 743F                <1> 	je	.cpu_clk_exit
   476 00001293 3C68                <1> 	cmp	al,'h'
   477 00001295 7445                <1> 	je	.cpu_clk_help
   478 00001297 3C34                <1> 	cmp	al,'4'
   479 00001299 740A                <1> 	je	.cpu_clk_4_77mhz
   480                              <1> %ifdef MACHINE_FE2010A
   481 0000129B 3C37                <1> 	cmp	al,'7'
   482 0000129D 7413                <1> 	je	.cpu_clk_7_16mhz
   483 0000129F 3C39                <1> 	cmp	al,'9'
   484 000012A1 741F                <1> 	je	.cpu_clk_9_55mhz
   485                              <1> %else ; MACHINE_FE2010A
   486                              <1> 	cmp	al,'t'
   487                              <1> 	je	.cpu_clk_turbo
   488                              <1> %endif ; MACHINE_FE2010A
   489 000012A3 EBE4                <1> 	jmp	.cpu_clk_input
   490                              <1> 
   491                              <1> .cpu_clk_4_77mhz:
   492 000012A5 B40E                <1> 	mov	ah,0Eh			; echo
   493 000012A7 BB0700              <1> 	mov	bx,0007h
   494 000012AA CD10                <1> 	int	10h
   495 000012AC 80E5FC              <1> 	and	ch,~nvram_trbo_mask	; CH[1:0] = 0 -> 4.77 MHz
   496 000012AF E9E1FE              <1> 	jmp	.menu_loop
   497                              <1> 
   498                              <1> %ifdef MACHINE_FE2010A
   499                              <1> .cpu_clk_7_16mhz:
   500 000012B2 B40E                <1> 	mov	ah,0Eh			; echo
   501 000012B4 BB0700              <1> 	mov	bx,0007h
   502 000012B7 CD10                <1> 	int	10h
   503 000012B9 80E5FC              <1> 	and	ch,~nvram_trbo_mask	; clear turbo bits
   504 000012BC 80CD01              <1> 	or	ch,1			; CH[1:0] = 1 -> 7.16 MHz
   505 000012BF E9D1FE              <1> 	jmp	.menu_loop
   506                              <1> 
   507                              <1> .cpu_clk_9_55mhz:
   508 000012C2 B40E                <1> 	mov	ah,0Eh			; echo
   509 000012C4 BB0700              <1> 	mov	bx,0007h
   510 000012C7 CD10                <1> 	int	10h
   511 000012C9 80E5FC              <1> 	and	ch,~nvram_trbo_mask	; clear turbo bits
   512 000012CC 80CD02              <1> 	or	ch,2			; CH[1:0] = 2 -> 9.55 MHz
   513 000012CF E9C1FE              <1> 	jmp	.menu_loop
   514                              <1> %else ; MACHINE_FE2010A
   515                              <1> .cpu_clk_turbo:
   516                              <1> 	mov	ah,0Eh			; echo
   517                              <1> 	mov	bx,0007h
   518                              <1> 	int	10h
   519                              <1> 	and	ch,~nvram_trbo_mask	; clear turbo bits
   520                              <1> 	or	ch,1			; CH[1:0] = 1 -> Turbo
   521                              <1> 	jmp	.menu_loop
   522                              <1> %endif ; MACHINE_FE2010A
   523                              <1> 
   524                              <1> .cpu_clk_exit:
   525 000012D2 B40E                <1> 	mov	ah,0Eh			; echo
   526 000012D4 BB0700              <1> 	mov	bx,0007h
   527 000012D7 CD10                <1> 	int	10h
   528 000012D9 E9B7FE              <1> 	jmp	.menu_loop
   529                              <1> 
   530                              <1> .cpu_clk_help:
   531 000012DC B40E                <1> 	mov	ah,0Eh			; echo
   532 000012DE BB0700              <1> 	mov	bx,0007h
   533 000012E1 CD10                <1> 	int	10h
   534 000012E3 BE[4406]            <1> 	mov	si,msg_set_clk_help
   535 000012E6 E82D15              <1> 	call	print
   536 000012E9 BE[A607]            <1> 	mov	si,msg_set_sub_help
   537 000012EC E82715              <1> 	call	print
   538 000012EF EB92                <1> 	jmp	.set_cpu_clk_prompt
   539                              <1> %endif ; TURBO_MODE
   540                              <1> 
   541                              <1> .print_settings:
   542 000012F1 B40E                <1> 	mov	ah,0Eh			; echo
   543 000012F3 BB0700              <1> 	mov	bx,0007h
   544 000012F6 CD10                <1> 	int	10h
   545 000012F8 BE[8B00]            <1> 	mov	si,msg_crlf
   546 000012FB E81815              <1> 	call	print
   547                              <1> 
   548                              <1> %ifdef TURBO_MODE
   549 000012FE BE[9900]            <1> 	mov	si,msg_cpu_clk
   550 00001301 E81215              <1> 	call	print
   551 00001304 88E8                <1> 	mov	al,ch
   552 00001306 E87514              <1> 	call	print_cpu_clk
   553 00001309 BE[8B00]            <1> 	mov	si,msg_crlf
   554 0000130C E80715              <1> 	call	print
   555                              <1> %endif ; TURBO_MODE
   556                              <1> 
   557                              <1> %ifdef MACHINE_FE2010A
   558 0000130F BE[C609]            <1> 	mov	si,msg_ws
   559 00001312 E80115              <1> 	call	print
   560 00001315 BE[E309]            <1> 	mov	si,msg_enabled		; assume fast wait states
   561 00001318 F6C510              <1> 	test	ch,nvram_fast_ws
   562 0000131B 7403                <1> 	jz	.print_ws
   563 0000131D BE[EB09]            <1> 	mov	si,msg_disabled
   564                              <1> 
   565                              <1> .print_ws:
   566 00001320 E8F314              <1> 	call	print
   567 00001323 BE[8B00]            <1> 	mov	si,msg_crlf
   568 00001326 E8ED14              <1> 	call	print
   569                              <1> %endif ; MACHINE_FE2010A
   570                              <1> 
   571                              <1> %ifdef AT_RTC
   572 00001329 E800FC              <1> 	call	print_rtc		; print current RTC time
   573                              <1> %endif ; AT_RTC
   574 0000132C 88C8                <1> 	mov	al,cl			; floppy bytes to AL
   575 0000132E E8790C              <1> 	call	print_floppy
   576 00001331 BE[4808]            <1> 	mov	si,msg_ext_scan
   577 00001334 E8DF14              <1> 	call	print
   578 00001337 BE[E309]            <1> 	mov	si,msg_enabled		; assume F0000-F7FFF ROM scan enabled
   579 0000133A F6C504              <1> 	test	ch,nvram_ext_scan
   580 0000133D 7403                <1> 	jz	.print_ext_scan
   581 0000133F BE[EB09]            <1> 	mov	si,msg_disabled		; F0000-F7FFF ROM scan disabled
   582                              <1> 
   583                              <1> .print_ext_scan:
   584 00001342 E8D114              <1> 	call	print
   585 00001345 BE[8B00]            <1> 	mov	si,msg_crlf
   586 00001348 E8CB14              <1> 	call	print
   587 0000134B BE[8008]            <1> 	mov	si,msg_mem_test
   588 0000134E E8C514              <1> 	call	print
   589 00001351 BE[E309]            <1> 	mov	si,msg_enabled		; assume memory test enabled
   590 00001354 F6C508              <1> 	test	ch,nvram_mem_test
   591 00001357 7403                <1> 	jz	.print_mem_test
   592 00001359 BE[EB09]            <1> 	mov	si,msg_disabled
   593                              <1> 
   594                              <1> .print_mem_test:
   595 0000135C E8B714              <1> 	call	print
   596 0000135F BE[8B00]            <1> 	mov	si,msg_crlf
   597 00001362 E8B114              <1> 	call	print
   598 00001365 E92BFE              <1> 	jmp	.menu_loop
   599                              <1> 
   600                              <1> %ifdef AT_RTC
   601                              <1> .set_time:
   602 00001368 51                  <1> 	push	cx
   603 00001369 57                  <1> 	push	di
   604 0000136A 06                  <1> 	push	es
   605 0000136B B40E                <1> 	mov	ah,0Eh			; echo
   606 0000136D BB0700              <1> 	mov	bx,0007h
   607 00001370 CD10                <1> 	int	10h
   608 00001372 BE[8B00]            <1> 	mov	si,msg_crlf
   609 00001375 E89E14              <1> 	call	print
   610                              <1> 
   611 00001378 BE[BA06]            <1> 	mov	si,msg_set_time
   612 0000137B E89814              <1> 	call	print
   613                              <1> 
   614 0000137E B402                <1> 	mov	ah,02h
   615 00001380 CD1A                <1> 	int	1Ah			; get current time
   616                              <1> 
   617 00001382 B8C007              <1> 	mov 	ax,07C0h		; use 07C0:0000 as a buffer
   618 00001385 8EC0                <1> 	mov	es,ax
   619 00001387 31FF                <1> 	xor	di,di
   620 00001389 B80800              <1> 	mov	ax,8			; length of the time string
   621                              <1> 
   622 0000138C E82902              <1> 	call	get_line
   623                              <1> 
   624 0000138F 09C0                <1> 	or	ax,ax			; empty string?
   625 00001391 7442                <1> 	jz	.set_time_exit
   626                              <1> 
   627 00001393 E89402              <1> 	call	atoi
   628                              <1> 
   629 00001396 83F817              <1> 	cmp	ax,23			; hours are greater than 23?
   630 00001399 7740                <1> 	ja	.set_time_invalid
   631                              <1> 
   632 0000139B E8B102              <1> 	call	bin_to_bcd		; convert to BCD
   633                              <1> 
   634 0000139E 88C5                <1> 	mov	ch,al			; CH = hours
   635                              <1> 
   636 000013A0 26803D3A            <1>     es	cmp	byte [di],':'		; ':' delimiter?
   637 000013A4 7535                <1> 	jne	.set_time_invalid
   638                              <1> 
   639 000013A6 47                  <1> 	inc	di
   640                              <1> 
   641 000013A7 E88002              <1> 	call	atoi
   642                              <1> 
   643 000013AA 83F83B              <1> 	cmp	ax,59			; minutes are greater than 59?
   644 000013AD 772C                <1> 	ja	.set_time_invalid
   645                              <1> 
   646 000013AF E89D02              <1> 	call	bin_to_bcd
   647                              <1> 
   648 000013B2 88C1                <1> 	mov	cl,al			; CL = minutes
   649                              <1> 
   650 000013B4 26803D3A            <1>     es	cmp	byte [di],':'		; ':' delimiter?
   651 000013B8 7521                <1> 	jne	.set_time_invalid
   652                              <1> 
   653 000013BA 47                  <1> 	inc	di
   654                              <1> 
   655 000013BB E86C02              <1> 	call	atoi
   656                              <1> 
   657 000013BE 83F83B              <1> 	cmp	ax,59			; seconds are greater than 59?
   658 000013C1 7718                <1> 	ja	.set_time_invalid
   659                              <1> 
   660 000013C3 E88902              <1> 	call	bin_to_bcd
   661                              <1> 
   662 000013C6 88C6                <1> 	mov	dh,al			; DH = seconds
   663                              <1> 
   664 000013C8 26803D00            <1>     es	cmp	byte [di],00h		; end of line?
   665 000013CC 750D                <1> 	jne	.set_time_invalid
   666                              <1> 
   667 000013CE B403                <1> 	mov	ah,03h			; set RTC time
   668 000013D0 CD1A                <1> 	int	1Ah
   669 000013D2 E886FA              <1> 	call	set_system_timer		; set timer variables to RTC time
   670                              <1> 
   671                              <1> .set_time_exit:
   672 000013D5 07                  <1> 	pop	es
   673 000013D6 5F                  <1> 	pop	di
   674 000013D7 59                  <1> 	pop	cx
   675 000013D8 E9B8FD              <1> 	jmp	.menu_loop
   676                              <1> 
   677                              <1> .set_time_invalid:
   678 000013DB BE[EC06]            <1> 	mov	si,msg_time_inval
   679 000013DE E83514              <1> 	call	print
   680 000013E1 EBF2                <1> 	jmp	.set_time_exit
   681                              <1> 
   682                              <1> .set_date:
   683 000013E3 51                  <1> 	push	cx
   684 000013E4 57                  <1> 	push	di
   685 000013E5 06                  <1> 	push	es
   686 000013E6 B40E                <1> 	mov	ah,0Eh			; echo
   687 000013E8 BB0700              <1> 	mov	bx,0007h
   688 000013EB CD10                <1> 	int	10h
   689 000013ED BE[8B00]            <1> 	mov	si,msg_crlf
   690 000013F0 E82314              <1> 	call	print
   691 000013F3 BE[D206]            <1> 	mov	si,msg_set_date
   692 000013F6 E81D14              <1> 	call	print
   693                              <1> 
   694 000013F9 B8C007              <1> 	mov 	ax,07C0h		; use 07C0:0000 as a buffer
   695 000013FC 8EC0                <1> 	mov	es,ax
   696 000013FE 31FF                <1> 	xor	di,di
   697 00001400 B80A00              <1> 	mov	ax,10			; length of the date string
   698                              <1> 
   699 00001403 E8B201              <1> 	call	get_line
   700                              <1> 
   701 00001406 09C0                <1> 	or	ax,ax			; empty string?
   702 00001408 7503E99000          <1> 	jz	.set_date_exit
   703                              <1> 
   704 0000140D E81A02              <1> 	call	atoi
   705                              <1> 
   706 00001410 3D0F27              <1> 	cmp	ax,9999			; year is greater than 9999?
   707 00001413 7603E98B00          <1> 	ja	.set_date_invalid
   708                              <1> 
   709 00001418 89C3                <1> 	mov	bx,ax			; store binary year in BX
   710                              <1> 
   711 0000141A E83202              <1> 	call	bin_to_bcd		; convert to BCD
   712                              <1> 
   713 0000141D 89C1                <1> 	mov	cx,ax			; CH = century, CL = year
   714                              <1> 	
   715 0000141F 26803D2D            <1>     es	cmp	byte [di],'-'		; '-' delimiter?
   716 00001423 757E                <1> 	jne	.set_date_invalid
   717                              <1> 
   718 00001425 47                  <1> 	inc	di
   719                              <1> 
   720 00001426 E80102              <1> 	call	atoi
   721                              <1> 
   722 00001429 83F801              <1> 	cmp	ax,1			; month is lower than 1?
   723 0000142C 7275                <1> 	jb	.set_date_invalid
   724                              <1> 
   725 0000142E 83F80C              <1> 	cmp	ax,12			; month is greater than 12?
   726 00001431 7770                <1> 	ja	.set_date_invalid
   727                              <1> 
   728 00001433 E81902              <1> 	call	bin_to_bcd
   729                              <1> 
   730 00001436 88C6                <1> 	mov	dh,al			; DH = month
   731                              <1> 
   732 00001438 26803D2D            <1>     es	cmp	byte [di],'-'		; '-' delimiter?
   733 0000143C 7565                <1> 	jne	.set_date_invalid
   734                              <1> 
   735 0000143E 47                  <1> 	inc	di
   736                              <1> 
   737 0000143F E8E801              <1> 	call	atoi
   738                              <1> 
   739 00001442 83F801              <1> 	cmp	ax,1			; day is lower than 1?
   740 00001445 725C                <1> 	jb	.set_date_invalid
   741                              <1> 
   742 00001447 80FE02              <1> 	cmp	dh,02h			; February
   743 0000144A 7430                <1> 	je	.set_date_february
   744                              <1> 
   745 0000144C 80FE04              <1> 	cmp	dh,04h			; April
   746 0000144F 7416                <1> 	je	.set_date_30_days
   747                              <1> 
   748 00001451 80FE06              <1> 	cmp	dh,06h			; July
   749 00001454 7411                <1> 	je	.set_date_30_days
   750                              <1> 
   751 00001456 80FE09              <1> 	cmp	dh,09h			; September
   752 00001459 740C                <1> 	je	.set_date_30_days
   753                              <1> 
   754 0000145B 80FE11              <1> 	cmp	dh,11h			; November
   755 0000145E 7407                <1> 	je	.set_date_30_days
   756                              <1> 
   757                              <1> .set_date_31_days:
   758 00001460 83F81F              <1> 	cmp	ax,31			; day of month is greater than 31?
   759 00001463 773E                <1> 	ja	.set_date_invalid
   760 00001465 EB27                <1> 	jmp	.set_date_set_day
   761                              <1> 
   762                              <1> .set_date_30_days:
   763 00001467 83F81E              <1> 	cmp	ax,30			; day of month is greater than 30?
   764 0000146A 7737                <1> 	ja	.set_date_invalid
   765 0000146C EB20                <1> 	jmp	.set_date_set_day
   766                              <1> 
   767                              <1> .set_date_29_days:
   768 0000146E 83F81D              <1> 	cmp	ax,29			; day of month is greater than 28?
   769 00001471 7730                <1> 	ja	.set_date_invalid
   770 00001473 EB19                <1> 	jmp	.set_date_set_day
   771                              <1> 
   772                              <1> .set_date_28_days:
   773 00001475 83F81C              <1> 	cmp	ax,28			; day of month is greater than 28?
   774 00001478 7729                <1> 	ja	.set_date_invalid
   775 0000147A EB12                <1> 	jmp	.set_date_set_day
   776                              <1> 
   777                              <1> .set_date_february:
   778 0000147C F7C30300            <1> 	test	bx,0003h		; check if years divides by 4
   779 00001480 75F3                <1> 	jnz	.set_date_28_days	; not a leap year
   780                              <1> 
   781 00001482 80F900              <1> 	cmp	cl,00h			; year doesn't end with 00
   782 00001485 75E7                <1> 	jne	.set_date_29_days	; a leap year
   783                              <1> 
   784 00001487 F6C503              <1> 	test	ch,03h			; check if century divides by 4
   785 0000148A 74E2                <1> 	jz	.set_date_29_days	; year divides by 400
   786 0000148C EBE7                <1> 	jmp	.set_date_28_days	; year divides by 100 but not by 400
   787                              <1> 
   788                              <1> .set_date_set_day:
   789 0000148E E8BE01              <1> 	call	bin_to_bcd
   790                              <1> 
   791 00001491 88C2                <1> 	mov	dl,al			; DL = date (day of month)
   792                              <1> 
   793 00001493 26803D00            <1>     es	cmp	byte [di],00h		; end of line?
   794 00001497 750A                <1> 	jne	.set_date_invalid
   795                              <1> 
   796 00001499 B405                <1> 	mov	ah,05h			; set RTC date
   797 0000149B CD1A                <1> 	int	1Ah
   798                              <1> 
   799                              <1> .set_date_exit:
   800 0000149D 07                  <1> 	pop	es
   801 0000149E 5F                  <1> 	pop	di
   802 0000149F 59                  <1> 	pop	cx
   803 000014A0 E9F0FC              <1> 	jmp	.menu_loop
   804                              <1> 
   805                              <1> .set_date_invalid:
   806 000014A3 BE[0307]            <1> 	mov	si,msg_date_inval
   807 000014A6 E86D13              <1> 	call	print
   808 000014A9 EBF2                <1> 	jmp	.set_date_exit
   809                              <1> 
   810                              <1> %endif ; AT_RTC
   811                              <1> 
   812                              <1> .set_ext_scan:
   813 000014AB B40E                <1> 	mov	ah,0Eh			; echo
   814 000014AD BB0700              <1> 	mov	bx,0007h
   815 000014B0 CD10                <1> 	int	10h
   816 000014B2 BE[8B00]            <1> 	mov	si,msg_crlf
   817 000014B5 E85E13              <1> 	call	print
   818 000014B8 BE[1208]            <1> 	mov	si,msg_set_ext
   819 000014BB E85813              <1> 	call	print
   820                              <1> 
   821                              <1> .set_ext_input:
   822 000014BE B400                <1> 	mov	ah,00h
   823 000014C0 CD16                <1> 	int	16h
   824 000014C2 3C0D                <1> 	cmp	al,0Dh
   825 000014C4 7424                <1> 	je	.set_ext_exit
   826 000014C6 0C20                <1> 	or	al,20h			; convert to lower case
   827 000014C8 3C6E                <1> 	cmp	al,'n'
   828 000014CA 7406                <1> 	je	.set_ext_disable
   829 000014CC 3C79                <1> 	cmp	al,'y'
   830 000014CE 740E                <1> 	je	.set_ext_enable
   831 000014D0 EBEC                <1> 	jmp	.set_ext_input
   832                              <1> 
   833                              <1> .set_ext_disable:
   834 000014D2 B40E                <1> 	mov	ah,0Eh			; echo
   835 000014D4 BB0700              <1> 	mov	bx,0007h
   836 000014D7 CD10                <1> 	int	10h
   837 000014D9 80CD04              <1> 	or	ch,nvram_ext_scan	; bit set = disable scan
   838 000014DC EB0C                <1> 	jmp	.set_ext_exit
   839                              <1> 
   840                              <1> .set_ext_enable:
   841 000014DE B40E                <1> 	mov	ah,0Eh			; echo
   842 000014E0 BB0700              <1> 	mov	bx,0007h
   843 000014E3 CD10                <1> 	int	10h
   844 000014E5 80E5FB              <1> 	and	ch,~nvram_ext_scan	; bit clear = enable scan
   845 000014E8 EB00                <1> 	jmp	.set_ext_exit
   846                              <1> 
   847                              <1> .set_ext_exit:
   848 000014EA BE[8B00]            <1> 	mov	si,msg_crlf
   849 000014ED E82613              <1> 	call	print
   850 000014F0 E9A0FC              <1> 	jmp	.menu_loop
   851                              <1> 
   852                              <1> .set_mem_test:
   853 000014F3 B40E                <1> 	mov	ah,0Eh			; echo
   854 000014F5 BB0700              <1> 	mov	bx,0007h
   855 000014F8 CD10                <1> 	int	10h
   856 000014FA BE[8B00]            <1> 	mov	si,msg_crlf
   857 000014FD E81613              <1> 	call	print
   858 00001500 BE[6508]            <1> 	mov	si,msg_set_mem_tst
   859 00001503 E81013              <1> 	call	print
   860                              <1> 
   861                              <1> .set_mem_test_input:
   862 00001506 B400                <1> 	mov	ah,00h
   863 00001508 CD16                <1> 	int	16h
   864 0000150A 3C0D                <1> 	cmp	al,0Dh
   865 0000150C 7424                <1> 	je	.set_mem_test_exit
   866 0000150E 0C20                <1> 	or	al,20h			; convert to lower case
   867 00001510 3C6E                <1> 	cmp	al,'n'
   868 00001512 7406                <1> 	je	.set_mem_test_disable
   869 00001514 3C79                <1> 	cmp	al,'y'
   870 00001516 740E                <1> 	je	.set_mem_test_enable
   871 00001518 EBEC                <1> 	jmp	.set_mem_test_input
   872                              <1> 
   873                              <1> .set_mem_test_disable:
   874 0000151A B40E                <1> 	mov	ah,0Eh			; echo
   875 0000151C BB0700              <1> 	mov	bx,0007h
   876 0000151F CD10                <1> 	int	10h
   877 00001521 80CD08              <1> 	or	ch,nvram_mem_test	; bit set = disable test
   878 00001524 EB0C                <1> 	jmp	.set_mem_test_exit
   879                              <1> 
   880                              <1> .set_mem_test_enable:
   881 00001526 B40E                <1> 	mov	ah,0Eh			; echo
   882 00001528 BB0700              <1> 	mov	bx,0007h
   883 0000152B CD10                <1> 	int	10h
   884 0000152D 80E5F7              <1> 	and	ch,~nvram_mem_test	; bit clear = enable test
   885 00001530 EB00                <1> 	jmp	.set_mem_test_exit
   886                              <1> 
   887                              <1> .set_mem_test_exit:
   888 00001532 BE[8B00]            <1> 	mov	si,msg_crlf
   889 00001535 E8DE12              <1> 	call	print
   890 00001538 E958FC              <1> 	jmp	.menu_loop
   891                              <1> 
   892                              <1> %ifdef MACHINE_FE2010A
   893                              <1> .set_ws:
   894 0000153B B40E                <1> 	mov	ah,0Eh			; echo
   895 0000153D BB0700              <1> 	mov	bx,0007h
   896 00001540 CD10                <1> 	int	10h
   897 00001542 BE[8B00]            <1> 	mov	si,msg_crlf
   898 00001545 E8CE12              <1> 	call	print
   899                              <1> .set_ws_loop:
   900 00001548 BE[9D08]            <1> 	mov	si,msg_set_ws
   901 0000154B E8C812              <1> 	call	print
   902                              <1> 
   903                              <1> .set_ws_input:
   904 0000154E B400                <1> 	mov	ah,00h
   905 00001550 CD16                <1> 	int	16h
   906 00001552 3C0D                <1> 	cmp	al,0Dh
   907 00001554 7437                <1> 	je	.set_ws_exit
   908 00001556 0C20                <1> 	or	al,20h			; convert to lower case
   909 00001558 3C6E                <1> 	cmp	al,'n'
   910 0000155A 740A                <1> 	je	.set_ws_disable
   911 0000155C 3C79                <1> 	cmp	al,'y'
   912 0000155E 7412                <1> 	je	.set_ws_enable
   913 00001560 3C68                <1> 	cmp	al,'h'
   914 00001562 741A                <1> 	je	.set_ws_help
   915 00001564 EBE8                <1> 	jmp	.set_ws_input
   916                              <1> 
   917                              <1> .set_ws_disable:
   918 00001566 B40E                <1> 	mov	ah,0Eh			; echo
   919 00001568 BB0700              <1> 	mov	bx,0007h
   920 0000156B CD10                <1> 	int	10h
   921 0000156D 80CD10              <1> 	or	ch,nvram_fast_ws	; bit set = fast waitstates
   922 00001570 EB1B                <1> 	jmp	.set_ws_exit
   923                              <1> 
   924                              <1> .set_ws_enable:
   925 00001572 B40E                <1> 	mov	ah,0Eh			; echo
   926 00001574 BB0700              <1> 	mov	bx,0007h
   927 00001577 CD10                <1> 	int	10h
   928 00001579 80E5EF              <1> 	and	ch,~nvram_fast_ws	; bit clear = normal waitstates
   929 0000157C EB0F                <1> 	jmp	.set_ws_exit
   930                              <1> 
   931                              <1> .set_ws_help:
   932 0000157E B40E                <1> 	mov	ah,0Eh			; echo
   933 00001580 BB0700              <1> 	mov	bx,0007h
   934 00001583 CD10                <1> 	int	10h
   935 00001585 BE[C208]            <1> 	mov	si,msg_ws_help
   936 00001588 E88B12              <1> 	call	print
   937 0000158B EBBB                <1> 	jmp	.set_ws_loop
   938                              <1> 
   939                              <1> .set_ws_exit:
   940 0000158D BE[8B00]            <1> 	mov	si,msg_crlf
   941 00001590 E88312              <1> 	call	print
   942 00001593 E9FDFB              <1> 	jmp	.menu_loop
   943                              <1> %endif ; MACHINE_FE2010A
   944                              <1> 
   945                              <1> .save:
   946 00001596 B40E                <1> 	mov	ah,0Eh			; echo
   947 00001598 BB0700              <1> 	mov	bx,0007h
   948 0000159B CD10                <1> 	int	10h
   949                              <1> 
   950                              <1> %ifdef AT_RTC_NVRAM
   951                              <1> 	call	nvram_save
   952                              <1> %endif ; AT_RTC_NVRAM
   953                              <1> %ifdef FLASH_NVRAM
   954 0000159D E84BFA              <1> 	call	flash_save
   955                              <1> %endif ; FLASH_NVRAM
   956 000015A0 E8D009              <1> 	call	detect_floppy		; set floppies in equipment_list
   957 000015A3 EB07                <1> 	jmp	.exit
   958                              <1> 
   959                              <1> .no_save:
   960 000015A5 B40E                <1> 	mov	ah,0Eh			; echo
   961 000015A7 BB0700              <1> 	mov	bx,0007h
   962 000015AA CD10                <1> 	int	10h
   963                              <1> 
   964                              <1> .exit:
   965 000015AC BE[8B00]            <1> 	mov	si,msg_crlf
   966 000015AF E86412              <1> 	call	print
   967 000015B2 5E                  <1> 	pop	si
   968 000015B3 5A                  <1> 	pop	dx
   969 000015B4 59                  <1> 	pop	cx
   970 000015B5 5B                  <1> 	pop	bx
   971 000015B6 58                  <1> 	pop	ax
   972 000015B7 C3                  <1> 	ret
   973                              <1> 
   974                              <1> ;=========================================================================
   975                              <1> ; get_line - read an ASCIIZ string from the console
   976                              <1> ; Input:
   977                              <1> ;	ES:DI - pointer to the buffer
   978                              <1> ;	AX - max string length
   979                              <1> ; Output:
   980                              <1> ;	AX - string length
   981                              <1> ; Notes:
   982                              <1> ;	Buffer must have size of max string length + 1 to accomodate 00h
   983                              <1> ;-------------------------------------------------------------------------
   984                              <1> get_line:
   985 000015B8 53                  <1> 	push	bx
   986 000015B9 52                  <1> 	push	dx
   987 000015BA 56                  <1> 	push	si
   988 000015BB 57                  <1> 	push	di
   989                              <1> 
   990 000015BC FC                  <1> 	cld
   991 000015BD 89FE                <1> 	mov	si,di
   992 000015BF 01C6                <1> 	add	si,ax			; SI = last character position
   993 000015C1 31D2                <1> 	xor	dx,dx			; DX = 0 - string length
   994                              <1> 
   995                              <1> .read_char_loop:
   996 000015C3 B400                <1> 	mov	ah,00h			; read character from keyboard
   997 000015C5 CD16                <1> 	int	16h
   998                              <1> 
   999 000015C7 3C08                <1> 	cmp	al,08h			; <Backspace> key
  1000 000015C9 741B                <1> 	jz	.backspace
  1001                              <1> 
  1002 000015CB 3C0D                <1> 	cmp	al,0Dh			; <Enter> key
  1003 000015CD 7441                <1> 	jz	.enter
  1004                              <1> 
  1005 000015CF 3C20                <1> 	cmp	al,20h			; below printable ASCII code?
  1006 000015D1 7233                <1> 	jb	.error_input
  1007                              <1> 
  1008 000015D3 3C7E                <1> 	cmp	al,7Eh			; above printable ASCII code?
  1009 000015D5 772F                <1> 	ja	.error_input
  1010                              <1> 
  1011 000015D7 39F7                <1> 	cmp	di,si			; end of buffer reached?
  1012 000015D9 732B                <1> 	jae	.error_input
  1013                              <1> 
  1014 000015DB AA                  <1> 	stosb				; store character in the buffer
  1015 000015DC 42                  <1> 	inc	dx			; increment strng length
  1016                              <1> 
  1017 000015DD B40E                <1> 	mov	ah,0Eh			; teletype output (echo)
  1018 000015DF BB0700              <1> 	mov	bx,0007h
  1019 000015E2 CD10                <1> 	int	10h
  1020                              <1> 
  1021 000015E4 EBDD                <1> 	jmp	.read_char_loop
  1022                              <1> 
  1023                              <1> .backspace:
  1024 000015E6 09D2                <1> 	or	dx,dx			; empty string?
  1025 000015E8 741C                <1> 	jz	.error_input
  1026                              <1> 
  1027 000015EA 4F                  <1> 	dec	di			; move pointer back
  1028 000015EB 4A                  <1> 	dec	dx			; decrement string size
  1029                              <1> 
  1030 000015EC B8080E              <1> 	mov	ax,0E08h		; move the cursor back
  1031 000015EF BB0700              <1> 	mov	bx,0007h
  1032 000015F2 CD10                <1> 	int	10h
  1033                              <1> 
  1034 000015F4 B8200E              <1> 	mov	ax,0E20h		; erase the character under the cursor
  1035 000015F7 BB0700              <1> 	mov	bx,0007h
  1036 000015FA CD10                <1> 	int	10h
  1037                              <1> 
  1038 000015FC B8080E              <1> 	mov	ax,0E08h		; move the cursor back again
  1039 000015FF BB0700              <1> 	mov	bx,0007h
  1040 00001602 CD10                <1> 	int	10h
  1041                              <1> 
  1042 00001604 EBBD                <1> 	jmp	.read_char_loop
  1043                              <1> 
  1044                              <1> .error_input:
  1045 00001606 B8070E              <1> 	mov	ax,0E07h		; beep
  1046 00001609 BB0700              <1> 	mov	bx,0007h
  1047 0000160C CD10                <1> 	int	10h
  1048                              <1> 
  1049 0000160E EBB3                <1> 	jmp	.read_char_loop
  1050                              <1> 
  1051                              <1> .enter:
  1052 00001610 B000                <1> 	mov	al,00h			; store 00h at the end of the string
  1053 00001612 AA                  <1> 	stosb
  1054                              <1> 
  1055 00001613 B80D0E              <1> 	mov	ax,0E0Dh		; CR
  1056 00001616 BB0700              <1> 	mov	bx,0007h
  1057 00001619 CD10                <1> 	int	10h
  1058                              <1> 
  1059 0000161B B80A0E              <1> 	mov	ax,0E0Ah		; LF
  1060 0000161E BB0700              <1> 	mov	bx,0007h
  1061 00001621 CD10                <1> 	int	10h
  1062                              <1> 
  1063 00001623 89D0                <1> 	mov	ax,dx			; string length to AX
  1064                              <1> 
  1065 00001625 5F                  <1> 	pop	di
  1066 00001626 5E                  <1> 	pop	si
  1067 00001627 5A                  <1> 	pop	dx
  1068 00001628 5B                  <1> 	pop	bx
  1069 00001629 C3                  <1> 	ret
  1070                              <1> 
  1071                              <1> ;=========================================================================
  1072                              <1> ; atoi - convert ASCIIZ string to an 16-bit integer number
  1073                              <1> ; Input:
  1074                              <1> ;	ES:DI - pointer to string
  1075                              <1> ; Output:
  1076                              <1> ;	AX - number
  1077                              <1> ; 	ES:DI - pointer moved to the position following the number
  1078                              <1> ;-------------------------------------------------------------------------
  1079                              <1> atoi:
  1080 0000162A 53                  <1> 	push	bx
  1081 0000162B 51                  <1> 	push	cx
  1082 0000162C 52                  <1> 	push	dx
  1083                              <1> 
  1084 0000162D 31C0                <1> 	xor	ax,ax			; zero the result
  1085 0000162F BB0A00              <1> 	mov	bx,10			; multiplier
  1086                              <1> 
  1087                              <1> .atoi_loop:
  1088 00001632 268A0D              <1>     es	mov	cl,byte [di]
  1089                              <1> 
  1090 00001635 80F930              <1> 	cmp	cl,'0'			; ASCII code below '0'
  1091 00001638 7211                <1> 	jb	.exit
  1092                              <1> 
  1093 0000163A 80F939              <1> 	cmp	cl,'9'			; ASCII code above '9'
  1094 0000163D 770C                <1> 	ja	.exit
  1095                              <1> 
  1096 0000163F 47                  <1> 	inc	di			; move to the next character
  1097                              <1> 
  1098 00001640 80E930              <1> 	sub	cl,'0'			; convert to ASCII to binary
  1099                              <1> 
  1100 00001643 F7E3                <1> 	mul	bx			; DX:AX = AX * 10
  1101 00001645 B500                <1> 	mov	ch,0
  1102 00001647 01C8                <1> 	add	ax,cx			; AX = AX + CX
  1103                              <1> 	
  1104 00001649 EBE7                <1> 	jmp	.atoi_loop
  1105                              <1> 
  1106                              <1> .exit:
  1107 0000164B 5A                  <1> 	pop	dx
  1108 0000164C 59                  <1> 	pop	cx
  1109 0000164D 5B                  <1> 	pop	bx
  1110 0000164E C3                  <1> 	ret
  1111                              <1> 
  1112                              <1> ;=========================================================================
  1113                              <1> ; bin_to_bcd - convert binary number to a packed BCD
  1114                              <1> ; Input:
  1115                              <1> ;	AX - binary number
  1116                              <1> ; Output:
  1117                              <1> ;	AX - packed BCD number
  1118                              <1> ;-------------------------------------------------------------------------
  1119                              <1> bin_to_bcd:
  1120 0000164F 53                  <1> 	push	bx
  1121 00001650 51                  <1> 	push	cx
  1122 00001651 52                  <1> 	push	dx
  1123 00001652 56                  <1> 	push	si
  1124                              <1> 
  1125 00001653 B100                <1> 	mov	cl,0			; shift amount
  1126 00001655 31F6                <1> 	xor	si,si			; zero result
  1127 00001657 BB0A00              <1> 	mov	bx,10			; BX - divisor
  1128                              <1> 
  1129                              <1> .bin_to_bcd_loop:
  1130 0000165A 31D2                <1> 	xor	dx,dx			; DX - zero for 32-bit div operand
  1131 0000165C F7F3                <1> 	div	bx
  1132                              <1> 
  1133 0000165E D3E2                <1> 	shl	dx,cl			; shift digit to the required position
  1134 00001660 80C104              <1> 	add	cl,4			; calculate next position
  1135                              <1> 
  1136 00001663 01D6                <1> 	add	si,dx			; add reminder to the result
  1137 00001665 09C0                <1> 	or	ax,ax			; quotient is zero?
  1138 00001667 75F1                <1> 	jnz	.bin_to_bcd_loop
  1139                              <1> 
  1140 00001669 89F0                <1> 	mov	ax,si			; result to AX
  1141                              <1> 
  1142 0000166B 5E                  <1> 	pop	si
  1143 0000166C 5A                  <1> 	pop	dx
  1144 0000166D 59                  <1> 	pop	cx
  1145 0000166E 5B                  <1> 	pop	bx
  1146 0000166F C3                  <1> 	ret
   267                                  %endif ; BIOS_SETUP
   268                                  %include	"delay.inc"		; delay function
   269                              <1> ;=========================================================================
   270                              <1> ; delay.inc - Delay functions
   271                              <1> ;-------------------------------------------------------------------------
   272                              <1> ;
   273                              <1> ; Compiles with NASM 2.13.02, might work with other versions
   274                              <1> ;
   275                              <1> ; Copyright (C) 2010 - 2023 Sergey Kiselev.
   276                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
   277                              <1> ;
   278                              <1> ; This program is free software: you can redistribute it and/or modify
   279                              <1> ; it under the terms of the GNU General Public License as published by
   280                              <1> ; the Free Software Foundation, either version 3 of the License, or
   281                              <1> ; (at your option) any later version.
   282                              <1> ;
   283                              <1> ; This program is distributed in the hope that it will be useful,
   284                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   285                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   286                              <1> ; GNU General Public License for more details.
   287                              <1> ;
   288                              <1> ; You should have received a copy of the GNU General Public License
   289                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   290                              <1> ;
   291                              <1> ;=========================================================================
   292                              <1> 
   293                              <1> %ifdef AT_DELAY
   294                              <1> 
   295                              <1> ;=========================================================================
   296                              <1> ; delay_15us - delay for multiplies of 15 microseconds
   297                              <1> ; Input:
   298                              <1> ;	CX = time to delay (in 15 microsecond units)
   299                              <1> ; Notes:
   300                              <1> ;	1.  Actual delay will be between (CX - 1) * 15us and CX * 15us
   301                              <1> ;	2.  This relies on the "refresh" bit of port 61h and therefore on
   302                              <1> ;	    timer channel 1. Will not function properly if timer gets
   303                              <1> ;	    reprogrammed by an application or if it was not initialized yet
   304                              <1> ;-------------------------------------------------------------------------
   305                              <1> delay_15us:
   306                              <1> 	push	ax
   307                              <1> 	push	cx
   308                              <1> .zero:
   309                              <1> 	in	al,ppi_pb_reg
   310                              <1> 	test	al,refresh_flag
   311                              <1> 	jz	.zero
   312                              <1> 	dec	cx
   313                              <1> 	jz	.exit
   314                              <1> .one:
   315                              <1> 	in	al,ppi_pb_reg
   316                              <1> 	test	al,refresh_flag
   317                              <1> 	jnz	.one
   318                              <1> 	dec	cx
   319                              <1> 	jnz	.zero
   320                              <1> .exit:
   321                              <1> 	pop	cx
   322                              <1> 	pop	ax
   323                              <1> 	ret
   324                              <1> 
   325                              <1> %else ; AT_DELAY
   326                              <1> 
   327                              <1> ;=========================================================================
   328                              <1> ; delay_15us - delay for multiplies of approximately 15 microseconds
   329                              <1> ; Input:
   330                              <1> ;	CX = time to delay (in 15 microsecond units)
   331                              <1> ; Notes:
   332                              <1> ;	This implementation does not provide precise timing
   333                              <1> ;	The actual delay depends on the CPU clock frequency
   334                              <1> ;-------------------------------------------------------------------------
   335                              <1> delay_15us:
   336 00001670 50                  <1> 	push	ax
   337 00001671 51                  <1> 	push	cx
   338                              <1> .1:
   339 00001672 B004                <1> 	mov	al,4
   340                              <1> .2:
   341 00001674 FEC8                <1> 	dec	al
   342 00001676 75FC                <1> 	jnz	.2
   343 00001678 E2F8                <1> 	loop	.1
   344 0000167A 59                  <1> 	pop	cx
   345 0000167B 58                  <1> 	pop	ax
   346 0000167C C3                  <1> 	ret
   347                              <1> 
   348                              <1> %endif ; AT_DELAY
   349                              <1> 
   350                              <1> 
   351                              <1> %if 0
   352                              <1> ;=========================================================================
   353                              <1> ; divide_32 - divide 64-bit argument by 32-bit, return 64-bit result
   354                              <1> ; Input:
   355                              <1> ;	DX:AX	- dividend
   356                              <1> ;	CX	- divisor
   357                              <1> ; Output:
   358                              <1> ;	DX:AX	- quotient
   359                              <1> ;-------------------------------------------------------------------------
   360                              <1> divide_32:
   361                              <1> 	or	dx,dx
   362                              <1> 	jnz	.1
   363                              <1> 	div	cx
   364                              <1> 	xor	dx,dx
   365                              <1> 	ret
   366                              <1> .1:
   367                              <1> 	push	bx
   368                              <1> 	mov	bx,ax
   369                              <1> 	mov	ax,dx
   370                              <1> 	xor	dx,dx
   371                              <1> 	div	cx
   372                              <1> 	xchg	bx,ax
   373                              <1> 	div	cx
   374                              <1> 	mov	dx,bx
   375                              <1> 	pop	bx
   376                              <1> 	ret
   377                              <1> %endif ; 0
   269                                  %include	"time1.inc"		; time services
   270                              <1> ;=========================================================================
   271                              <1> ; time1.inc - BIOS Time Services
   272                              <1> ;       INT 1Ah - BIOS Time Services
   273                              <1> ;		functions AH=00h to AH=07h
   274                              <1> ;	INT 70h - IRQ8 interrupt handler (RTC alarm)
   275                              <1> ;-------------------------------------------------------------------------
   276                              <1> ;
   277                              <1> ; Compiles with NASM 2.13.02, might work with other versions
   278                              <1> ;
   279                              <1> ; Copyright (C) 2010 - 2023 Sergey Kiselev.
   280                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
   281                              <1> ;
   282                              <1> ; This program is free software: you can redistribute it and/or modify
   283                              <1> ; it under the terms of the GNU General Public License as published by
   284                              <1> ; the Free Software Foundation, either version 3 of the License, or
   285                              <1> ; (at your option) any later version.
   286                              <1> ;
   287                              <1> ; This program is distributed in the hope that it will be useful,
   288                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   289                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   290                              <1> ; GNU General Public License for more details.
   291                              <1> ;
   292                              <1> ; You should have received a copy of the GNU General Public License
   293                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   294                              <1> ;
   295                              <1> ;=========================================================================
   296                              <1> 
   297                              <1> ;=========================================================================
   298                              <1> ; int_1A_fn00 - Read current time
   299                              <1> ; Input:
   300                              <1> ;	AH = 0 - read current time
   301                              <1> ; Output:
   302                              <1> ;	CX = high word of tick count
   303                              <1> ;	DX = low word of tick count
   304                              <1> ;	AL = midnight flag: non-zero if midnight passed since time last read
   305                              <1> ;-------------------------------------------------------------------------
   306                              <1> int_1A_fn00:
   307 0000167D 8B166C00            <1> 	mov	dx,word [ticks_lo]
   308 00001681 8B0E6E00            <1> 	mov	cx,word [ticks_hi]
   309 00001685 A07000              <1> 	mov	al,byte [new_day]	; read new_day to al
   310 00001688 30067000            <1> 	xor	byte [new_day],al	; new_day = 0
   311 0000168C E90648              <1> 	jmp	int_1A_exit
   312                              <1> 
   313                              <1> ;=========================================================================
   314                              <1> ; int_1A_fn01 - Set current time and clear midnight flag
   315                              <1> ; Input:
   316                              <1> ;	AH = 01h - function 01h - set current time and clear midnight flag
   317                              <1> ;	CX = high word of tick count
   318                              <1> ;	DX = low word of tick count
   319                              <1> ; Output:
   320                              <1> ;	None
   321                              <1> ;-------------------------------------------------------------------------
   322                              <1> int_1A_fn01:
   323 0000168F 89166C00            <1> 	mov	word [ticks_lo],dx
   324 00001693 890E6E00            <1> 	mov	word [ticks_hi],cx
   325 00001697 C606700000          <1> 	mov	byte [new_day],00h
   326 0000169C E9F647              <1> 	jmp	int_1A_exit
   327                              <1> 
   328                              <1> %ifdef AT_RTC
   329                              <1> 
   330                              <1> ;=========================================================================
   331                              <1> ; int_1A_fn02 - Read real time clock (RTC)
   332                              <1> ; Input:
   333                              <1> ;	AH = 02h - function 02h - read RTC time
   334                              <1> ; Output:
   335                              <1> ;	CF set if RTC update is in progress and operation was not performed
   336                              <1> ;	CH = BCD hours
   337                              <1> ;	CL = BCD minutes
   338                              <1> ;	DH = BCD seconds
   339                              <1> ;	DL - daylight savings flag: 00h = standard time, 01h = daylight time
   340                              <1> ;-------------------------------------------------------------------------
   341                              <1> int_1A_fn02:
   342                              <1> %ifdef AT_RTC_AUTODETECT
   343 0000169F E8FCF8              <1> 	call	rtc_detect		; check that RTC is present
   344 000016A2 7303E9F147          <1> 	jc	int_1A_exitf		; error - no RTC
   345                              <1> %endif ; AT_RTC_AUTODETECT
   346 000016A7 50                  <1> 	push	ax
   347 000016A8 B00A                <1> 	mov	al,cmos_control_a
   348 000016AA E88CF7              <1> 	call	rtc_read		; read control A register
   349 000016AD A880                <1> 	test	al,cmos_uip
   350 000016AF 7405                <1> 	jz	.1			; no update in progess
   351 000016B1 F9                  <1> 	stc
   352 000016B2 58                  <1> 	pop	ax
   353 000016B3 E9E247              <1> 	jmp	int_1A_exitf
   354                              <1> .1:
   355 000016B6 B00B                <1> 	mov	al,cmos_control_b
   356 000016B8 E87EF7              <1> 	call	rtc_read		; read control B register
   357 000016BB 2401                <1> 	and	al,cmos_dse		; mask the daylight savings bit
   358 000016BD 88C2                <1> 	mov	dl,al
   359 000016BF B000                <1> 	mov	al,cmos_seconds
   360 000016C1 E875F7              <1> 	call	rtc_read		; read seconds
   361 000016C4 88C6                <1> 	mov	dh,al
   362 000016C6 B002                <1> 	mov	al,cmos_minutes
   363 000016C8 E86EF7              <1> 	call	rtc_read		; read minutes
   364 000016CB 88C1                <1> 	mov	cl,al
   365 000016CD B004                <1> 	mov	al,cmos_hours
   366 000016CF E867F7              <1> 	call	rtc_read		; read hours
   367 000016D2 88C5                <1> 	mov	ch,al
   368 000016D4 F8                  <1> 	clc
   369 000016D5 58                  <1> 	pop	ax
   370 000016D6 E9BF47              <1> 	jmp	int_1A_exitf
   371                              <1> 
   372                              <1> ;=========================================================================
   373                              <1> ; int_1A_fn03 - Set real time clock
   374                              <1> ; Input:
   375                              <1> ;	AH = 03h - function 03h - set RTC time
   376                              <1> ;	CH = BCD hours
   377                              <1> ;	CL = BCD minutes
   378                              <1> ;	DH = BCD seconds
   379                              <1> ;	DL - daylight savings flag: 00h = standard time, 01h = daylight time
   380                              <1> ; Output:
   381                              <1> ;	None
   382                              <1> ;-------------------------------------------------------------------------
   383                              <1> int_1A_fn03:
   384                              <1> %ifdef AT_RTC_AUTODETECT
   385 000016D9 E8C2F8              <1> 	call	rtc_detect		; check that RTC is present
   386 000016DC 7303E9B747          <1> 	jc	int_1A_exitf		; error - no RTC
   387                              <1> %endif ; AT_RTC_AUTODETECT
   388 000016E1 50                  <1> 	push	ax
   389 000016E2 B00B                <1> 	mov	al,cmos_control_b
   390 000016E4 E852F7              <1> 	call	rtc_read		; read control B register
   391 000016E7 88C4                <1> 	mov	ah,al
   392 000016E9 80CC80              <1> 	or	ah,cmos_set		; set the RTC set bit
   393 000016EC B00B                <1> 	mov	al,cmos_control_b
   394 000016EE E857F7              <1> 	call	rtc_write		; write control B register
   395                              <1> 
   396 000016F1 80E201              <1> 	and	dl,cmos_dse		; mask the daylight saving flag
   397 000016F4 80E4FE              <1> 	and	ah,~cmos_dse		; clear daylight saving flag for now
   398 000016F7 08D4                <1> 	or	ah,dl			; add it from the input
   399 000016F9 B00B                <1> 	mov	al,cmos_control_b
   400 000016FB E84AF7              <1> 	call	rtc_write		; write control B register
   401                              <1> 
   402 000016FE B000                <1> 	mov	al,cmos_seconds
   403 00001700 88F4                <1> 	mov	ah,dh
   404 00001702 E843F7              <1> 	call	rtc_write		; write seconds
   405 00001705 B002                <1> 	mov	al,cmos_minutes
   406 00001707 88CC                <1> 	mov	ah,cl
   407 00001709 E83CF7              <1> 	call	rtc_write		; write minutes
   408 0000170C B004                <1> 	mov	al,cmos_hours
   409 0000170E 88EC                <1> 	mov	ah,ch
   410 00001710 E835F7              <1> 	call	rtc_write		; write hours
   411                              <1> 
   412 00001713 B00B                <1> 	mov	al,cmos_control_b
   413 00001715 E821F7              <1> 	call	rtc_read		; read control B register
   414 00001718 88C4                <1> 	mov	ah,al
   415 0000171A 80E47F              <1> 	and	ah,~cmos_set		; clear the RTC set bit
   416 0000171D B00B                <1> 	mov	al,cmos_control_b
   417 0000171F E826F7              <1> 	call	rtc_write		; write control B register
   418 00001722 58                  <1> 	pop	ax
   419 00001723 E96F47              <1> 	jmp	int_1A_exit
   420                              <1> 
   421                              <1> ;=========================================================================
   422                              <1> ; int_1A_fn04 - Read date from real time clock
   423                              <1> ; Input:
   424                              <1> ;	AH = 04h - function 04h - read RTC date
   425                              <1> ; Output:
   426                              <1> ;	CF set if RTC update is in progress and operation was not performed
   427                              <1> ;	CH = BCD century
   428                              <1> ;	CL = BCD year
   429                              <1> ;	DH = BCD month
   430                              <1> ;	DL = BCD date
   431                              <1> ;-------------------------------------------------------------------------
   432                              <1> int_1A_fn04:
   433                              <1> %ifdef AT_RTC_AUTODETECT
   434 00001726 E875F8              <1> 	call	rtc_detect		; check that RTC is present
   435 00001729 7303E96A47          <1> 	jc	int_1A_exitf		; error - no RTC
   436                              <1> %endif ; AT_RTC_AUTODETECT
   437 0000172E 50                  <1> 	push	ax
   438 0000172F B00A                <1> 	mov	al,cmos_control_a
   439 00001731 E805F7              <1> 	call	rtc_read		; read control A register
   440 00001734 A880                <1> 	test	al,cmos_uip
   441 00001736 7405                <1> 	jz	.1			; no update in progess
   442 00001738 F9                  <1> 	stc
   443 00001739 58                  <1> 	pop	ax
   444 0000173A E95B47              <1> 	jmp	int_1A_exitf
   445                              <1> .1:
   446 0000173D B007                <1> 	mov	al,cmos_date
   447 0000173F E8F7F6              <1> 	call	rtc_read		; read date
   448 00001742 88C2                <1> 	mov	dl,al
   449 00001744 B008                <1> 	mov	al,cmos_month
   450 00001746 E8F0F6              <1> 	call	rtc_read		; read month
   451 00001749 88C6                <1> 	mov	dh,al
   452 0000174B B009                <1> 	mov	al,cmos_year
   453 0000174D E8E9F6              <1> 	call	rtc_read		; read year
   454 00001750 88C1                <1> 	mov	cl,al
   455 00001752 B032                <1> 	mov	al,cmos_century
   456 00001754 E8E2F6              <1> 	call	rtc_read		; read century
   457 00001757 88C5                <1> 	mov	ch,al
   458 00001759 F8                  <1> 	clc
   459 0000175A 58                  <1> 	pop	ax
   460 0000175B E93A47              <1> 	jmp	int_1A_exitf
   461                              <1> 
   462                              <1> ;=========================================================================
   463                              <1> ; int_1A_fn05 - Set date in real time clock
   464                              <1> ; Input:
   465                              <1> ;	AH = 05h - function 05h - set RTC date
   466                              <1> ;	CH = BCD century
   467                              <1> ;	CL = BCD year
   468                              <1> ;	DH = BCD month
   469                              <1> ;	DL = BCD date
   470                              <1> ; Output:
   471                              <1> ;	None
   472                              <1> ;-------------------------------------------------------------------------
   473                              <1> int_1A_fn05:
   474                              <1> %ifdef AT_RTC_AUTODETECT
   475 0000175E E83DF8              <1> 	call	rtc_detect		; check that RTC is present
   476 00001761 7303E93247          <1> 	jc	int_1A_exitf		; error - no RTC
   477                              <1> %endif ; AT_RTC_AUTODETECT
   478 00001766 50                  <1> 	push	ax
   479 00001767 B00B                <1> 	mov	al,cmos_control_b
   480 00001769 E8CDF6              <1> 	call	rtc_read		; read control B register
   481 0000176C 88C4                <1> 	mov	ah,al
   482 0000176E 80CC80              <1> 	or	ah,cmos_set		; set the RTC set bit
   483 00001771 B00B                <1> 	mov	al,cmos_control_b
   484 00001773 E8D2F6              <1> 	call	rtc_write		; write control B register
   485                              <1> 
   486 00001776 B007                <1> 	mov	al,cmos_date
   487 00001778 88D4                <1> 	mov	ah,dl
   488 0000177A E8CBF6              <1> 	call	rtc_write		; write date
   489                              <1> 
   490 0000177D B008                <1> 	mov	al,cmos_month
   491 0000177F 88F4                <1> 	mov	ah,dh
   492 00001781 E8C4F6              <1> 	call	rtc_write		; write month
   493 00001784 B009                <1> 	mov	al,cmos_year
   494 00001786 88CC                <1> 	mov	ah,cl
   495 00001788 E8BDF6              <1> 	call	rtc_write		; write year
   496 0000178B B032                <1> 	mov	al,cmos_century
   497 0000178D 88EC                <1> 	mov	ah,ch
   498 0000178F E8B6F6              <1> 	call	rtc_write		; write centry
   499                              <1> 
   500 00001792 B00B                <1> 	mov	al,cmos_control_b
   501 00001794 E8A2F6              <1> 	call	rtc_read		; read control B register
   502 00001797 88C4                <1> 	mov	ah,al
   503 00001799 80E47F              <1> 	and	ah,~cmos_set		; clear the RTC set bit
   504 0000179C B00B                <1> 	mov	al,cmos_control_b
   505 0000179E E8A7F6              <1> 	call	rtc_write		; write control B register
   506 000017A1 58                  <1> 	pop	ax
   507 000017A2 E9F046              <1> 	jmp	int_1A_exit
   508                              <1> 
   509                              <1> ;=========================================================================
   510                              <1> ; int_1A_fn06 - Set real time clock alarm
   511                              <1> ; Input:
   512                              <1> ;	AH = 06h - function 06h - set RTC alarm time
   513                              <1> ;	CH = BCD hours
   514                              <1> ;	CL = BCD minutes
   515                              <1> ;	DH = BCD seconds
   516                              <1> ; Output:
   517                              <1> ;	CF = 1 - alarm already set
   518                              <1> ;-------------------------------------------------------------------------
   519                              <1> int_1A_fn06:
   520                              <1> %ifdef AT_RTC_AUTODETECT
   521 000017A5 E8F6F7              <1> 	call	rtc_detect		; check that RTC is present
   522 000017A8 7303E9EB46          <1> 	jc	int_1A_exitf		; error - no RTC
   523                              <1> %endif ; AT_RTC_AUTODETECT
   524 000017AD 50                  <1> 	push	ax
   525 000017AE B00B                <1> 	mov	al,cmos_control_b
   526 000017B0 E886F6              <1> 	call	rtc_read		; read control B register
   527 000017B3 A820                <1> 	test	al,cmos_aie
   528 000017B5 7405                <1> 	jz	.1			; RTC alarm interrupt is not enabled
   529 000017B7 F9                  <1> 	stc
   530 000017B8 58                  <1> 	pop	ax
   531 000017B9 E9DC46              <1> 	jmp	int_1A_exitf
   532                              <1> .1:
   533 000017BC 88C4                <1> 	mov	ah,al
   534 000017BE 80CC80              <1> 	or	ah,cmos_set		; set the RTC set bit
   535 000017C1 B00B                <1> 	mov	al,cmos_control_b
   536 000017C3 E882F6              <1> 	call	rtc_write		; write control B register
   537                              <1> 
   538 000017C6 B001                <1> 	mov	al,cmos_alarm_secs
   539 000017C8 88F4                <1> 	mov	ah,dh
   540 000017CA E87BF6              <1> 	call	rtc_write		; write alarm seconds
   541 000017CD B003                <1> 	mov	al,cmos_alarm_mins
   542 000017CF 88CC                <1> 	mov	ah,cl
   543 000017D1 E874F6              <1> 	call	rtc_write		; write alarm minutes
   544 000017D4 B005                <1> 	mov	al,cmos_alarm_hrs
   545 000017D6 88EC                <1> 	mov	ah,ch
   546 000017D8 E86DF6              <1> 	call	rtc_write		; write alarm hours
   547                              <1> 
   548 000017DB B00B                <1> 	mov	al,cmos_control_b
   549 000017DD E859F6              <1> 	call	rtc_read		; read control B register
   550 000017E0 88C4                <1> 	mov	ah,al
   551 000017E2 80E47F              <1> 	and	ah,~cmos_set		; set the RTC set bit
   552 000017E5 B00B                <1> 	mov	al,cmos_control_b
   553 000017E7 E85EF6              <1> 	call	rtc_write		; write control B register
   554                              <1> 
   555 000017EA B00B                <1> 	mov	al,cmos_control_b
   556 000017EC E84AF6              <1> 	call	rtc_read		; read control B register
   557 000017EF 88C4                <1> 	mov	ah,al
   558 000017F1 80CC20              <1> 	or	ah,cmos_aie		; set alarm interrupt flag
   559 000017F4 B00B                <1> 	mov	al,cmos_control_b
   560 000017F6 E84FF6              <1> 	call	rtc_write		; write control B register with AIE set
   561                              <1> 
   562 000017F9 58                  <1> 	pop	ax
   563 000017FA F8                  <1> 	clc
   564 000017FB E99A46              <1> 	jmp	int_1A_exitf
   565                              <1> 
   566                              <1> ;=========================================================================
   567                              <1> ; int_1A_fn07 - Reset real time clock alarm
   568                              <1> ; Input:
   569                              <1> ;	AH = 07h - function 07h - set RTC time
   570                              <1> ; Output:
   571                              <1> ;	None
   572                              <1> ;-------------------------------------------------------------------------
   573                              <1> int_1A_fn07:
   574                              <1> %ifdef AT_RTC_AUTODETECT
   575 000017FE E89DF7              <1> 	call	rtc_detect		; check that RTC is present
   576 00001801 7303E99246          <1> 	jc	int_1A_exitf		; error - no RTC
   577                              <1> %endif ; AT_RTC_AUTODETECT
   578 00001806 50                  <1> 	push	ax
   579                              <1> 
   580 00001807 B00B                <1> 	mov	al,cmos_control_b
   581 00001809 E82DF6              <1> 	call	rtc_read		; read control B register
   582 0000180C 88C4                <1> 	mov	ah,al
   583 0000180E 80E4DF              <1> 	and	ah,~cmos_aie		; clear alarm interrupt flag
   584 00001811 B00B                <1> 	mov	al,cmos_control_b
   585 00001813 E832F6              <1> 	call	rtc_write		; write control B reg. with AIE cleared
   586                              <1> 
   587 00001816 58                  <1> 	pop	ax
   588 00001817 E97B46              <1> 	jmp	int_1A_exit
   589                              <1> 	
   590                              <1> %ifdef SECOND_PIC
   591                              <1> ;=========================================================================
   592                              <1> ; int_70 - RTC interrupt service routine (IRQ8)
   593                              <1> ; Notes:
   594                              <1> ;	Calls INT 4Ah if interrupt is caused by RTC alarm
   595                              <1> ;-------------------------------------------------------------------------
   596                              <1> int_70:
   597                              <1> 	push	ax
   598                              <1> 	mov	al,20h
   599                              <1> 	out	pic2_reg0,al		; signal EOI to the slave PIC
   600                              <1> 	out	pic1_reg0,al		; signal EOI to the master PIC
   601                              <1> 	mov	al,cmos_control_c
   602                              <1> 	call	rtc_read		; read control C register
   603                              <1> 	test	al,cmos_af		; check for alarm flag
   604                              <1> 	jz	.1
   605                              <1> 	int	4Ah			; call INT 4Ah
   606                              <1> .1:
   607                              <1> 	pop	ax
   608                              <1> 	iret
   609                              <1> %endif ; SECOND_PIC
   610                              <1> 
   611                              <1> %endif ; AT_RTC
   270                                  %include	"floppy1.inc"		; floppy services
   271                              <1> ;=========================================================================
   272                              <1> ; floppy1.inc - BIOS floppy disk services (part 1 of 2)
   273                              <1> ;	INT 13h, function AH=00h
   274                              <1> ;	INT 13h, function AH=01h
   275                              <1> ;	INT 13h, function AH=08h
   276                              <1> ;	INT 13h, function AH=15h
   277                              <1> ;	INT 13h, function AH=16h
   278                              <1> ;	INT 13h, function AH=17h
   279                              <1> ;	INT 13h, function AH=18h
   280                              <1> ;	INT 13h, function AH=08h
   281                              <1> ;	- see floppy2.inc for other INT 13h functions
   282                              <1> ;-------------------------------------------------------------------------
   283                              <1> ;
   284                              <1> ; Compiles with NASM 2.13.02, might work with other versions
   285                              <1> ;
   286                              <1> ; Copyright (C) 2010 - 2023 Sergey Kiselev.
   287                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
   288                              <1> ;
   289                              <1> ; This program is free software: you can redistribute it and/or modify
   290                              <1> ; it under the terms of the GNU General Public License as published by
   291                              <1> ; the Free Software Foundation, either version 3 of the License, or
   292                              <1> ; (at your option) any later version.
   293                              <1> ;
   294                              <1> ; This program is distributed in the hope that it will be useful,
   295                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   296                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   297                              <1> ; GNU General Public License for more details.
   298                              <1> ;
   299                              <1> ; You should have received a copy of the GNU General Public License
   300                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   301                              <1> ;
   302                              <1> ;=========================================================================
   303                              <1> 
   304                              <1> ;-------------------------------------------------------------------------
   305                              <1> ; FDC registers
   306                              <1> 
   307                              <1> fdc_dor_reg	equ	3F2h		; FDC digital output register (W)
   308                              <1> fdc_status_reg	equ	3F4h		; FDC main status register (R)
   309                              <1> fdc_data_reg	equ	3F5h		; FDC data register (R/W)
   310                              <1> fdc_dir_reg	equ	3F7h		; FDC digital input register (W)
   311                              <1> fdc_ccr_reg	equ	3F7h		; FDC control configuration register (R)
   312                              <1> 
   313                              <1> ; FDC status register bits
   314                              <1> fdc_stat_ready	equ	80h		; 1 = FDC is ready to send / receive
   315                              <1> fdc_stat_dir	equ	40h		; 0 = CPU -> FDC; 1 = FDC -> CPU
   316                              <1> fdc_stat_dma	equ	20h		; 1 = DMA and IRQ enabled
   317                              <1> fdc_stat_busy	equ	10h		; 1 = FDC is busy
   318                              <1> 
   319                              <1> ;-------------------------------------------------------------------------
   320                              <1> ; DMAC registers
   321                              <1> 
   322                              <1> dmac_ch0_addr_reg	equ	00h	; DMAC channel 0 base addres (W)
   323                              <1> dmac_ch0_count_reg	equ	01h	; DMAC channel 0 word count (W)
   324                              <1> dmac_ch1_addr_reg	equ	02h	; DMAC channel 1 base addres (W)
   325                              <1> dmac_ch1_count_reg	equ	03h	; DMAC channel 1 word count (W)
   326                              <1> dmac_ch2_addr_reg	equ	04h	; DMAC channel 2 base addres (W)
   327                              <1> dmac_ch2_count_reg	equ	05h	; DMAC channel 2 word count (W)
   328                              <1> dmac_mask_reg		equ	0Ah	; DMAC single mask bit register (W)
   329                              <1> dmac_mode_reg		equ	0Bh	; DMAC mode register (R/W)
   330                              <1> dmac_ff_reg		equ	0Ch	; DMAC set (R) or clear (W)
   331                              <1> 					; first / last flip-flop
   332                              <1> dmapage_ch2_reg		equ	81h	; DMA page channel 2 register
   333                              <1> 
   334                              <1> ;-------------------------------------------------------------------------
   335                              <1> ; Floppy disk services - error codes
   336                              <1> 
   337                              <1> fdc_e_success	equ	00h		; successful completion
   338                              <1> fdc_e_invalid	equ	01h		; invalid function or parameter
   339                              <1> fdc_e_address	equ	02h		; address mark not found
   340                              <1> fdc_e_wprotect	equ	03h		; disk write-protected
   341                              <1> fdc_e_notfound	equ	04h		; sector not found
   342                              <1> fdc_e_changed	equ	06h		; disk changed
   343                              <1> fdc_e_dma	equ	08h		; DMA overrun
   344                              <1> fdc_e_boundary	equ	09h		; attempted DMA across 64K boundary
   345                              <1> fdc_e_format	equ	0Ch		; not supported or drive type unknown
   346                              <1> fdc_e_crc	equ	10h		; uncorrectable CRC error on read
   347                              <1> fdc_e_failure	equ	20h		; controller failure
   348                              <1> fdc_e_seek	equ	40h		; seek failed
   349                              <1> fdc_e_timeout	equ	80h		; timeout / device not ready
   350                              <1> 
   351                              <1> ;-------------------------------------------------------------------------
   352                              <1> ; Drive media state for fdc_media_state
   353                              <1> 
   354                              <1> fdc_m_rate_bits		equ	0C0h	; bits 7-6: data transfer rate
   355                              <1> 					; 00b = 500 Kbit/sec
   356                              <1> 					; 01b = 300 Kbit/sec
   357                              <1> 					; 10b = 250 Kbit/sec
   358                              <1> 					; 11b = 1 Mbit/sec
   359                              <1> fdc_m_double_step	equ	20h	; bit 5:    1 = double stepping required
   360                              <1> fdc_m_established	equ	10h	; bit 4:    1 = media/drive established
   361                              <1> fdc_m_state_bits	equ	07h	; bits 2-0: media state bits
   362                              <1> 					; 000b = trying 360K in 360K drive
   363                              <1> 					; 001b = trying 360K in 1.2M drive
   364                              <1> 					; 010b = trying 1.2M in 1.2M drive
   365                              <1> 					; 011b = known 360K in 360K drive
   366                              <1> 					; 100b = known 360K in 1.2M drive
   367                              <1> 					; 101b = known 1.2M in 1.2M drive
   368                              <1> 					; 110b = not used
   369                              <1> 					; 111b = 720K in 720K or 1.44M in 1.44M
   370                              <1> fdc_m_360in360		equ	93h	; 250 Kbps, established, 360K in 360K
   371                              <1> fdc_m_720		equ	97h	; 250 Kbps, established, other drive
   372                              <1> fdc_m_try_360in1200	equ	61h	; 300 Kbps, not established, 360K in 1.2
   373                              <1> fdc_m_360in1200		equ	74h	; 300 Kbps, established, 360K in 1.2M
   374                              <1> fdc_m_try_1200in1200	equ	02h	; 500 Kbps, not established, 1.2M in 1.2
   375                              <1> fdc_m_1200in1200	equ	15h	; 500 Kbps, established, 1.2M in 1.2M
   376                              <1> fdc_m_try_1440		equ	07h	; 500 Kbps, not established, other drive
   377                              <1> fdc_m_1440		equ	17h	; 500 Kbps, established, other drive
   378                              <1> fdc_m_try_2880		equ	0C7h	; 1 Mbps, not established, other drive
   379                              <1> fdc_m_2880		equ	0D7h	; 1 Mbps, established, other drive
   380                              <1> 
   381                              <1> ;-------------------------------------------------------------------------
   382                              <1> ; IRQ flag - fdc_calib_state, bit 7. Set by INT 0Eh (IRQ6) interrupt handler
   383                              <1> ;	     when IRQ6 happens to indicate completion of an I/O operation
   384                              <1> 
   385                              <1> fdc_irq_flag	equ	80h		; IRQ6 had occurred
   386                              <1> 
   387                              <1> ; write flag - fdc_motor_state, bit 7. Set for write or format,
   388                              <1> ;	       unset for read or verify
   389                              <1> 
   390                              <1> fdc_write_flag	equ	80h		; write or format operation
   391                              <1> 
   392                              <1> ;-------------------------------------------------------------------------
   393                              <1> ; floppy drive type definitions
   394                              <1> 
   395                              <1> type_none	equ	00h
   396                              <1> type_360	equ	01h
   397                              <1> type_1200	equ	02h
   398                              <1> type_720	equ	03h
   399                              <1> type_1440	equ	04h
   400                              <1> type_2880	equ	06h
   401                              <1> 
   402                              <1> ;=========================================================================
   403                              <1> ; int_13_fn00: Reset disk system
   404                              <1> ; Input:
   405                              <1> ;	AH = 00h
   406                              <1> ;	DL = drive number (bit 7 not set - floppy drive)
   407                              <1> ; Output:
   408                              <1> ;	CF clear if successful
   409                              <1> ;		AH = 00h - successful completion
   410                              <1> ;	CF set on error
   411                              <1> ;		AH = 20h - controller failure
   412                              <1> ;		AH = 80h - timeout / device not ready
   413                              <1> ; Note:
   414                              <1> ;	This function doesn't check drive number, but HDD BIOS (if installed)
   415                              <1> ;	normally will call this functions if bit 7 of DL is not set
   416                              <1> ;-------------------------------------------------------------------------
   417                              <1> int_13_fn00:
   418 0000181A E80700              <1> 	call	fdc_init
   419 0000181D 88264100            <1> 	mov	byte [fdc_last_error],ah  ; save the error code
   420 00001821 E9CD34              <1> 	jmp	int_13_exit
   421                              <1> 
   422                              <1> ;=========================================================================
   423                              <1> ; fdc_init - Initialize floppy disk controller
   424                              <1> ; Input:
   425                              <1> ;	none
   426                              <1> ; Output:
   427                              <1> ;	CF clear on success
   428                              <1> ;		AH = 00h - successful completion
   429                              <1> ;	CF set if error
   430                              <1> ;		AH = 20h - controller failure
   431                              <1> ;		AH = 80h - timeout / device not ready
   432                              <1> ;-------------------------------------------------------------------------
   433                              <1> fdc_init:
   434 00001824 80263E00F0          <1> 	and	byte [fdc_calib_state],0F0h ; require recalibration
   435 00001829 E8BA05              <1> 	call	fdc_reset		; reset FDC
   436 0000182C 7257                <1> 	jc	fdc_init_error
   437 0000182E BAF403              <1> 	mov	dx,fdc_status_reg	; get status register address
   438 00001831 EC                  <1> 	in	al,dx
   439 00001832 A880                <1> 	test	al,80h
   440 00001834 7404                <1> 	jz	.try_again		; try again if FDC not ready
   441 00001836 A840                <1> 	test	al,40h
   442 00001838 740F                <1> 	jz	.fdc_ready		; FDC ready to recieve data
   443                              <1> .try_again:
   444 0000183A E8A905              <1> 	call	fdc_reset
   445 0000183D BAF403              <1> 	mov	dx,fdc_status_reg	; get status register address
   446 00001840 EC                  <1> 	in	al,dx
   447 00001841 A880                <1> 	test	al,80h
   448 00001843 7440                <1> 	jz	fdc_init_error
   449 00001845 A840                <1> 	test	al,40h
   450 00001847 753C                <1> 	jnz	fdc_init_error
   451                              <1> .fdc_ready:
   452 00001849 B008                <1> 	mov	al,08h			; FDC Sense Interrupt Status command
   453 0000184B E8D904              <1> 	call	fdc_write		; send the command
   454 0000184E 7235                <1> 	jc	fdc_init_error
   455 00001850 E83105              <1> 	call	fdc_read		; read ST0
   456 00001853 7230                <1> 	jc	fdc_init_error
   457 00001855 A24200              <1> 	mov	byte [fdc_ctrl_status],al  ; save ST0
   458 00001858 88C4                <1> 	mov	ah,al			; save AL to AH
   459 0000185A E82705              <1> 	call	fdc_read		; read current cylinder
   460 0000185D 7226                <1> 	jc	fdc_init_error
   461 0000185F A24300              <1> 	mov	byte [fdc_ctrl_status+1],al  ; save
   462 00001862 80E4C0              <1> 	and	ah,0C0h
   463 00001865 80FCC0              <1> 	cmp	ah,0C0h			; abnormal termination?
   464 00001868 751B                <1> 	jne	fdc_init_error	; not an abnormal termination
   465                              <1> 
   466                              <1> ; fall through to fdc_send_specify
   467                              <1> 
   468                              <1> ;=========================================================================
   469                              <1> ; fdc_send_specify - Send specify command to FDC
   470                              <1> ; Input:
   471                              <1> ;	none
   472                              <1> ; Output:
   473                              <1> ;	CF clear on success
   474                              <1> ;		AH = 00 - successful completion
   475                              <1> ;	CF set if error
   476                              <1> ;		AH = 20h - controller failure
   477                              <1> ;	AX,CL,SI trashed
   478                              <1> ; Note:
   479                              <1> ;	Specify command parameters are obtained from table at INT 1Eh vector
   480                              <1> ;-------------------------------------------------------------------------
   481                              <1> fdc_send_specify:
   482 0000186A 1E                  <1> 	push	ds
   483 0000186B 31F6                <1> 	xor	si,si
   484 0000186D 8EDE                <1> 	mov	ds,si
   485 0000186F C5367800            <1> 	lds	si,[1Eh*4]		; DS:SI -> INT 1Eh
   486 00001873 B003                <1> 	mov	al,3		 	; FDC Specify command
   487 00001875 8A24                <1> 	mov	ah,byte [si]		; specify command - byte 0
   488 00001877 8B7401              <1> 	mov	si,word [si+1]		; specify command - byte 1
   489 0000187A B103                <1> 	mov	cl,3			; command length 3 bytes (AX, SI - low)
   490 0000187C 1F                  <1> 	pop	ds
   491 0000187D E85B04              <1> 	call	fdc_send_cmd		; send specify command to FDC
   492 00001880 7203                <1> 	jc	fdc_init_error
   493 00001882 B400                <1> 	mov	ah,fdc_e_success	; successful completion
   494 00001884 C3                  <1> 	ret
   495                              <1> 
   496                              <1> fdc_init_error:
   497 00001885 B420                <1> 	mov	ah,fdc_e_failure
   498 00001887 F9                  <1> 	stc
   499 00001888 C3                  <1> 	ret
   500                              <1> 
   501                              <1> ;=========================================================================
   502                              <1> ; int_13_fn01 - Get status of last operation
   503                              <1> ; Input:
   504                              <1> ;	AH = 01h
   505                              <1> ;	DL = drive number (bit 7 not set - floppy drive)
   506                              <1> ; Output:
   507                              <1> ;	CF clear if last operation was successful
   508                              <1> ;		AH = 00h - successful completion
   509                              <1> ;	CF set on error
   510                              <1> ;		AH - error code of the last operation
   511                              <1> ; Note:
   512                              <1> ;	This function doesn't check drive number, but HDD BIOS (if installed)
   513                              <1> ;	normally will call this functions if bit 7 of DL is not set
   514                              <1> ;-------------------------------------------------------------------------
   515                              <1> int_13_fn01:
   516 00001889 8A264100            <1> 	mov	ah,byte [fdc_last_error]
   517 0000188D 08E4                <1> 	or	ah,ah
   518 0000188F 7401                <1> 	jz	.no_error
   519 00001891 F9                  <1> 	stc
   520                              <1> .no_error:
   521 00001892 E95C34              <1> 	jmp	int_13_exit
   522                              <1> 
   523                              <1> ;=========================================================================
   524                              <1> ; int_13_fn08: Get drive parameters
   525                              <1> ; Input:
   526                              <1> ;	AH = 08h
   527                              <1> ;	DL = drive number (0 - 7Fh)
   528                              <1> ; Output:
   529                              <1> ;	CF clear if successful
   530                              <1> ;		AX = 0000h
   531                              <1> ;		BH = 00h
   532                              <1> ;		BL = drive type
   533                              <1> ;		CH = maximal cylinder number - 1
   534                              <1> ;		CL = maximal sector number
   535                              <1> ;		DH = maximal head number
   536                              <1> ;		DL = number of drives
   537                              <1> ;		ES:DI -> diskette parameter table
   538                              <1> ;	CF set on error
   539                              <1> ;		AH = 01h - drive number is greater than 7Fh
   540                              <1> ; Notes:
   541                              <1> ;	- If non-existent drive number is specified, function returns zeros in
   542                              <1> ;	AX,BX,CX,DH,ES,DI and number of floppy drives in DL (0 if no floppies)
   543                              <1> ;	- If media type is not established function sets media parameters 
   544                              <1> ;	based on drive type
   545                              <1> ;-------------------------------------------------------------------------
   546                              <1> int_13_fn08:
   547 00001895 80FA80              <1> 	cmp	dl,80h			; valid floppy drive number?
   548 00001898 7203E99E00          <1> 	jae	.invalid_drive		; hard drive number specified
   549 0000189D A01000              <1> 	mov	al,byte [equipment_list]
   550 000018A0 2441                <1> 	and	al,equip_floppies|equip_floppy2
   551 000018A2 B402                <1> 	mov	ah,2			; assume two floppy drives
   552 000018A4 3C41                <1> 	cmp	al,equip_floppies|equip_floppy2 ; two floppy drives?
   553 000018A6 7406                <1> 	je	.check_drive_number
   554 000018A8 FECC                <1> 	dec	ah			; assume one floppy drive
   555 000018AA 3C01                <1> 	cmp	al,equip_floppies	; one floppy drive?
   556 000018AC 757B                <1> 	jne	.no_drives
   557                              <1> 
   558                              <1> .check_drive_number:
   559 000018AE 886608              <1> 	mov	byte [bp+int_13_dl],ah	; pass number of drives to caller
   560 000018B1 38E2                <1> 	cmp	dl,ah			; requested drive number is larger
   561                              <1> 					; than number of disks?
   562 000018B3 7378                <1> 	jnb	.non_existent_drive	; jump if non existent drive requested
   563 000018B5 E8D106              <1> 	call	get_drive_type		; returns drive type in AL
   564 000018B8 7273                <1> 	jc	.non_existent_drive	; return no drive if there is an error
   565                              <1> 
   566 000018BA C6460901            <1> 	mov	byte [bp+int_13_dh],1	; maximal head number is 1 for floppy
   567 000018BE 88460C              <1> 	mov	byte [bp+int_13_bl],al	; pass drive type to caller
   568 000018C1 8CC9                <1> 	mov	cx,cs
   569 000018C3 8EC1                <1> 	mov	es,cx			; diskette parameter table segment
   570                              <1> 
   571 000018C5 3C01                <1> 	cmp	al,type_360
   572 000018C7 7417                <1> 	je	.set_360
   573 000018C9 3C03                <1> 	cmp	al,type_720
   574 000018CB 741E                <1> 	je	.set_720
   575 000018CD 3C02                <1> 	cmp	al,type_1200
   576 000018CF 7425                <1> 	je	.set_1200
   577 000018D1 3C04                <1> 	cmp	al,type_1440
   578 000018D3 742C                <1> 	je	.set_1440
   579                              <1> 
   580                              <1> .set_2880:
   581 000018D5 B0C7                <1> 	mov	al,fdc_m_try_2880	; try 2.88M in 2.88M drive
   582 000018D7 8D3E[B04F]          <1> 	lea	di,[media_2880]		; only 2.88M uses 1 Mbps rate
   583 000018DB B9244F              <1> 	mov	cx,4F24h		; 2.88M - 80 cylinders, 36 sectors
   584 000018DE EB2A                <1> 	jmp	.set_media_type
   585                              <1> 
   586                              <1> .set_360:
   587 000018E0 B093                <1> 	mov	al,fdc_m_360in360
   588 000018E2 8D3E[6F4F]          <1> 	lea	di,[media_360_in_360]
   589 000018E6 B90927              <1> 	mov	cx,2709h		; 360K - 40 cylinders, 9 sectors
   590 000018E9 EB1F                <1> 	jmp	.set_media_type
   591                              <1> 
   592                              <1> .set_720:
   593 000018EB B097                <1> 	mov	al,fdc_m_720
   594 000018ED 8D3E[894F]          <1> 	lea	di,[media_720]
   595 000018F1 B9094F              <1> 	mov	cx,4F09h		; 720K - 80 cylinders, 9 sectors
   596 000018F4 EB14                <1> 	jmp	.set_media_type
   597                              <1> 
   598                              <1> .set_1200:
   599 000018F6 B002                <1> 	mov	al,fdc_m_try_1200in1200
   600 000018F8 8D3E[7C4F]          <1> 	lea	di,[media_1200]
   601 000018FC B90F4F              <1> 	mov	cx,4F0Fh		; 1.2M - 80 cylinders, 15 sectors
   602 000018FF EB09                <1> 	jmp	.set_media_type
   603                              <1> 
   604                              <1> .set_1440:
   605 00001901 B007                <1> 	mov	al,fdc_m_try_1440
   606 00001903 8D3E[964F]          <1> 	lea	di,[media_1440]
   607 00001907 B9124F              <1> 	mov	cx,4F12h		; 1.44M - 80 cylinders, 18 sectors
   608                              <1> 
   609                              <1> .set_media_type:
   610 0000190A E81C06              <1> 	call	get_media_state
   611 0000190D F6C310              <1> 	test	bl,fdc_m_established	; media type established?
   612 00001910 7503                <1> 	jnz	.set_parameters		; no need to update if established
   613 00001912 E81E06              <1> 	call	set_media_state
   614                              <1> 
   615                              <1> .set_parameters:
   616 00001915 31C0                <1> 	xor	ax,ax			; AH = 00h - successful completion
   617 00001917 88460E              <1> 	mov	byte [bp+int_13_al],al	; successful completion
   618 0000191A A24100              <1> 	mov	byte [fdc_last_error],al
   619 0000191D 88460D              <1> 	mov	byte [bp+int_13_bh],al	; clear BH just in case
   620 00001920 894E0A              <1> 	mov	word [bp+int_13_cx],cx	; cylinders / sectors
   621 00001923 897E04              <1> 	mov	word [bp+int_13_di],di	; diskette parameter table pointer
   622 00001926 E9C833              <1> 	jmp	int_13_exit
   623                              <1> 
   624                              <1> .no_drives:
   625 00001929 C6460800            <1> 	mov	byte [bp+int_13_dl],0	; zero drives
   626                              <1> 
   627                              <1> .non_existent_drive:
   628 0000192D 31C9                <1> 	xor	cx,cx
   629 0000192F 31FF                <1> 	xor	di,di
   630 00001931 884E0C              <1> 	mov	byte [bp+int_13_bl],cl	; drive type is zero
   631 00001934 884E09              <1> 	mov	byte [bp+int_13_dh],cl	; maximal head number is zero
   632 00001937 8EC1                <1> 	mov	es,cx			; disk parameter table segment = 0000h
   633 00001939 EBDA                <1> 	jmp	.set_parameters
   634                              <1> 
   635                              <1> .invalid_drive:
   636 0000193B B401                <1> 	mov	ah,fdc_e_invalid
   637 0000193D F9                  <1> 	stc
   638 0000193E E9B033              <1> 	jmp	int_13_exit
   639                              <1> 
   640                              <1> ;=========================================================================
   641                              <1> ; int_13_fn15: Get disk type
   642                              <1> ; Input:
   643                              <1> ;	AH = 15h
   644                              <1> ;	DL = drive number (0 or 1)
   645                              <1> ; Output:
   646                              <1> ;	AH = type code:
   647                              <1> ;		00h - no such drive (invalid drive specified)
   648                              <1> ;		01h - floppy without change-line support
   649                              <1> ;		02h - floppy with change-line support
   650                              <1> ;-------------------------------------------------------------------------
   651                              <1> int_13_fn15:
   652 00001941 B400                <1> 	mov	ah,00h			; assume no drive
   653 00001943 3C00                <1> 	cmp	al,type_none
   654 00001945 740C                <1> 	je	.exit
   655 00001947 B401                <1> 	mov	ah,01h			; assume no change-line support
   656 00001949 3C01                <1> 	cmp	al,type_360
   657 0000194B 7406                <1> 	je	.exit
   658 0000194D 3C03                <1> 	cmp	al,type_720		; no change-line support on 720K drives?
   659 0000194F 7402                <1> 	je	.exit
   660 00001951 B402                <1> 	mov	ah,02h			; otherwise it supports change-line
   661                              <1> 
   662                              <1> .exit:
   663 00001953 F8                  <1> 	clc
   664 00001954 C606410000          <1> 	mov	byte [fdc_last_error],0
   665 00001959 E99533              <1> 	jmp	int_13_exit
   666                              <1> 
   667                              <1> ;=========================================================================
   668                              <1> ; int_13_fn16 - Detect disk change
   669                              <1> ; Input:
   670                              <1> ;	AH = 16h
   671                              <1> ;	DL = drive number (0 or 1)
   672                              <1> ; Output:
   673                              <1> ;	CF clear if change line inactive
   674                              <1> ;		AH = 00h - disk not changed
   675                              <1> ;	CF set if change line active or error
   676                              <1> ;		AH = 01h - invalid drive number
   677                              <1> ;		AH = 06h - disk changed or change line not supported
   678                              <1> ;		AH = 80h - timeout / device not ready
   679                              <1> ;-------------------------------------------------------------------------
   680                              <1> int_13_fn16:
   681 0000195C 3C01                <1> 	cmp	al,type_360
   682 0000195E 742E                <1> 	je	.no_change_line		; report disk changed for 360K drives
   683 00001960 3C03                <1> 	cmp	al,type_720
   684 00001962 742A                <1> 	je	.no_change_line		; report disk changed for 720K drives
   685                              <1> 
   686 00001964 E81602              <1> 	call	fdc_motor_on		; turn motor on
   687 00001967 30E4                <1> 	xor	ah,ah			; assume disk not changed
   688 00001969 BAF703              <1> 	mov	dx,fdc_dir_reg		; get digital input register address
   689 0000196C EC                  <1> 	in	al,dx			; read disk change line
   690 0000196D D0E0                <1> 	shl	al,1			; bit 7 to CF
   691 0000196F 7303                <1> 	jnc	.exit
   692 00001971 B406                <1> 	mov	ah,fdc_e_changed
   693 00001973 F9                  <1> 	stc
   694                              <1> 
   695                              <1> .exit:
   696 00001974 88264100            <1> 	mov	byte [fdc_last_error],ah  ; save the error code
   697 00001978 9C                  <1> 	pushf
   698 00001979 1E                  <1> 	push	ds
   699 0000197A 31F6                <1> 	xor	si,si
   700 0000197C 8EDE                <1> 	mov	ds,si
   701 0000197E C5367800            <1> 	lds	si,[1Eh*4]		; DS:SI -> INT 1Eh
   702 00001982 8A4C02              <1> 	mov	cl,byte [si+2]
   703 00001985 1F                  <1> 	pop	ds
   704 00001986 880E4000            <1> 	mov	byte [fdc_motor_tout],cl ; ticks before turning off the motor
   705 0000198A 9D                  <1> 	popf
   706 0000198B E96333              <1> 	jmp	int_13_exit
   707                              <1> 
   708                              <1> .no_change_line:
   709 0000198E B406                <1> 	mov	ah,fdc_e_changed	; can't detect - report disk changed
   710 00001990 F9                  <1> 	stc
   711 00001991 88264100            <1> 	mov	byte [fdc_last_error],ah
   712 00001995 E95933              <1> 	jmp	int_13_exit
   713                              <1> 
   714                              <1> .invalid_drive:
   715 00001998 B401                <1> 	mov	ah,fdc_e_invalid
   716 0000199A F9                  <1> 	stc
   717 0000199B E95333              <1> 	jmp	int_13_exit
   718                              <1> 
   719                              <1> ;=========================================================================
   720                              <1> ; int_13_fn17 - Set disk type for format
   721                              <1> ; Input:
   722                              <1> ;	AH = 17h
   723                              <1> ;	AL = format type
   724                              <1> ;		01h - 320K / 360K disk in 360K drive
   725                              <1> ;		02h - 320K / 360K disk in 1.2M drive
   726                              <1> ;		03h - 1.2M disk in 1.2M drive
   727                              <1> ;		04h - 720K disk in 720K or 1.2M drive
   728                              <1> ;	DL = drive number (0 or 1)
   729                              <1> ; Output:
   730                              <1> ;	CF clear if successful
   731                              <1> ;		AH = 00h - successful completion
   732                              <1> ;	CF set on error
   733                              <1> ;		AH = 01h - invalid drive number
   734                              <1> ;		AH = 06h - disk changed
   735                              <1> ;		AH = 80h - timeout / device not ready
   736                              <1> ;-------------------------------------------------------------------------
   737                              <1> int_13_fn17:
   738 0000199E 8A4E0E              <1> 	mov	cl,byte [bp+int_13_al]	; get original AL value to CL
   739 000019A1 80F900              <1> 	cmp	cl,0			; validate parameters
   740 000019A4 744F                <1> 	je	.invalid_parameters
   741 000019A6 80F904              <1> 	cmp	cl,4
   742 000019A9 774A                <1> 	ja	.invalid_parameters
   743 000019AB 80F901              <1> 	cmp	cl,1			; 360K disk in 360K drive?
   744 000019AE 7506                <1> 	jne	.not_360in360
   745 000019B0 B400                <1> 	mov	ah,0			; no error
   746 000019B2 B093                <1> 	mov	al,fdc_m_360in360	; 360K disk in 360K drive
   747 000019B4 EB30                <1> 	jmp	.exit_check_error
   748                              <1> 
   749                              <1> .not_360in360:
   750 000019B6 E8C401              <1> 	call	fdc_motor_on
   751 000019B9 E86602              <1> 	call	fdc_disk_change		; check if disk has been changed
   752 000019BC 80FC06              <1> 	cmp	ah,fdc_e_changed
   753 000019BF 7611                <1> 	jbe	.set_type		; disk changed (no errors other than
   754                              <1> 					; "disk changed" from fdc_disk_change)
   755 000019C1 80FC80              <1> 	cmp	ah,fdc_e_timeout
   756 000019C4 750C                <1> 	jne	.set_type		; floppy disk is installed
   757 000019C6 E86005              <1> 	call	get_media_state		; BL = media state
   758 000019C9 80FB97              <1> 	cmp	bl,fdc_m_720		; 250 Kbps and not 5.25?
   759 000019CC 7418                <1> 	je	.exit_check_error
   760 000019CE B061                <1> 	mov	al,fdc_m_try_360in1200	; 300 Kpbs, try 360 in 1.2M
   761 000019D0 EB14                <1> 	jmp	.exit_check_error
   762                              <1> 
   763                              <1> .set_type:
   764 000019D2 80F904              <1> 	cmp	cl,4			; 720K in 720K?
   765 000019D5 7504                <1> 	jne	.check_360in1200	; jump if not 720K in 720K
   766 000019D7 B097                <1> 	mov	al,fdc_m_720
   767 000019D9 EB0B                <1> 	jmp	.exit_check_error
   768                              <1> 
   769                              <1> .check_360in1200:
   770 000019DB 80F902              <1> 	cmp	cl,2			; 360K in 1.2M?
   771 000019DE 7504                <1> 	jne	.set_1200in1200		; jump if not 360K in 1.2M
   772 000019E0 B074                <1> 	mov	al,fdc_m_360in1200
   773 000019E2 EB02                <1> 	jmp	.exit_check_error
   774                              <1> 
   775                              <1> .set_1200in1200:
   776 000019E4 B015                <1> 	mov	al,fdc_m_1200in1200	; 1.2M in 1.2M
   777                              <1> 
   778                              <1> .exit_check_error:
   779 000019E6 E84A05              <1> 	call	set_media_state		; set media state to value in AL
   780 000019E9 88264100            <1> 	mov	byte [fdc_last_error],ah
   781 000019ED 08E4                <1> 	or	ah,ah
   782 000019EF 7401                <1> 	jz	.exit			; jump if no error
   783 000019F1 F9                  <1> 	stc				; indicate error
   784                              <1> 
   785                              <1> .exit:
   786 000019F2 E9DD32              <1> 	jmp	int_13_upd_exit
   787                              <1> 
   788                              <1> .invalid_parameters:
   789 000019F5 B401                <1> 	mov	ah,fdc_e_invalid
   790 000019F7 EBF9                <1> 	jmp	.exit
   791                              <1> 
   792                              <1> ;=========================================================================
   793                              <1> ; int_13_fn18 - Set media type for format
   794                              <1> ; Input:
   795                              <1> ;	AH = 18h
   796                              <1> ;	DL = drive number (0 or 1)
   797                              <1> ;	CH = number of cylinders - 1
   798                              <1> ;	CL = sectors per track
   799                              <1> ; Output:
   800                              <1> ;	CF = clear if successful
   801                              <1> ;		AH = 00h - requested format is supported
   802                              <1> ;		ES:DI -> diskette parameter table
   803                              <1> ;	CF = set on error
   804                              <1> ;		AH = 01h - invalid drive number specified
   805                              <1> ;		AH = 0Ch - format is not supported or drive type is unknown
   806                              <1> ;-------------------------------------------------------------------------
   807                              <1> int_13_fn18:
   808 000019F9 3C01                <1> 	cmp	al,type_360		; 360K drive?
   809 000019FB 750E                <1> 	jne	.try_drive_1200
   810 000019FD 81F90927            <1> 	cmp	cx,2709h	 	; 40 tracks 9 sectors?
   811 00001A01 7573                <1> 	jnz	.unsupported_format
   812 00001A03 B093                <1> 	mov	al,fdc_m_360in360	; 360K in 360K established, 250 Kbps
   813 00001A05 8D3E[6F4F]          <1> 	lea	di,[media_360_in_360]
   814 00001A09 EB54                <1> 	jmp	.set_media
   815                              <1> 
   816                              <1> .try_drive_1200:
   817 00001A0B 3C02                <1> 	cmp	al,type_1200		; 1.2M drive?
   818 00001A0D 751C                <1> 	jne	.try_drive_2880
   819 00001A0F 81F90F4F            <1> 	cmp	cx,4F0Fh		; 80 tracks 15 sectors?
   820 00001A13 7508                <1> 	jne	.try_media_360_in_1200
   821 00001A15 B015                <1> 	mov	al,fdc_m_1200in1200	; 1.2M in 1.2M established, 500Kbps
   822 00001A17 8D3E[7C4F]          <1> 	lea	di,[media_1200]		; 1.2M
   823 00001A1B EB42                <1> 	jmp	.set_media
   824                              <1> 
   825                              <1> .try_media_360_in_1200:
   826 00001A1D 81F90927            <1> 	cmp	cx,2709h		; 80 tracks 9 sectors?
   827 00001A21 7553                <1> 	jne	.unsupported_format
   828 00001A23 B074                <1> 	mov	al,fdc_m_360in1200	; 360K in 1.2M established, 300Kbps
   829 00001A25 8D3E[A34F]          <1> 	lea	di,[media_360_in_1200]	; 360K in 1.2M
   830 00001A29 EB34                <1> 	jmp	.set_media
   831                              <1> 
   832                              <1> .try_drive_2880:
   833 00001A2B 3C06                <1> 	cmp	al,type_2880		; 2.88M drive?
   834 00001A2D 750E                <1> 	jne	.try_drive_1440
   835 00001A2F 81F9244F            <1> 	cmp	cx,4F24h		; 80 tracks 36 sectors?
   836 00001A33 750C                <1> 	jne	.try_media_1440
   837 00001A35 B0D7                <1> 	mov	al,fdc_m_2880		; indicate 2.88M
   838 00001A37 8D3E[B04F]          <1> 	lea	di,[media_2880]
   839 00001A3B EB22                <1> 	jmp	.set_media
   840                              <1> 
   841                              <1> .try_drive_1440:
   842 00001A3D 3C04                <1> 	cmp	al,type_1440		; 1.44M drive?
   843 00001A3F 750E                <1> 	jne	.try_drive_720
   844                              <1> 
   845                              <1> .try_media_1440:
   846 00001A41 81F9124F            <1> 	cmp	cx,4F12h		; 80 tracks 18 sectors?
   847 00001A45 750C                <1> 	jne	.try_media_720
   848 00001A47 B017                <1> 	mov	al,fdc_m_1440		; indicate 1.44M
   849 00001A49 8D3E[964F]          <1> 	lea	di,[media_1440]
   850 00001A4D EB10                <1> 	jmp	.set_media
   851                              <1> 
   852                              <1> .try_drive_720:
   853 00001A4F 3C03                <1> 	cmp	al,type_720		; 720K drive?
   854 00001A51 7523                <1> 	jne	.unsupported_format	; should never happen...
   855                              <1> 
   856                              <1> .try_media_720:	
   857 00001A53 81F9094F            <1> 	cmp	cx,4F09h		; 80 tracks 9 sectors?
   858 00001A57 751D                <1> 	jne	.unsupported_format
   859 00001A59 B097                <1> 	mov	al,fdc_m_720		; other established, 250Kbps
   860 00001A5B 8D3E[894F]          <1> 	lea	di,[media_720]		; 720K
   861                              <1> 
   862                              <1> .set_media:
   863 00001A5F E8D104              <1> 	call	set_media_state		; set drive media state (in AL)
   864 00001A62 E87404              <1> 	call	fdc_set_rate		; transfer rate in AL (bits 7-6)
   865 00001A65 897E04              <1> 	mov	word [bp+int_13_di],di	; return parameters table - offset
   866 00001A68 8CC9                <1> 	mov	cx,cs
   867 00001A6A 8EC1                <1> 	mov	es,cx			; return parameters table - segment
   868 00001A6C C606410000          <1> 	mov	byte [fdc_last_error],0	; no errors
   869 00001A71 30E4                <1> 	xor	ah,ah
   870 00001A73 E95C32              <1> 	jmp	int_13_upd_exit
   871                              <1> 
   872                              <1> .unsupported_format:
   873 00001A76 B40C                <1> 	mov	ah,fdc_e_format		; not supported or drive type unknown
   874 00001A78 F9                  <1> 	stc
   875 00001A79 E95632              <1> 	jmp	int_13_upd_exit
   876                              <1> 
   877                              <1> ;=========================================================================
   878                              <1> ; fdc_recalibrate - Recalibrate disk drive, seek to cylinder 0
   879                              <1> ; Input:
   880                              <1> ;	[BP+int_13_dl] = drive number (0 or 1)
   881                              <1> ; Output:
   882                              <1> ;	CF clear if successful
   883                              <1> ;		AH = 00h - successful completion
   884                              <1> ;	CF set on error
   885                              <1> ;		AH = 20h - controller failure
   886                              <1> ;		AH = 20h - timeout
   887                              <1> ;	AH trashed
   888                              <1> ;-------------------------------------------------------------------------
   889                              <1> fdc_recalibrate:
   890 00001A7C 56                  <1> 	push	si
   891 00001A7D 51                  <1> 	push	cx
   892 00001A7E 52                  <1> 	push	dx
   893 00001A7F B007                <1> 	mov	al,07h			; FDC Recalibrate command
   894 00001A81 8A6608              <1> 	mov	ah,byte [bp+int_13_dl]	; drive number - 2nd byte of command
   895 00001A84 B102                <1> 	mov	cl,2			; 2 bytes command
   896 00001A86 80263E007F          <1> 	and	byte [fdc_calib_state],~fdc_irq_flag ; clear IRQ flag
   897 00001A8B E84D02              <1> 	call	fdc_send_cmd
   898 00001A8E 7236                <1> 	jc	recal_end		; failure
   899 00001A90 E85F04              <1> 	call	fdc_wait_irq		; wait for IRQ
   900 00001A93 7231                <1> 	jc	recal_end		; timeout waiting for interrupt
   901 00001A95 B008                <1> 	mov	al,08h			; FDC Sense Interrupt Status command
   902 00001A97 B101                <1> 	mov	cl,1			; 1 byte command
   903 00001A99 E83F02              <1> 	call	fdc_send_cmd
   904 00001A9C 7228                <1> 	jc	recal_end		; failure
   905 00001A9E B90200              <1> 	mov	cx,2			; 2 bytes result
   906 00001AA1 E8A902              <1> 	call	fdc_get_result		; store result
   907 00001AA4 7220                <1> 	jc	recal_end		; failure
   908 00001AA6 BB4200              <1> 	mov	bx,fdc_ctrl_status
   909 00001AA9 B440                <1> 	mov	ah,fdc_e_seek
   910 00001AAB 8A17                <1> 	mov	dl,byte [bx]			; ST0
   911 00001AAD 80E260              <1> 	and	dl,60h
   912 00001AB0 80FA60              <1> 	cmp	dl,60h			; abnormal termination + seek end
   913 00001AB3 F9                  <1> 	stc				; indicate error
   914 00001AB4 7410                <1> 	je	recal_end		; failure
   915                              <1> 
   916 00001AB6 B500                <1> 	mov	ch,0
   917 00001AB8 E89004              <1> 	call	set_cylinder		; set current cylinder to 0
   918 00001ABB E8A704              <1> 	call	set_drive_calibrated	; set drive calibrated in data area
   919 00001ABE B94300              <1> 	mov	cx,43h
   920 00001AC1 E8ACFB              <1> 	call	delay_15us		; 1 ms delay
   921 00001AC4 30E4                <1> 	xor	ah,ah			; AH = 0, CF = 0 - no error
   922                              <1> 
   923                              <1> recal_end:
   924 00001AC6 88264100            <1> 	mov	byte [fdc_last_error],ah
   925 00001ACA 5A                  <1> 	pop	dx
   926 00001ACB 59                  <1> 	pop	cx
   927 00001ACC 5E                  <1> 	pop	si
   928 00001ACD C3                  <1> 	ret
   929                              <1> 
   930                              <1> ;=========================================================================
   931                              <1> ; fdc_seek - Move floppy drive head to the specified cylinder
   932                              <1> ; Input:
   933                              <1> ;	DL = drive number
   934                              <1> ;	DH = head number
   935                              <1> ;	CH = cylinder
   936                              <1> ; Output:
   937                              <1> ;	CF clear if successful
   938                              <1> ;		AH = 00h - successful completion
   939                              <1> ;	CF set on error
   940                              <1> ;		AH = 20h - controller failure
   941                              <1> ;		AH = 40h - seek failed
   942                              <1> ;		AH = 80h - timeout / device not ready
   943                              <1> ;-------------------------------------------------------------------------
   944                              <1> fdc_seek:
   945 00001ACE 53                  <1> 	push	bx
   946 00001ACF 51                  <1> 	push	cx
   947 00001AD0 52                  <1> 	push	dx
   948 00001AD1 E88304              <1> 	call	check_drive_calibrated
   949 00001AD4 720A                <1> 	jc	.skip_recalibrate	; jump if drive is already calibrated
   950 00001AD6 E8A3FF              <1> 	call	fdc_recalibrate
   951 00001AD9 7305                <1> 	jnc	.skip_recalibrate	; jump if calibration successful
   952 00001ADB E89EFF              <1> 	call	fdc_recalibrate		; try recalibrating again
   953 00001ADE 727B                <1> 	jc	.exit			; no luck...
   954                              <1> 
   955                              <1> .skip_recalibrate:
   956 00001AE0 E84604              <1> 	call	get_media_state		; BL = media state
   957 00001AE3 F6C320              <1> 	test	bl,fdc_m_double_step 	; check double stepping bit
   958 00001AE6 7402                <1> 	jz	.no_double_stepping
   959 00001AE8 D0E5                <1> 	shl	ch,1			; CH = CH * 2 (double cylinder number)
   960                              <1> 
   961                              <1> .no_double_stepping:
   962 00001AEA E85204              <1> 	call	check_cylinder		; already at the right cylinder?
   963 00001AED 750B                <1> 	jnz	.do_seek		; jump if seek is required
   964 00001AEF 803E410040          <1> 	cmp	byte [fdc_last_error],fdc_e_seek
   965 00001AF4 7404                <1> 	je	.do_seek		; jump if it was a seek error
   966 00001AF6 30E4                <1> 	xor	ah,ah			; AH = 0, CF = 0 - success
   967 00001AF8 EB61                <1> 	jmp	.exit
   968                              <1> 
   969                              <1> .do_seek:
   970 00001AFA 88E8                <1> 	mov	al,ch			; cylinder
   971 00001AFC 89C6                <1> 	mov	si,ax			; SI - low = cylinder number
   972 00001AFE B00F                <1> 	mov	al,0Fh			; FDC Seek command
   973 00001B00 88F4                <1> 	mov	ah,dh			; head
   974 00001B02 D0E4                <1> 	shl	ah,1			; move head to bit 2
   975 00001B04 D0E4                <1> 	shl	ah,1
   976 00001B06 0A6608              <1> 	or	ah,byte [bp+int_13_dl]	; seek - byte 1 (head / drive)
   977 00001B09 B103                <1> 	mov	cl,3			; 3 bytes command
   978 00001B0B 80263E007F          <1> 	and	byte [fdc_calib_state],~fdc_irq_flag ; clear IRQ flag
   979 00001B10 E8C801              <1> 	call	fdc_send_cmd
   980 00001B13 7242                <1> 	jc	.set_result		; seek error
   981 00001B15 E8DA03              <1> 	call	fdc_wait_irq		; wait for IRQ
   982 00001B18 723D                <1> 	jc	.set_result		; timeout waiting for interrupt
   983                              <1> 
   984 00001B1A B008                <1> 	mov	al,08h			; FDC Sense Interrupt Status command
   985 00001B1C B101                <1> 	mov	cl,1			; 1 byte command
   986 00001B1E E8BA01              <1> 	call	fdc_send_cmd
   987 00001B21 7234                <1> 	jc	.set_result		; failure
   988 00001B23 B102                <1> 	mov	cl,2
   989 00001B25 53                  <1> 	push	bx
   990 00001B26 E82402              <1> 	call	fdc_get_result		; read result bytes
   991 00001B29 5B                  <1> 	pop	bx
   992 00001B2A 722B                <1> 	jc	.set_result		; error
   993 00001B2C B440                <1> 	mov	ah,fdc_e_seek
   994 00001B2E A04200              <1> 	mov	al,byte [fdc_ctrl_status] ; ST0
   995 00001B31 2460                <1> 	and	al,60h
   996 00001B33 3C60                <1> 	cmp	al,60h			; abnormal termination + seek end
   997 00001B35 F9                  <1> 	stc
   998 00001B36 741F                <1> 	je	.set_result		; seek error
   999 00001B38 E81004              <1> 	call	set_cylinder		; save new cylinder number
  1000                              <1> 
  1001 00001B3B 1E                  <1> 	push	ds
  1002 00001B3C 31F6                <1> 	xor	si,si
  1003 00001B3E 8EDE                <1> 	mov	ds,si
  1004 00001B40 C5367800            <1> 	lds	si,[1Eh*4]		; DS:SI -> INT 1Eh
  1005 00001B44 8A4409              <1> 	mov	al,byte [si+9]		; AL = head settle time in ms
  1006 00001B47 1F                  <1> 	pop	ds
  1007                              <1> 
  1008 00001B48 08C0                <1> 	or	al,al			; head settle time is zero?!
  1009 00001B4A 7413                <1> 	jz	.get_settle_time
  1010                              <1> 
  1011 00001B4C B143                <1> 	mov	cl,67			; 15 us * 67 ~= 1 ms
  1012 00001B4E F6E1                <1> 	mul	cl			; AX = delay in 15 us intervals
  1013 00001B50 89C1                <1> 	mov	cx,ax
  1014                              <1> 
  1015                              <1> .wait:
  1016 00001B52 E81BFB              <1> 	call	delay_15us
  1017                              <1> 
  1018                              <1> .wait_end:
  1019 00001B55 30E4                <1> 	xor	ah,ah			; AH = 0, CF = 0 - no error
  1020                              <1> 
  1021                              <1> .set_result:
  1022 00001B57 88264100            <1> 	mov	byte [fdc_last_error],ah
  1023                              <1> 
  1024                              <1> .exit:
  1025 00001B5B 5A                  <1> 	pop	dx
  1026 00001B5C 59                  <1> 	pop	cx
  1027 00001B5D 5B                  <1> 	pop	bx
  1028 00001B5E C3                  <1> 	ret
  1029                              <1> 
  1030                              <1> .get_settle_time:
  1031 00001B5F F6063F0080          <1> 	test	byte [fdc_motor_state],fdc_write_flag ; test the write bit
  1032 00001B64 74EF                <1> 	jz	.wait_end		; jump if read / verify - no wait
  1033                              <1> 
  1034 00001B66 E8C003              <1> 	call	get_media_state	
  1035 00001B69 88DC                <1> 	mov	ah,bl			; AH = media state
  1036 00001B6B 80E407              <1> 	and	ah,fdc_m_state_bits	; leave only drive media state bits
  1037 00001B6E B92D05              <1> 	mov	cx,1325			; 20 ms delay for 360K drives
  1038 00001B71 74DF                <1> 	jz	.wait			; jump if 360K, media not established
  1039 00001B73 80FC03              <1> 	cmp	ah,fdc_m_360in360 & fdc_m_state_bits
  1040 00001B76 74DA                <1> 	je	.wait			; jump if 360K, media established
  1041 00001B78 B9E303              <1> 	mov	cx,995			; 15 ms delay for other drives
  1042 00001B7B EBD5                <1> 	jmp	.wait
  1043                              <1> 
  1044                              <1> ;=========================================================================
  1045                              <1> ; fdc_motor_on - Turn motor on (if it is not on yet)
  1046                              <1> ; Input:
  1047                              <1> ;	DL = drive number (0 or 1) -- FIXME: Does it receive DL?
  1048                              <1> ; Output:
  1049                              <1> ;	none
  1050                              <1> ;-------------------------------------------------------------------------
  1051                              <1> fdc_motor_on:
  1052 00001B7D 50                  <1> 	push	ax
  1053 00001B7E 51                  <1> 	push	cx
  1054 00001B7F 52                  <1> 	push	dx
  1055 00001B80 FA                  <1> 	cli				; entering critical section
  1056 00001B81 C6064000FF          <1> 	mov	byte [fdc_motor_tout],0FFh  ; set timeout to maximum
  1057 00001B86 8A5608              <1> 	mov	dl,byte [bp+int_13_dl]	; DL = drive number
  1058 00001B89 88D1                <1> 	mov	cl,dl			; CL = drive number
  1059 00001B8B FEC1                <1> 	inc	cl			; CL = drive number + 1
  1060 00001B8D A03F00              <1> 	mov	al,byte [fdc_motor_state] ; AL = motor state byte
  1061 00001B90 88C6                <1> 	mov	dh,al			; keep a copy in motor state in DH
  1062 00001B92 24CF                <1> 	and	al,0CFh			; clear drive select bits (5-4)
  1063                              <1> 
  1064 00001B94 D0E2                <1> 	shl	dl,1			; shift drive number to bits (5-4)
  1065 00001B96 D0E2                <1> 	shl	dl,1
  1066 00001B98 D0E2                <1> 	shl	dl,1
  1067 00001B9A D0E2                <1> 	shl	dl,1
  1068 00001B9C 08D0                <1> 	or	al,dl			; select drive
  1069 00001B9E D2EE                <1> 	shr	dh,cl			; set CF if motor for is on
  1070 00001BA0 724A                <1> 	jc	.already_on
  1071 00001BA2 B201                <1> 	mov	dl,1
  1072 00001BA4 FEC9                <1> 	dec	cl
  1073 00001BA6 D2E2                <1> 	shl	dl,cl
  1074 00001BA8 08D0                <1> 	or	al,dl			; indicate that motor is on
  1075 00001BAA A23F00              <1> 	mov	byte [fdc_motor_state],al ; update motor state in data area
  1076 00001BAD FB                  <1> 	sti
  1077 00001BAE 0C40                <1> 	or	al,40h			; no reset
  1078 00001BB0 E86703              <1> 	call	set_fdc_dor
  1079 00001BB3 B8FD90              <1> 	mov	ax,90FDh
  1080 00001BB6 CD15                <1> 	int	15h			; call OS hook
  1081 00001BB8 722E                <1> 	jc	.exit
  1082 00001BBA 1E                  <1> 	push	ds
  1083 00001BBB 56                  <1> 	push	si
  1084 00001BBC 31F6                <1> 	xor	si,si
  1085 00001BBE 8EDE                <1> 	mov	ds,si
  1086 00001BC0 C5367800            <1> 	lds	si,[1Eh*4]		; DS:SI -> INT 1Eh
  1087 00001BC4 8A440A              <1> 	mov	al,byte [si+0Ah]	; AL = motor start time in 1/8 second
  1088 00001BC7 5E                  <1> 	pop	si
  1089 00001BC8 1F                  <1> 	pop	ds
  1090                              <1> 
  1091 00001BC9 F6063F0080          <1> 	test	byte [fdc_motor_state],fdc_write_flag ; test the write bit
  1092 00001BCE 7408                <1> 	jz	.read_verify		; jump if not write operation
  1093 00001BD0 3C08                <1> 	cmp	al,8
  1094 00001BD2 730A                <1> 	jae	.wait_loop		; jump if at least 1 second start time
  1095 00001BD4 B008                <1> 	mov	al,8			; wait at least 1 second for write
  1096 00001BD6 EB06                <1> 	jmp	.wait_loop
  1097                              <1> 
  1098                              <1> .read_verify:
  1099 00001BD8 3C05                <1> 	cmp	al,5
  1100 00001BDA 7302                <1> 	jae	.wait_loop		; jump if at least 625 ms start time
  1101 00001BDC B005                <1> 	mov	al,5			; wait at least 625 ms for read / verify
  1102                              <1> 
  1103                              <1> .wait_loop:
  1104 00001BDE B95F20              <1> 	mov	cx,8287			; 8287 * 15.09us ~= 125ms
  1105 00001BE1 E88CFA              <1> 	call	delay_15us		; wait 125 ms
  1106 00001BE4 FEC8                <1> 	dec	al
  1107 00001BE6 75F6                <1> 	jnz	.wait_loop		; repeat until AL = 0
  1108                              <1> 
  1109                              <1> .exit:
  1110 00001BE8 5A                  <1> 	pop	dx
  1111 00001BE9 59                  <1> 	pop	cx
  1112 00001BEA 58                  <1> 	pop	ax
  1113 00001BEB C3                  <1> 	ret
  1114                              <1> 
  1115                              <1> .already_on:
  1116 00001BEC A23F00              <1> 	mov	byte [fdc_motor_state],al ; update motor state (AL) in data area
  1117 00001BEF FB                  <1> 	sti
  1118 00001BF0 0C40                <1> 	or	al,40h			; no reset
  1119 00001BF2 E82503              <1> 	call	set_fdc_dor
  1120 00001BF5 EBF1                <1> 	jmp	.exit
  1121                              <1> 
  1122                              <1> ;=========================================================================
  1123                              <1> ; fdc_end_io - Set motor timeout, return next sector to be transferred
  1124                              <1> ; Input:
  1125                              <1> ;	CH = cylinder
  1126                              <1> ;	DH = head
  1127                              <1> ; Output:
  1128                              <1> ;	BL = next sector to be transferred
  1129                              <1> ;-------------------------------------------------------------------------	
  1130                              <1> fdc_end_io:
  1131 00001BF7 50                  <1> 	push	ax
  1132 00001BF8 1E                  <1> 	push	ds
  1133 00001BF9 31DB                <1> 	xor	bx,bx
  1134 00001BFB 8EDB                <1> 	mov	ds,bx
  1135 00001BFD C51E7800            <1> 	lds	bx,[1Eh*4]		; DS:BX -> INT 1Eh
  1136 00001C01 8A6702              <1> 	mov	ah,byte [bx+2]		; motor timeout (ticks)
  1137 00001C04 8A4704              <1> 	mov	al,byte [bx+4]		; sectors per track
  1138 00001C07 FEC0                <1> 	inc	al
  1139 00001C09 1F                  <1> 	pop	ds
  1140 00001C0A BB4200              <1> 	mov	bx,fdc_ctrl_status
  1141 00001C0D 3A6F03              <1> 	cmp	ch,byte [bx+3]		; same result cylinder?
  1142 00001C10 7508                <1> 	jne	.exit
  1143 00001C12 3A7704              <1> 	cmp	dh,byte [bx+4]		; same result head?
  1144 00001C15 7503                <1> 	jne	.exit
  1145 00001C17 8A4705              <1> 	mov	al,byte [bx+5]		; result sector number
  1146                              <1> .exit:
  1147 00001C1A 88264000            <1> 	mov	byte [fdc_motor_tout],ah  ; motor timeout
  1148 00001C1E 88C3                <1> 	mov	bl,al			; next sector to be transferred
  1149 00001C20 58                  <1> 	pop	ax
  1150 00001C21 C3                  <1> 	ret
  1151                              <1> 
  1152                              <1> ;========================================================================
  1153                              <1> ; fdc_disk_change - Read disk change line, reset it if active
  1154                              <1> ; Input:
  1155                              <1> ;	AL = drive type
  1156                              <1> ; Output:
  1157                              <1> ;	CF clear if disk not changed
  1158                              <1> ;		AH = 00h - disk not changed
  1159                              <1> ;	CF set if disk changed or on error
  1160                              <1> ;		AH = 06h - disk changed
  1161                              <1> ;		AH = error code
  1162                              <1> ;		AL - trashed
  1163                              <1> ; Note:
  1164                              <1> ;	Motor needs to be turned on before calling this function
  1165                              <1> ;------------------------------------------------------------------------
  1166                              <1> fdc_disk_change:
  1167 00001C22 53                  <1> 	push	bx
  1168 00001C23 51                  <1> 	push	cx
  1169 00001C24 B400                <1> 	mov	ah,0
  1170 00001C26 3C01                <1> 	cmp	al,type_360
  1171 00001C28 7443                <1> 	je	.exit			; jump if 360K drive (no change line)
  1172 00001C2A 3C03                <1> 	cmp	al,type_720
  1173 00001C2C 743F                <1> 	je	.exit			; jump if 720K drive (no change line)
  1174                              <1> 
  1175 00001C2E E8F802              <1> 	call	get_media_state
  1176 00001C31 88D8                <1> 	mov	al,bl			; AL = drive media state
  1177 00001C33 2407                <1> 	and	al,fdc_m_state_bits
  1178 00001C35 7436                <1> 	jz	.exit			; jump if 360K drive (no change line)
  1179 00001C37 3C03                <1> 	cmp	al,3
  1180 00001C39 7432                <1> 	je	.exit			; jump if 360K drive (no change line)
  1181 00001C3B BAF703              <1> 	mov	dx,fdc_dir_reg		; get digital input register address
  1182 00001C3E EC                  <1> 	in	al,dx			; read disk change line
  1183 00001C3F D0E0                <1> 	shl	al,1
  1184 00001C41 732A                <1> 	jnc	.exit			; no disk change
  1185 00001C43 88D8                <1> 	mov	al,bl			; AL = drive media state
  1186 00001C45 24EF                <1> 	and	al,~fdc_m_established	; media not detected
  1187 00001C47 E8E902              <1> 	call	set_media_state
  1188 00001C4A E8D7FB              <1> 	call	fdc_init		; full initialization
  1189 00001C4D 721E                <1> 	jc	.exit
  1190 00001C4F 8B5608              <1> 	mov	dx,word [bp+int_13_dx]	; restore DX
  1191 00001C52 B501                <1> 	mov	ch,1
  1192 00001C54 E877FE              <1> 	call	fdc_seek		; seek to cylinder 1
  1193 00001C57 7214                <1> 	jc	.exit
  1194 00001C59 B500                <1> 	mov	ch,0
  1195 00001C5B E870FE              <1> 	call	fdc_seek		; seek to cylinder 0
  1196 00001C5E 720D                <1> 	jc	.exit
  1197 00001C60 B406                <1> 	mov	ah,fdc_e_changed
  1198 00001C62 BAF703              <1> 	mov	dx,fdc_dir_reg		; get digital input register address
  1199 00001C65 EC                  <1> 	in	al,dx			; read disk change line
  1200 00001C66 D0E0                <1> 	shl	al,1
  1201 00001C68 7302                <1> 	jnc	.changed_or_error	; jump if disk change line was reset
  1202 00001C6A B480                <1> 	mov	ah,fdc_e_timeout	; failed: no floppy
  1203                              <1> 
  1204                              <1> .changed_or_error:
  1205 00001C6C F9                  <1> 	stc
  1206                              <1> 
  1207                              <1> .exit:
  1208 00001C6D 8B5608              <1> 	mov	dx,word [bp+int_13_dx]	; restore dx
  1209 00001C70 59                  <1> 	pop	cx
  1210 00001C71 5B                  <1> 	pop	bx
  1211 00001C72 C3                  <1> 	ret
  1212                              <1> 
  1213                              <1> ;=========================================================================
  1214                              <1> ; fdc_configure_dma - Configure DMA controller for FDC operation (channel 2)
  1215                              <1> ; Input:
  1216                              <1> ;	AL = DMA mode byte
  1217                              <1> ;		42h - verify (single mode, addr increment, verify, channel 2)
  1218                              <1> ;		46h - read   (single mode, addr increment, write, channel 2)
  1219                              <1> ;		4Ah - write  (single mode, addr increment, read, channel 2)
  1220                              <1> ;	CX = byte count (minus 1)
  1221                              <1> ;	ES:BX -> buffer address for DMA operation (BX is from [BP+int_13_bx])
  1222                              <1> ; Output:
  1223                              <1> ;	CF clear on success
  1224                              <1> ;	CF set if error
  1225                              <1> ;		AH = 08h - DMA overrun
  1226                              <1> ;	AX,BX trashed
  1227                              <1> ; Note:
  1228                              <1> ;	Translates ES:BX to DMA page and base address and configures DMAC
  1229                              <1> ;-------------------------------------------------------------------------
  1230                              <1> fdc_configure_dma:
  1231 00001C73 52                  <1> 	push	dx
  1232 00001C74 8B5E0C              <1> 	mov	bx,word [bp+int_13_bx]	; get BX from the stack
  1233 00001C77 8CC2                <1> 	mov	dx,es			; user's buffer segment
  1234 00001C79 D1C2                <1> 	rol	dx,1
  1235 00001C7B D1C2                <1> 	rol	dx,1
  1236 00001C7D D1C2                <1> 	rol	dx,1
  1237 00001C7F D1C2                <1> 	rol	dx,1
  1238 00001C81 88D4                <1> 	mov	ah,dl			; calculate DMA page number
  1239 00001C83 80E40F              <1> 	and	ah,0Fh			; AH = page number: bits 19 - 16 of ES
  1240 00001C86 80E2F0              <1> 	and	dl,0F0h			; DX = DMA offset: bits 15 - 0 of ES
  1241 00001C89 01DA                <1> 	add	dx,bx			; add user's buffer offset
  1242 00001C8B 80D400              <1> 	adc	ah,0			; increment page number on overflow
  1243                              <1> 
  1244 00001C8E 89D3                <1> 	mov	bx,dx			; check if crossing DMA page boundary:
  1245 00001C90 01CB                <1> 	add	bx,cx			;   add DMA buffer address to byte count
  1246 00001C92 7243                <1> 	jc	.dma_boundary		; jump if crossing DMA boundary (64 KiB)
  1247                              <1> 
  1248 00001C94 FA                  <1> 	cli
  1249 00001C95 E60B                <1> 	out	dmac_mode_reg,al	; send DMA mode byte
  1250 00001C97 EB00                <1> 	jmp	$+2
  1251 00001C99 EB00                <1> 	jmp	$+2
  1252 00001C9B E60C                <1> 	out	dmac_ff_reg,al		; clear first/last flip-flop
  1253 00001C9D EB00                <1> 	jmp	$+2
  1254 00001C9F EB00                <1> 	jmp	$+2
  1255 00001CA1 88C8                <1> 	mov	al,cl
  1256 00001CA3 E605                <1> 	out	dmac_ch2_count_reg,al	; send word count - low byte
  1257 00001CA5 EB00                <1> 	jmp	$+2
  1258 00001CA7 EB00                <1> 	jmp	$+2
  1259 00001CA9 88E8                <1> 	mov	al,ch
  1260 00001CAB E605                <1> 	out	dmac_ch2_count_reg,al	; send word count - high byte
  1261 00001CAD EB00                <1> 	jmp	$+2
  1262 00001CAF EB00                <1> 	jmp	$+2
  1263 00001CB1 E60C                <1> 	out	dmac_ff_reg,al		; clear first/last flip-flop
  1264 00001CB3 EB00                <1> 	jmp	$+2
  1265 00001CB5 EB00                <1> 	jmp	$+2
  1266 00001CB7 88D0                <1> 	mov	al,dl
  1267 00001CB9 E604                <1> 	out	dmac_ch2_addr_reg,al	; send base address - low byte
  1268 00001CBB EB00                <1> 	jmp	$+2
  1269 00001CBD EB00                <1> 	jmp	$+2
  1270 00001CBF 88F0                <1> 	mov	al,dh
  1271 00001CC1 E604                <1> 	out	dmac_ch2_addr_reg,al	; send base address - high byte
  1272 00001CC3 EB00                <1> 	jmp	$+2
  1273 00001CC5 EB00                <1> 	jmp	$+2
  1274 00001CC7 88E0                <1> 	mov	al,ah
  1275 00001CC9 E681                <1> 	out	dmapage_ch2_reg,al	; channel 2 page register
  1276 00001CCB EB00                <1> 	jmp	$+2
  1277 00001CCD EB00                <1> 	jmp	$+2
  1278 00001CCF B002                <1> 	mov	al,2
  1279 00001CD1 E60A                <1> 	out	dmac_mask_reg,al	; enable DMA channel 2
  1280 00001CD3 FB                  <1> 	sti
  1281 00001CD4 F8                  <1> 	clc				; CF = 0 - no error
  1282                              <1> 
  1283                              <1> .exit:
  1284 00001CD5 5A                  <1> 	pop	dx
  1285 00001CD6 C3                  <1> 	ret
  1286                              <1> 
  1287                              <1> .dma_boundary:				; Note: CF is already set
  1288 00001CD7 B409                <1> 	mov	ah,fdc_e_boundary
  1289 00001CD9 EBFA                <1> 	jmp	.exit
  1290                              <1> 
  1291                              <1> ;=========================================================================
  1292                              <1> ; fdc_send_cmd - Send a command to FDC
  1293                              <1> ; Input:
  1294                              <1> ;	AL = 1st byte of the command
  1295                              <1> ;	AH = 2nd byte of the command
  1296                              <1> ;	SI = 3rd and 4th bytes of the command
  1297                              <1> ;	DI = 5th and 6th bytes of the command
  1298                              <1> ;	BL = 7th byte of the command
  1299                              <1> ;	BH = 8th byte of the command
  1300                              <1> ;	CH = 9th byte of the command
  1301                              <1> ;	CL = command length (number of bytes)
  1302                              <1> ; Output:
  1303                              <1> ;	CF clear if successful
  1304                              <1> ;		AH = 00h - successful completion
  1305                              <1> ;	CF set on error
  1306                              <1> ;		AH = 20h - controller failure
  1307                              <1> ;		AH = 80h - timeout / device not ready
  1308                              <1> ;	AX trashed
  1309                              <1> ;-------------------------------------------------------------------------
  1310                              <1> fdc_send_cmd:
  1311 00001CDB E84900              <1> 	call	fdc_write		; send AL (1st byte)
  1312 00001CDE FEC9                <1> 	dec	cl
  1313 00001CE0 7644                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  1314 00001CE2 88E0                <1> 	mov	al,ah
  1315 00001CE4 E84000              <1> 	call	fdc_write		; send AH (2nd byte)
  1316 00001CE7 FEC9                <1> 	dec	cl
  1317 00001CE9 763B                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  1318 00001CEB 89F0                <1> 	mov	ax,si
  1319 00001CED E83700              <1> 	call	fdc_write		; send SI / low byte (3th byte)
  1320 00001CF0 FEC9                <1> 	dec	cl
  1321 00001CF2 7632                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  1322 00001CF4 88E0                <1> 	mov	al,ah
  1323 00001CF6 E82E00              <1> 	call	fdc_write		; send SI / high byte (4th byte)
  1324 00001CF9 FEC9                <1> 	dec	cl
  1325 00001CFB 7629                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  1326 00001CFD 89F8                <1> 	mov	ax,di
  1327 00001CFF E82500              <1> 	call	fdc_write		; send DI / low byte (5th byte)
  1328 00001D02 FEC9                <1> 	dec	cl
  1329 00001D04 7620                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  1330 00001D06 88E0                <1> 	mov	al,ah
  1331 00001D08 E81C00              <1> 	call	fdc_write		; send DI / high byte (6th byte)
  1332 00001D0B FEC9                <1> 	dec	cl
  1333 00001D0D 7617                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  1334 00001D0F 88D8                <1> 	mov	al,bl
  1335 00001D11 E81300              <1> 	call	fdc_write		; send BL (7rd byte)
  1336 00001D14 FEC9                <1> 	dec	cl
  1337 00001D16 760E                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  1338 00001D18 88F8                <1> 	mov	al,bh
  1339 00001D1A E80A00              <1> 	call	fdc_write		; send BH (8th byte)
  1340 00001D1D FEC9                <1> 	dec	cl
  1341 00001D1F 7605                <1> 	jbe	.send_cmd_exit		; jump if done (ZF=1) or on error (CF=1)
  1342 00001D21 88E8                <1> 	mov	al,ch
  1343 00001D23 E80100              <1> 	call	fdc_write		; send CH (9th byte)
  1344                              <1> 
  1345                              <1> .send_cmd_exit:
  1346 00001D26 C3                  <1> 	ret
  1347                              <1> 
  1348                              <1> ;=========================================================================
  1349                              <1> ; fdc_write - Send byte to FDC
  1350                              <1> ; Input:
  1351                              <1> ;	AL = byte to send
  1352                              <1> ; Output:
  1353                              <1> ;	CF clear if successful
  1354                              <1> ;	CF set if timeout
  1355                              <1> ;		AH = 80h - timeout / device not ready
  1356                              <1> ;-------------------------------------------------------------------------
  1357                              <1> fdc_write:
  1358 00001D27 51                  <1> 	push	cx
  1359 00001D28 52                  <1> 	push	dx
  1360 00001D29 50                  <1> 	push	ax
  1361 00001D2A BAF403              <1> 	mov	dx,fdc_status_reg	; get status register address
  1362 00001D2D 31C9                <1> 	xor	cx,cx			; busy wait counter
  1363                              <1> 
  1364                              <1> .wait_ready:
  1365 00001D2F EC                  <1> 	in	al,dx			; read fdc_status_reg
  1366 00001D30 A880                <1> 	test	al,fdc_stat_ready	; exit loop if FDC is ready
  1367 00001D32 7508                <1> 	jnz	.fdc_ready
  1368 00001D34 E2F9                <1> 	loop	.wait_ready
  1369 00001D36 58                  <1> 	pop	ax
  1370 00001D37 B480                <1> 	mov	ah,fdc_e_timeout	; timeout
  1371 00001D39 F9                  <1> 	stc				; indicate error
  1372 00001D3A EB08                <1> 	jmp	.exit
  1373                              <1> 
  1374                              <1> .fdc_ready:
  1375 00001D3C A860                <1> 	test	al,fdc_stat_dir|fdc_stat_dma ; check that DIR and DMA flags are 0
  1376 00001D3E 7507                <1> 	jnz	.failure		; FDC failure if they are set
  1377 00001D40 58                  <1> 	pop	ax
  1378 00001D41 42                  <1> 	inc	dx			; DX = fdc_data_reg = fdc_status_reg + 1
  1379 00001D42 EE                  <1> 	out	dx,al			; write byte
  1380 00001D43 F8                  <1> 	clc				; no error
  1381                              <1> 
  1382                              <1> .exit:
  1383 00001D44 5A                  <1> 	pop	dx
  1384 00001D45 59                  <1> 	pop	cx
  1385 00001D46 C3                  <1> 	ret
  1386                              <1> 
  1387                              <1> .failure:
  1388 00001D47 58                  <1> 	pop	ax
  1389 00001D48 B420                <1> 	mov	ah,fdc_e_failure	; FDC failure
  1390 00001D4A F9                  <1> 	stc
  1391 00001D4B EBF7                <1> 	jmp	.exit
  1392                              <1> 
  1393                              <1> ;=========================================================================
  1394                              <1> ; fdc_get_result - Read FDC result
  1395                              <1> ; Input:
  1396                              <1> ;	none
  1397                              <1> ; Output:
  1398                              <1> ;	CF clear if successful
  1399                              <1> ;		AH = 00h - operation successful
  1400                              <1> ;		Result is returned in fdc_ctrl_status BIOS area
  1401                              <1> ;	CF set on error
  1402                              <1> ;		AH = 20h - controller failure
  1403                              <1> ;		AH = 80h - timeout / device not ready
  1404                              <1> ;	AL,BX - trashed
  1405                              <1> ;-------------------------------------------------------------------------
  1406                              <1> fdc_get_result:
  1407 00001D4D 51                  <1> 	push	cx
  1408 00001D4E 52                  <1> 	push	dx
  1409 00001D4F BB4200              <1> 	mov	bx,fdc_ctrl_status
  1410 00001D52 BAF403              <1> 	mov	dx,fdc_status_reg	; get status register address
  1411                              <1> 
  1412                              <1> .next_byte:
  1413 00001D55 31C9                <1>         xor     cx,cx			; busy wait counter
  1414                              <1> 
  1415                              <1> .wait_ready:
  1416 00001D57 EC                  <1> 	in	al,dx			; read fdc_status_reg
  1417 00001D58 A880                <1> 	test	al,fdc_stat_ready	; exit loop if FDC is ready
  1418 00001D5A 7507                <1> 	jnz	.fdc_ready
  1419 00001D5C E2F9                <1> 	loop	.wait_ready
  1420 00001D5E B480                <1> 	mov	ah,fdc_e_timeout	; timeout
  1421 00001D60 F9                  <1> 	stc				; indicate error
  1422 00001D61 EB19                <1> 	jmp	.exit
  1423                              <1> 
  1424                              <1> .fdc_ready:
  1425 00001D63 2470                <1> 	and	al,fdc_stat_dir|fdc_stat_dma|fdc_stat_busy
  1426 00001D65 A8EF                <1> 	test	al,~fdc_stat_busy	; controller finished sending result?
  1427 00001D67 7411                <1> 	je	.done
  1428 00001D69 3C50                <1> 	cmp	al,fdc_stat_dir|fdc_stat_busy
  1429 00001D6B 7512                <1> 	jne	.failure		; invalid FDC status, indicate FDC failure
  1430 00001D6D 83FB49              <1> 	cmp	bx,fdc_ctrl_status+7	; already read 7 bytes?
  1431 00001D70 730D                <1> 	jnb	.failure		; controller error if so
  1432 00001D72 42                  <1> 	inc	dx			; DX = fdc_data_reg = fdc_status_reg + 1
  1433 00001D73 EC                  <1> 	in	al,dx
  1434 00001D74 8807                <1> 	mov	byte [bx],al
  1435 00001D76 43                  <1> 	inc	bx
  1436 00001D77 4A                  <1> 	dec	dx			; DX = fdc_status_reg = fdc_data_reg - 1
  1437 00001D78 EBDB                <1> 	jmp	.next_byte
  1438                              <1> 
  1439                              <1> .done:
  1440 00001D7A 30E4                <1> 	xor	ah,ah			; operation successful
  1441                              <1> 
  1442                              <1> .exit:
  1443 00001D7C 5A                  <1> 	pop	dx
  1444 00001D7D 59                  <1> 	pop	cx
  1445 00001D7E C3                  <1> 	ret
  1446                              <1> 
  1447                              <1> .failure:
  1448 00001D7F B420                <1> 	mov	ah,fdc_e_failure
  1449 00001D81 F9                  <1> 	stc
  1450 00001D82 EBF8                <1> 	jmp	.exit
  1451                              <1> 
  1452                              <1> ;=========================================================================
  1453                              <1> ; fdc_read - Read byte from FDC
  1454                              <1> ; Input:
  1455                              <1> ;	none
  1456                              <1> ; Output:
  1457                              <1> ;	CF clear if successful
  1458                              <1> ;		AL = byte read from FDC
  1459                              <1> ;		AH - unchanged
  1460                              <1> ;	CF set on error
  1461                              <1> ;		AH = 20h - controller failure
  1462                              <1> ;		AH = 80h - timeout / device not ready
  1463                              <1> ;-------------------------------------------------------------------------
  1464                              <1> fdc_read:
  1465 00001D84 51                  <1> 	push	cx
  1466 00001D85 52                  <1> 	push	dx
  1467 00001D86 BAF403              <1> 	mov	dx,fdc_status_reg	; get status register address
  1468 00001D89 31C9                <1>         xor     cx,cx			; busy wait counter
  1469                              <1> 
  1470                              <1> .wait_ready:
  1471 00001D8B EC                  <1> 	in	al,dx			; read fdc_status_reg
  1472 00001D8C A880                <1> 	test	al,fdc_stat_ready	; exit loop if FDC is ready
  1473 00001D8E 7507                <1> 	jnz	.fdc_ready
  1474 00001D90 E2F9                <1> 	loop	.wait_ready
  1475 00001D92 B480                <1> 	mov	ah,fdc_e_timeout	; timeout
  1476 00001D94 F9                  <1> 	stc				; indicate error
  1477 00001D95 EB08                <1> 	jmp	.exit
  1478                              <1> 
  1479                              <1> .fdc_ready:
  1480 00001D97 EC                  <1> 	in	al,dx
  1481 00001D98 A840                <1> 	test	al,fdc_stat_dir		; FDC is ready to send a byte? 
  1482 00001D9A 7406                <1> 	jz	.failure		; jump if not ready
  1483                              <1> ;	jmp	short $+2		; I/O delay
  1484                              <1> ;	jmp	short $+2
  1485 00001D9C 42                  <1> 	inc	dx			; DX = fdc_data_reg = fdc_status_reg + 1
  1486 00001D9D EC                  <1> 	in	al,dx			; read the byte
  1487 00001D9E F8                  <1> 	clc				; no error
  1488                              <1> 
  1489                              <1> .exit:
  1490 00001D9F 5A                  <1> 	pop	dx
  1491 00001DA0 59                  <1> 	pop	cx
  1492 00001DA1 C3                  <1> 	ret
  1493                              <1> 
  1494                              <1> .failure:
  1495 00001DA2 B420                <1> 	mov	ah,fdc_e_failure
  1496 00001DA4 F9                  <1> 	stc
  1497 00001DA5 EBF8                <1> 	jmp	.exit
  1498                              <1> 
  1499                              <1> ;=========================================================================
  1500                              <1> ; fdc_get_error - Translate FDC status to BIOS error number
  1501                              <1> ; Input:
  1502                              <1> ;	DS:[fdc_ctrl_status] - FDC status bytes
  1503                              <1> ; Output:
  1504                              <1> ;	AH = error code
  1505                              <1> ;-------------------------------------------------------------------------
  1506                              <1> fdc_get_error:
  1507 00001DA7 8B1E4200            <1> 	mov	bx,word [fdc_ctrl_status]
  1508 00001DAB F6C3C0              <1> 	test	bl,0C0h			; BL = ST1
  1509 00001DAE B400                <1> 	mov	ah,fdc_e_success
  1510 00001DB0 7433                <1> 	jz	.exit			; jump if successful completion
  1511 00001DB2 F6C340              <1> 	test	bl,40h			; abnormal termination?
  1512 00001DB5 B420                <1> 	mov	ah,fdc_e_failure
  1513 00001DB7 742C                <1> 	jz	.exit
  1514 00001DB9 F6C701              <1> 	test	bh,1			; address mark not found?
  1515 00001DBC B402                <1> 	mov	ah,fdc_e_address
  1516 00001DBE 7525                <1> 	jnz	.exit
  1517 00001DC0 F6C702              <1> 	test	bh,2			; disk write protected?
  1518 00001DC3 B403                <1> 	mov	ah,fdc_e_wprotect
  1519 00001DC5 751E                <1> 	jnz	.exit
  1520 00001DC7 F6C704              <1> 	test	bh,4			; sector not found?
  1521 00001DCA B404                <1> 	mov	ah,fdc_e_notfound
  1522 00001DCC 7517                <1> 	jnz	.exit
  1523 00001DCE F6C710              <1> 	test	bh,10H			; DMA overrun?
  1524 00001DD1 B408                <1> 	mov	ah,fdc_e_dma
  1525 00001DD3 7510                <1> 	jnz	.exit
  1526 00001DD5 F6C720              <1> 	test	bh,20H			; CRC error?
  1527 00001DD8 B410                <1> 	mov	ah,fdc_e_crc
  1528 00001DDA 7509                <1> 	jnz	.exit
  1529 00001DDC F6C780              <1> 	test	bh,80h			; access after last sector?
  1530 00001DDF B404                <1> 	mov	ah,fdc_e_notfound
  1531 00001DE1 7502                <1> 	jnz	.exit
  1532 00001DE3 B420                <1> 	mov	ah,fdc_e_failure	; return FDC failure for other errors
  1533                              <1> 
  1534                              <1> .exit:
  1535 00001DE5 C3                  <1> 	ret
  1536                              <1> 
  1537                              <1> ;=========================================================================
  1538                              <1> ; fdc_reset - Reset FDC
  1539                              <1> ; Input:
  1540                              <1> ;	none
  1541                              <1> ; Output:
  1542                              <1> ;	Resets FDC flags in BIOS area
  1543                              <1> ;	AX,CX,DX - trashed 
  1544                              <1> ;-------------------------------------------------------------------------
  1545                              <1> fdc_reset:
  1546 00001DE6 FA                  <1> 	cli
  1547 00001DE7 80263E007F          <1> 	and	byte [fdc_calib_state],~fdc_irq_flag ; clear IRQ flag
  1548 00001DEC 80263F007F          <1> 	and	byte [fdc_motor_state],~fdc_write_flag ; clear the write bit
  1549 00001DF1 A03F00              <1> 	mov	al,byte [fdc_motor_state] ; AL = motor state byte
  1550 00001DF4 24BF                <1> 	and	al,0BFh			; clear bit 6 - reset
  1551 00001DF6 50                  <1> 	push	ax			; set_fdc_dor trashes AX, save it
  1552 00001DF7 E82001              <1> 	call	set_fdc_dor
  1553 00001DFA 58                  <1> 	pop	ax
  1554 00001DFB B90300              <1> 	mov	cx,3
  1555 00001DFE E86FF8              <1> 	call	delay_15us		; 30-45 us delay
  1556 00001E01 0C40                <1> 	or	al,40h			; set bit 6 - no reset
  1557 00001E03 E81401              <1> 	call	set_fdc_dor
  1558 00001E06 FB                  <1> 	sti
  1559 00001E07 E8E800              <1> 	call	fdc_wait_irq		; wait for IRQ
  1560 00001E0A 7207                <1> 	jc	.exit
  1561 00001E0C 80263E007F          <1> 	and	byte [fdc_calib_state],~fdc_irq_flag ; clear IRQ flag
  1562 00001E11 30E4                <1> 	xor	ah,ah			; no errors
  1563                              <1> .exit:
  1564 00001E13 C3                  <1> 	ret
  1565                              <1> 
  1566                              <1> ;=========================================================================
  1567                              <1> ; fdc_detect_media - Detect media type, update it in fdc_media_state[drive]
  1568                              <1> ; Input:
  1569                              <1> ;	[BP+int_13_dl] = drive number
  1570                              <1> ; Output:
  1571                              <1> ;	CF clear if successful
  1572                              <1> ;		AH = 00h
  1573                              <1> ;	CF set on error
  1574                              <1> ;		AH = 20h - invalid drive type
  1575                              <1> ;-------------------------------------------------------------------------
  1576                              <1> fdc_detect_media:
  1577 00001E14 52                  <1> 	push	dx
  1578 00001E15 51                  <1> 	push	cx
  1579                              <1> 
  1580 00001E16 B420                <1> 	mov	ah,fdc_e_failure	; in case the get_drive_type fails
  1581 00001E18 8A5608              <1> 	mov	dl,byte [bp+int_13_dl]	; restore DL in case it was trashed
  1582 00001E1B E86B01              <1> 	call	get_drive_type		; get drive type to AL
  1583 00001E1E 726B                <1> 	jc	.exit			; drive doesn't exist or invalid type
  1584                              <1> 
  1585 00001E20 3C03                <1> 	cmp	al,type_720
  1586 00001E22 7410                <1> 	je	.set_720
  1587 00001E24 3C02                <1> 	cmp	al,type_1200
  1588 00001E26 7415                <1> 	je	.detect_1200
  1589 00001E28 3C04                <1> 	cmp	al,type_1440
  1590 00001E2A 7427                <1> 	je	.detect_1440
  1591 00001E2C 3C06                <1> 	cmp	al,type_2880
  1592 00001E2E 7439                <1> 	je	.detect_2880
  1593                              <1> 
  1594 00001E30 B093                <1> 	mov	al,fdc_m_360in360	; set 360K disk in 360K drive
  1595 00001E32 EB02                <1> 	jmp	.set_rate
  1596                              <1> 
  1597                              <1> .set_720:
  1598 00001E34 B097                <1> 	mov	al,fdc_m_720
  1599                              <1> 
  1600                              <1> .set_rate:
  1601 00001E36 50                  <1> 	push	ax
  1602 00001E37 E89F00              <1> 	call	fdc_set_rate		; transfer rate in AL
  1603 00001E3A 58                  <1> 	pop	ax
  1604 00001E3B EB49                <1> 	jmp	.exit_set_media
  1605                              <1> 
  1606                              <1> .detect_1200:
  1607 00001E3D B000                <1> 	mov	al,0			; try 500 Kbps
  1608 00001E3F E85000              <1> 	call	fdc_read_id
  1609 00001E42 B015                <1> 	mov	al,fdc_m_1200in1200
  1610 00001E44 7340                <1> 	jnc	.exit_set_media		; jump if successful
  1611 00001E46 B040                <1> 	mov	al,40h			; try 300 Kbps
  1612 00001E48 E84700              <1> 	call	fdc_read_id
  1613 00001E4B B074                <1> 	mov	al,fdc_m_360in1200
  1614 00001E4D 7337                <1> 	jnc	.exit_set_media		; jump if successful
  1615 00001E4F B002                <1> 	mov	al,fdc_m_try_1200in1200
  1616 00001E51 EB33                <1> 	jmp	.exit_set_media
  1617                              <1> 
  1618                              <1> .detect_1440:
  1619 00001E53 B000                <1> 	mov	al,0			; try 500 Kbps
  1620 00001E55 E83A00              <1> 	call	fdc_read_id
  1621 00001E58 B017                <1> 	mov	al,fdc_m_1440
  1622 00001E5A 732A                <1> 	jnc	.exit_set_media		; jump if successful
  1623 00001E5C B080                <1> 	mov	al,80h			; try 250 Kbps
  1624 00001E5E E83100              <1> 	call	fdc_read_id
  1625 00001E61 B097                <1> 	mov	al,fdc_m_720
  1626 00001E63 7321                <1> 	jnc	.exit_set_media		; jump if successful
  1627 00001E65 B007                <1> 	mov	al,fdc_m_try_1440
  1628 00001E67 EB1D                <1> 	jmp	.exit_set_media
  1629                              <1> 
  1630                              <1> .detect_2880:
  1631 00001E69 B0C0                <1> 	mov	al,0C0h			; try 1 Mbps
  1632 00001E6B E82400              <1> 	call	fdc_read_id
  1633 00001E6E B0D7                <1> 	mov	al,fdc_m_2880
  1634 00001E70 7314                <1> 	jnc	.exit_set_media		; jump if successful
  1635 00001E72 B000                <1> 	mov	al,0			; try 500 Kbps
  1636 00001E74 E81B00              <1> 	call	fdc_read_id
  1637 00001E77 B017                <1> 	mov	al,fdc_m_1440
  1638 00001E79 730B                <1> 	jnc	.exit_set_media		; jump if successful
  1639 00001E7B B080                <1> 	mov	al,80h			; try 250 Kbps
  1640 00001E7D E81200              <1> 	call	fdc_read_id
  1641 00001E80 B097                <1> 	mov	al,fdc_m_720
  1642 00001E82 7302                <1> 	jnc	.exit_set_media		; jump_if successful
  1643 00001E84 B0C7                <1> 	mov	al,fdc_m_try_2880
  1644                              <1> 
  1645                              <1> .exit_set_media:
  1646 00001E86 E8AA00              <1> 	call	set_media_state		; set media state
  1647 00001E89 30E4                <1> 	xor	ah,ah			; AH = 0, CF = 0 - no error
  1648                              <1> .exit:
  1649 00001E8B 88264100            <1> 	mov	byte [fdc_last_error],ah
  1650 00001E8F 59                  <1> 	pop	cx
  1651 00001E90 5A                  <1> 	pop	dx
  1652 00001E91 C3                  <1> 	ret
  1653                              <1> 
  1654                              <1> ;=========================================================================
  1655                              <1> ; fdc_read_id - Read ID
  1656                              <1> ; Input:
  1657                              <1> ;	[BP+int_13_dl] = drive number
  1658                              <1> ; Output:
  1659                              <1> ;	CF clear if successful
  1660                              <1> ;		AH = 0 - successful completion
  1661                              <1> ;		AL = ID (bits 7-6)
  1662                              <1> ;	CF set on error
  1663                              <1> ;		AH = error code
  1664                              <1> ;	AX,CX - trashed
  1665                              <1> ;-------------------------------------------------------------------------
  1666                              <1> fdc_read_id:
  1667 00001E92 53                  <1> 	push	bx
  1668 00001E93 C6064000FF          <1> 	mov	byte [fdc_motor_tout],0FFh ; set timeout to maximum
  1669 00001E98 E83E00              <1> 	call	fdc_set_rate		; transfer rate in AL
  1670 00001E9B 8A5608              <1> 	mov	dl,byte [bp+int_13_dl]
  1671 00001E9E E8DBFB              <1> 	call	fdc_recalibrate		; recalibrate
  1672 00001EA1 7305                <1> 	jnc	.do_read_id
  1673 00001EA3 E8D6FB              <1> 	call	fdc_recalibrate		; second attempt
  1674 00001EA6 722E                <1> 	jc	.error
  1675                              <1> 
  1676                              <1> .do_read_id:
  1677 00001EA8 B90300              <1> 	mov	cx,3			; 3 attempts
  1678                              <1> 
  1679                              <1> .read_id_loop:
  1680 00001EAB 51                  <1> 	push	cx
  1681 00001EAC B04A                <1> 	mov	al,4Ah			; FDC Read ID command
  1682                              <1> ; FIXME - does drive number in DL gets to here?
  1683                              <1> ;	mov	ah,dl			; read id - byte 1 (head = 0 / drive)
  1684 00001EAE 8A6608              <1> 	mov	ah,byte [bp+int_13_dl]	; read id - byte 1 (head = 0 / drive)
  1685 00001EB1 B102                <1> 	mov	cl,2			; 2 byte commands
  1686 00001EB3 80263E007F          <1> 	and	byte [fdc_calib_state],~fdc_irq_flag ; clear IRQ6 flag
  1687 00001EB8 E820FE              <1> 	call	fdc_send_cmd
  1688 00001EBB 7218                <1> 	jc	.error_cmd
  1689 00001EBD E83200              <1> 	call	fdc_wait_irq		; wait for IRQ6
  1690 00001EC0 7213                <1> 	jc	.error_cmd		; timeout waiting for interrupt
  1691 00001EC2 B107                <1> 	mov	cl,7
  1692 00001EC4 E886FE              <1> 	call	fdc_get_result		; read result bytes
  1693 00001EC7 720C                <1> 	jc	.error_cmd
  1694 00001EC9 E8DBFE              <1> 	call	fdc_get_error		; get error code
  1695 00001ECC 59                  <1> 	pop	cx
  1696 00001ECD 08E4                <1> 	or	ah,ah
  1697 00001ECF 7406                <1> 	jz	.exit			; if no errors
  1698 00001ED1 E2D8                <1> 	loop	.read_id_loop		; retry
  1699 00001ED3 EB01                <1> 	jmp	.error
  1700                              <1> 
  1701                              <1> .error_cmd:
  1702 00001ED5 59                  <1> 	pop	cx
  1703                              <1> 
  1704                              <1> .error:
  1705 00001ED6 F9                  <1> 	stc
  1706                              <1> 
  1707                              <1> .exit:
  1708 00001ED7 5B                  <1> 	pop	bx
  1709 00001ED8 C3                  <1> 	ret
  1710                              <1> 
  1711                              <1> ;=========================================================================
  1712                              <1> ; fdc_set_rate - Set transfer rate
  1713                              <1> ; Input:
  1714                              <1> ;	AL = transfer rate (bits 7 and 6)
  1715                              <1> ;		00h - 500 Kbps (1.2M and 1.44M disks)
  1716                              <1> ;		40h - 300 Kbps (360K disk in 1.2M drive)
  1717                              <1> ;		80h - 250 Kbps (360K disk in 360K drive, or 720K disk)
  1718                              <1> ;		0C0h - 1 Mbps (2.88M disks)
  1719                              <1> ; Output:
  1720                              <1> ;	none
  1721                              <1> ;-------------------------------------------------------------------------
  1722                              <1> fdc_set_rate:
  1723 00001ED9 50                  <1> 	push	ax
  1724 00001EDA 24C0                <1> 	and	al,fdc_m_rate_bits	; get the data rate bits only
  1725 00001EDC 80268B003F          <1> 	and	byte [fdc_last_rate],~fdc_m_rate_bits ; clear rate bits
  1726 00001EE1 08068B00            <1> 	or	byte [fdc_last_rate],al	; set new rate bits
  1727 00001EE5 D0C0                <1> 	rol	al,1
  1728 00001EE7 D0C0                <1> 	rol	al,1
  1729 00001EE9 BAF703              <1> 	mov	dx,fdc_ccr_reg		; get control configuration register address
  1730 00001EEC EE                  <1> 	out	dx,al
  1731 00001EED 8B5608              <1> 	mov	dx,word [bp+int_13_dx]	; restore DX
  1732 00001EF0 58                  <1> 	pop	ax
  1733 00001EF1 C3                  <1> 	ret
  1734                              <1> 
  1735                              <1> ;=========================================================================
  1736                              <1> ; fdc_wait_irq - Wait for FDC interrupt for 2 seconds
  1737                              <1> ; Input:
  1738                              <1> ;	none
  1739                              <1> ; Output:
  1740                              <1> ;	CF clear if interrupt had occurred
  1741                              <1> ;		AH = 00h - successful completion
  1742                              <1> ;	CF set if no interrupt
  1743                              <1> ;		AH = 80h - timeout
  1744                              <1> ;	BX = fdc_calib_state
  1745                              <1> ;	AL - trashed
  1746                              <1> ;-------------------------------------------------------------------------
  1747                              <1> fdc_wait_irq:
  1748 00001EF2 51                  <1> 	push	cx
  1749 00001EF3 FB                  <1> 	sti
  1750 00001EF4 F8                  <1> 	clc
  1751 00001EF5 B80190              <1> 	mov	ax,9001h
  1752 00001EF8 CD15                <1> 	int	15h			; call OS hook
  1753 00001EFA 7212                <1> 	jc	.timeout
  1754 00001EFC BB3E00              <1> 	mov	bx,fdc_calib_state	; contains IRQ flag
  1755 00001EFF 31C9                <1> 	xor	cx,cx
  1756                              <1> 
  1757                              <1> %ifdef AT_DELAY
  1758                              <1> 
  1759                              <1> .zero_loop:
  1760                              <1> 	test	byte [bx],fdc_irq_flag	; test IRQ flag
  1761                              <1> 	jnz	.exit			; exit loop if interrupt had occurred
  1762                              <1> 	in	al,ppi_pb_reg
  1763                              <1> 	test	al,refresh_flag
  1764                              <1> 	jz	.zero_loop		; wait 15.09 us
  1765                              <1> 	loop	.one_loop		; DEC CX; JNZ .one_loop
  1766                              <1> 	jmp	.timeout
  1767                              <1> 
  1768                              <1> .one_loop:
  1769                              <1> 	test	byte [bx],fdc_irq_flag	; test IRQ flag
  1770                              <1> 	jnz	.exit			; exit loop if interrupt had occurred
  1771                              <1> 	in	al,ppi_pb_reg
  1772                              <1> 	test	al,refresh_flag
  1773                              <1> 	jnz	.one_loop		; wait 15.09 us
  1774                              <1> 	loop	.zero_loop		; DEC CX; JNZ .zero_loop
  1775                              <1> 
  1776                              <1> %else ; AT_DELAY
  1777                              <1> 
  1778                              <1> .1:
  1779                              <1> 	; wait 38.13 us (Intel 8088 CPU running on 4.77 MHz)
  1780 00001F01 B00A                <1> 	mov	al,10
  1781                              <1> .2:
  1782 00001F03 F60780              <1> 	test	byte [bx],fdc_irq_flag	; test IRQ flag
  1783 00001F06 750B                <1> 	jnz	.exit			; exit loop if interrupt had occurred
  1784 00001F08 FEC8                <1> 	dec	al
  1785 00001F0A 75F7                <1> 	jnz	.2
  1786 00001F0C E2F3                <1> 	loop	.1
  1787                              <1> 
  1788                              <1> %endif ; AT_DELAY
  1789                              <1> 
  1790                              <1> .timeout:
  1791 00001F0E B480                <1> 	mov	ah,fdc_e_timeout	; timeout
  1792 00001F10 F9                  <1> 	stc
  1793 00001F11 59                  <1> 	pop	cx
  1794 00001F12 C3                  <1> 	ret
  1795                              <1> 
  1796                              <1> .exit:
  1797 00001F13 80277F              <1> 	and	byte [bx],~fdc_irq_flag	; clear IRQ flag
  1798 00001F16 30E4                <1> 	xor	ah,ah			; AH = 0, CF = 0 - no error
  1799 00001F18 59                  <1> 	pop	cx
  1800 00001F19 C3                  <1> 	ret
  1801                              <1> 
  1802                              <1> ;=========================================================================
  1803                              <1> ; set_fdc_dor - set FDC Digital Output Register - DOR
  1804                              <1> ; Input:
  1805                              <1> ;	AL = new motor state
  1806                              <1> ; Output:
  1807                              <1> ;	AL, DX trashed
  1808                              <1> ;-------------------------------------------------------------------------
  1809                              <1> set_fdc_dor:
  1810 00001F1A D0C8                <1> 	ror	al,1
  1811 00001F1C D0C8                <1> 	ror	al,1
  1812 00001F1E D0C8                <1> 	ror	al,1
  1813 00001F20 D0C8                <1> 	ror	al,1
  1814 00001F22 0C08                <1> 	or	al,08h			; DMA+IRQ enabled
  1815 00001F24 BAF203              <1> 	mov	dx,fdc_dor_reg		; get digital output register address
  1816 00001F27 EE                  <1> 	out	dx,al			; send the state to FDC
  1817 00001F28 C3                  <1> 	ret
  1818                              <1> 
  1819                              <1> ;=========================================================================
  1820                              <1> ; get_media_state - Get drive's media state from the data area
  1821                              <1> ; Input:
  1822                              <1> ;	[BP+int_13_dl] = drive number
  1823                              <1> ; Output:
  1824                              <1> ;	BL = drive's media state
  1825                              <1> ;	BH = 0 (destroyed)
  1826                              <1> ;-------------------------------------------------------------------------
  1827                              <1> get_media_state:
  1828 00001F29 8A5E08              <1> 	mov	bl,byte [bp+int_13_dl]
  1829 00001F2C B700                <1> 	mov	bh,0			; BX = drive number
  1830 00001F2E 8A9F9000            <1> 	mov	bl,byte [fdc_media_state+bx]
  1831 00001F32 C3                  <1> 	ret
  1832                              <1> 
  1833                              <1> ;=========================================================================
  1834                              <1> ; set_media_state - Store drive's media state in the data area
  1835                              <1> ; Input:
  1836                              <1> ;	AL = media state
  1837                              <1> ;	[BP+int_13_dl] = drive number
  1838                              <1> ; Output:
  1839                              <1> ;	none
  1840                              <1> ;-------------------------------------------------------------------------
  1841                              <1> set_media_state:
  1842 00001F33 53                  <1> 	push	bx
  1843 00001F34 8A5E08              <1> 	mov	bl,byte [bp+int_13_dl]
  1844 00001F37 B700                <1> 	mov	bh,0			; BX = drive number
  1845 00001F39 88879000            <1> 	mov	byte [fdc_media_state+bx],al
  1846 00001F3D 5B                  <1> 	pop	bx
  1847 00001F3E C3                  <1> 	ret
  1848                              <1> 
  1849                              <1> ;=========================================================================
  1850                              <1> ; check_cylinder - Compare specified cylinder with value in the BIOS data area
  1851                              <1> ; Input:
  1852                              <1> ;	CH = current cylinder
  1853                              <1> ;	[BP+int_13_dl] = drive number
  1854                              <1> ; Output:
  1855                              <1> ;	ZF = 1 - cylinder matches
  1856                              <1> ;-------------------------------------------------------------------------
  1857                              <1> check_cylinder:
  1858 00001F3F 53                  <1> 	push	bx
  1859 00001F40 8A5E08              <1> 	mov	bl,byte [bp+int_13_dl]
  1860 00001F43 B700                <1> 	mov	bh,0			; BX = drive number
  1861 00001F45 38AF9400            <1> 	cmp	byte [fdc_cylinder+bx],ch
  1862 00001F49 5B                  <1> 	pop	bx
  1863 00001F4A C3                  <1> 	ret
  1864                              <1> 
  1865                              <1> ;=========================================================================
  1866                              <1> ; set_cylinder - Store drive's current cylinder into the BIOS data area
  1867                              <1> ; Input:
  1868                              <1> ;	CH = current cylinder
  1869                              <1> ;	[BP+int_13_dl] = drive number
  1870                              <1> ; Output:
  1871                              <1> ;	none
  1872                              <1> ;-------------------------------------------------------------------------
  1873                              <1> set_cylinder:
  1874 00001F4B 53                  <1> 	push	bx
  1875 00001F4C 8A5E08              <1> 	mov	bl,byte [bp+int_13_dl]
  1876 00001F4F B700                <1> 	mov	bh,0			; BX = drive number
  1877 00001F51 88AF9400            <1> 	mov	byte [fdc_cylinder+bx],ch
  1878 00001F55 5B                  <1> 	pop	bx
  1879 00001F56 C3                  <1> 	ret
  1880                              <1> 
  1881                              <1> ;=========================================================================
  1882                              <1> ; check_drive_calibrated - Check if the drive calibrated bit is set
  1883                              <1> ;			   in the BIOS data area
  1884                              <1> ; Input:
  1885                              <1> ;	[BP+int_13_dl] = drive number
  1886                              <1> ; Output:
  1887                              <1> ;	CF = 1 - bit set (drive calibrated)
  1888                              <1> ;-------------------------------------------------------------------------
  1889                              <1> check_drive_calibrated:
  1890 00001F57 51                  <1> 	push	cx
  1891 00001F58 8A2E3E00            <1> 	mov	ch,byte [fdc_calib_state] ; calibration state for primary FDC
  1892 00001F5C 8A4E08              <1> 	mov	cl,byte [bp+int_13_dl]	; CL = drive number
  1893 00001F5F FEC1                <1> 	inc	cl
  1894 00001F61 D2ED                <1> 	shr	ch,cl			; set CF if drive is calibrated
  1895 00001F63 59                  <1> 	pop	cx
  1896 00001F64 C3                  <1> 	ret
  1897                              <1> 
  1898                              <1> ;=========================================================================
  1899                              <1> ; set_drive_calibrated - Set drive calibrated bit in the BIOS data area
  1900                              <1> ; Input:
  1901                              <1> ;	[BP+int_13_dl] = drive number
  1902                              <1> ; Output:
  1903                              <1> ;	none
  1904                              <1> ;-------------------------------------------------------------------------
  1905                              <1> set_drive_calibrated:
  1906 00001F65 51                  <1> 	push	cx
  1907 00001F66 8A4E08              <1> 	mov	cl,byte [bp+int_13_dl]	; CL = drive number
  1908 00001F69 B501                <1> 	mov	ch,1			; bit 0 set
  1909 00001F6B D2E5                <1> 	shl	ch,cl			; move it into the right position
  1910 00001F6D 082E3E00            <1> 	or	byte [fdc_calib_state],ch ; set the bit for the primary FDC
  1911 00001F71 59                  <1> 	pop	cx
  1912 00001F72 C3                  <1> 	ret
  1913                              <1> 
  1914                              <1> ;=========================================================================
  1915                              <1> ; detect_floppy - Detect floppy configuration
  1916                              <1> ;                 set equipment bits accordingly
  1917                              <1> ; Input:
  1918                              <1> ;	none
  1919                              <1> ; Ouput:
  1920                              <1> ;	AL = NVRAM floppy configuration byte
  1921                              <1> ;-------------------------------------------------------------------------
  1922                              <1> detect_floppy:
  1923                              <1> %ifdef BIOS_SETUP
  1924 00001F73 E848F0              <1> 	call	get_floppy
  1925                              <1> %else ; BIOS_SETUP
  1926                              <1> 	mov	al,44h			; FIXME: fake two 1.44MB floppy drives
  1927                              <1> %endif ; BIOS_SETUP
  1928 00001F76 3C00                <1> 	cmp	al,00h			; No floppy drives?
  1929 00001F78 740E                <1> 	je	.exit
  1930 00001F7A 800E100001          <1> 	or	byte [equipment_list],equip_floppies
  1931 00001F7F A80F                <1> 	test	al,0Fh			; Second floppy drive installed?
  1932 00001F81 7405                <1> 	jz	.exit
  1933 00001F83 800E100040          <1> 	or	byte [equipment_list],equip_floppy2
  1934                              <1> .exit:
  1935 00001F88 C3                  <1> 	ret
  1936                              <1> 
  1937                              <1> ;=========================================================================
  1938                              <1> ; get_drive_type - Read drive type from NVRAM or Flash ROM configuration
  1939                              <1> ; Input:
  1940                              <1> ;	DL = drive number (0 or 1)
  1941                              <1> ; Output:
  1942                              <1> ;	CF clear if successful
  1943                              <1> ;		AL = drive type
  1944                              <1> ;	CF set on error (invalid drive type)
  1945                              <1> ;=========================================================================
  1946                              <1> 
  1947                              <1> get_drive_type:
  1948                              <1> %ifdef BIOS_SETUP
  1949 00001F89 E832F0              <1> 	call	get_floppy
  1950                              <1> %else ; BIOS_SETUP
  1951                              <1> 	mov	al,44h			; FIXME: fake two 1.44MB floppy drives
  1952                              <1> %endif ; BIOS_SETUP
  1953 00001F8C 08D2                <1> 	or	dl,dl			; drive 0?
  1954 00001F8E 7508                <1> 	jnz	.drive_1		; jump if drive 1 - type in bits 3-0
  1955 00001F90 D0E8                <1> 	shr	al,1			; shift drive 0 bits 7-4 to 3-0
  1956 00001F92 D0E8                <1> 	shr	al,1
  1957 00001F94 D0E8                <1> 	shr	al,1
  1958 00001F96 D0E8                <1> 	shr	al,1
  1959                              <1> .drive_1:
  1960 00001F98 240F                <1> 	and	al,0Fh			; mask drive bits
  1961 00001F9A 3C00                <1> 	cmp	al,type_none
  1962 00001F9C 740A                <1> 	je	.error
  1963 00001F9E 3C05                <1> 	cmp	al,5			; invalid value
  1964 00001FA0 7406                <1> 	je	.error
  1965 00001FA2 3C06                <1> 	cmp	al,type_2880
  1966 00001FA4 7702                <1> 	ja	.error
  1967 00001FA6 F8                  <1> 	clc
  1968 00001FA7 C3                  <1> 	ret
  1969                              <1> 
  1970                              <1> .error:
  1971 00001FA8 F9                  <1> 	stc
  1972 00001FA9 C3                  <1> 	ret
  1973                              <1> 
  1974                              <1> ;=========================================================================
  1975                              <1> ; print_floppy - Print floppy configuration
  1976                              <1> ; Input:
  1977                              <1> ;	AL = NVRAM floppy configuration byte
  1978                              <1> ; Ouput:
  1979                              <1> ;	none
  1980                              <1> ;-------------------------------------------------------------------------
  1981                              <1> print_floppy:
  1982 00001FAA 50                  <1> 	push	ax
  1983 00001FAB 56                  <1> 	push	si
  1984 00001FAC BE[9402]            <1> 	mov	si,msg_floppy
  1985 00001FAF E86408              <1> 	call	print
  1986 00001FB2 D0C8                <1> 	ror	al,1
  1987 00001FB4 D0C8                <1> 	ror	al,1
  1988 00001FB6 D0C8                <1> 	ror	al,1
  1989 00001FB8 D0C8                <1> 	ror	al,1
  1990 00001FBA 89C6                <1> 	mov	si,ax
  1991 00001FBC 83E607              <1> 	and	si,0007h
  1992 00001FBF D1E6                <1> 	shl	si,1
  1993 00001FC1 2E8BB4[290A]        <1>     cs	mov	si,word [tbl_floppy+si]
  1994 00001FC6 E84D08              <1> 	call	print
  1995 00001FC9 BE[BA02]            <1> 	mov	si,msg_floppy_2
  1996 00001FCC E84708              <1> 	call	print
  1997 00001FCF D0C8                <1> 	ror	al,1
  1998 00001FD1 D0C8                <1> 	ror	al,1
  1999 00001FD3 D0C8                <1> 	ror	al,1
  2000 00001FD5 D0C8                <1> 	ror	al,1
  2001 00001FD7 89C6                <1> 	mov	si,ax
  2002 00001FD9 83E607              <1> 	and	si,0007h
  2003 00001FDC D1E6                <1> 	shl	si,1
  2004 00001FDE 2E8BB4[290A]        <1>     cs	mov	si,word [tbl_floppy+si]
  2005 00001FE3 E83008              <1> 	call	print
  2006 00001FE6 BE[8B00]            <1> 	mov	si,msg_crlf
  2007 00001FE9 E82A08              <1> 	call	print
  2008 00001FEC 5E                  <1> 	pop	si
  2009 00001FED 58                  <1> 	pop	ax
  2010 00001FEE C3                  <1> 	ret
   271                                  %ifdef AT_KEYBOARD
   272                                  %include	"at_kbc.inc"		; keyboard controller functions
   273                                  %endif ; AT_KEYBOARD
   274                                  %include	"scancode.inc"		; keyboard scancodes translation func.
   275                              <1> ;=========================================================================
   276                              <1> ; scancode.inc - Keyboard scancode to ASCII code conversion
   277                              <1> ;		 and related INT 16h functions:
   278                              <1> ;	INT 16h - BIOS Keyboard Services
   279                              <1> ;		- function AH=00h
   280                              <1> ;		- function AH=01h
   281                              <1> ;		- function AH=10h
   282                              <1> ;		- function AH=11h
   283                              <1> ;-------------------------------------------------------------------------
   284                              <1> ;
   285                              <1> ; Compiles with NASM 2.13.02, might work with other versions
   286                              <1> ;
   287                              <1> ; Copyright (C) 2010 - 2023 Sergey Kiselev.
   288                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
   289                              <1> ;
   290                              <1> ; This program is free software: you can redistribute it and/or modify
   291                              <1> ; it under the terms of the GNU General Public License as published by
   292                              <1> ; the Free Software Foundation, either version 3 of the License, or
   293                              <1> ; (at your option) any later version.
   294                              <1> ;
   295                              <1> ; This program is distributed in the hope that it will be useful,
   296                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   297                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   298                              <1> ; GNU General Public License for more details.
   299                              <1> ;
   300                              <1> ; You should have received a copy of the GNU General Public License
   301                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   302                              <1> ;
   303                              <1> ;=========================================================================
   304                              <1> 
   305                              <1> ;=========================================================================
   306                              <1> ; scan_xlat_table - Keyboard scan code to ASCII and
   307                              <1> ;                   BIOS scan code translation table
   308                              <1> ; Note 1: Table starts with scancode == 1
   309                              <1> ; Note 2: The high byte of the 'Normal' field indicates key flags
   310                              <1> ;	00 - no flags
   311                              <1> ;	1x - keypad numeric keys, can be used with Alt to enter ASCII codes
   312                              <1> ;	     x in this case equals digit value
   313                              <1> ;	20 - key is affected by Caps Log or Num Lock (reverses Shift operation)
   314                              <1> ;	40 - there is an extended key, so check for 0E0h flag
   315                              <1> ;	8x - F11, F12 BIOS scan codes
   316                              <1> ;	     (observation: for all other keys BIOS scan code == kbd scan code)
   317                              <1> ;-------------------------------------------------------------------------
   318                              <1> 
   319                              <1> scan_xlat_table:
   320                              <1> ;		Normal	Shift	Ctrl	Alt	Key	KeySh	Scan
   321 00001FEF 1B001B011B01F001    <1> 	dw	001Bh,	011Bh,	011Bh,	01F0h	; Esc		01h
   322 00001FF7 3100210200000078    <1> 	dw	0031h,	0221h,	0,	7800h	; 1	!	02h
   323 00001FFF 3200400300030079    <1> 	dw	0032h,	0340h,	0300h,	7900h	; 2	@	03h
   324 00002007 330023040000007A    <1> 	dw	0033h,	0423h,	0,	7A00h	; 3	#	04h
   325 0000200F 340024050000007B    <1> 	dw	0034h,	0524h,	0,	7B00h	; 4	$	05h
   326 00002017 350025060000007C    <1> 	dw	0035h,	0625h,	0,	7C00h	; 5	%	06h
   327 0000201F 36005E071E07007D    <1> 	dw	0036h,	075Eh,	071Eh,	7D00h	; 6	^	07h
   328 00002027 370026080000007E    <1> 	dw	0037h,	0826h,	0,	7E00h	; 7	&	08h
   329 0000202F 38002A090000007F    <1> 	dw	0038h,	092Ah,	0,	7F00h	; 8	*	09h
   330 00002037 3900280A00000080    <1> 	dw	0039h,	0A28h,	0,	8000h	; 9	(	0Ah
   331 0000203F 3000290B00000081    <1> 	dw	0030h,	0B29h,	0,	8100h	; 0	)	0Bh
   332 00002047 2D005F0C1F0C0082    <1> 	dw	002Dh,	0C5Fh,	0C1Fh,	8200h	; -	_	0Ch
   333 0000204F 3D002B0D00000083    <1> 	dw	003Dh,	0D2Bh,	0,	8300h	; =	+	0Dh
   334 00002057 0800080E7F0EF00E    <1> 	dw	0008h,	0E08h,	0E7Fh,	0EF0h	; Back Space	0Eh
   335 0000205F 0900000F009400A5    <1> 	dw	0009h,	0F00h,	9400h,	0A500h	; Tab		0Fh
   336 00002067 7120511011100010    <1> 	dw	2071h,	1051h,	1011h,	1000h	; q	Q	10h
   337                              <1> ;		Normal	Shift	Ctrl	Alt	Key	KeySh	Scan
   338 0000206F 7720571117110011    <1> 	dw	2077h,	1157h,	1117h,	1100h	; w	W	11h
   339 00002077 6520451205120012    <1> 	dw	2065h,	1245h,	1205h,	1200h	; e	E	12h
   340 0000207F 7220521312130013    <1> 	dw	2072h,	1352h,	1312h,	1300h	; r	R	13h
   341 00002087 7420541414140014    <1> 	dw	2074h,	1454h,	1414h,	1400h	; t	T	14h
   342 0000208F 7920591519150015    <1> 	dw	2079h,	1559h,	1519h,	1500h	; y	Y	15h
   343 00002097 7520551615160016    <1> 	dw	2075h,	1655h,	1615h,	1600h	; u	U	16h
   344 0000209F 6920491709170017    <1> 	dw	2069h,	1749h,	1709h,	1700h	; i	I	17h
   345 000020A7 6F204F180F180018    <1> 	dw	206Fh,	184Fh,	180Fh,	1800h	; o	O	18h
   346 000020AF 7020501910190019    <1> 	dw	2070h,	1950h,	1910h,	1900h	; p	P	19h
   347 000020B7 5B007B1A1B1AF01A    <1> 	dw	005Bh,	1A7Bh,	1A1Bh,	1AF0h	; [	{	1Ah
   348 000020BF 5D007D1B1D1BF01B    <1> 	dw	005Dh,	1B7Dh,	1B1Dh,	1BF0h	; ]	}	1Bh
   349 000020C7 0D400D1C0A1CF01C    <1> 	dw	400Dh,	1C0Dh,	1C0Ah,	1CF0h	; Enter		1Ch
   350 000020CF 0000000000000000    <1> 	dw	0,	0,	0,	0,	; Ctrl		1Dh
   351 000020D7 6120411E011E001E    <1> 	dw	2061h,	1E41h,	1E01h,	1E00h	; a	A	1Eh
   352 000020DF 7320531F131F001F    <1> 	dw	2073h,	1F53h,	1F13h,	1F00h	; s	S	1Fh
   353 000020E7 6420442004200020    <1> 	dw	2064h,	2044h,	2004h,	2000h	; d	D	20h
   354                              <1> ;		Normal	Shift	Ctrl	Alt	Key	KeySh	Scan
   355 000020EF 6620462106210021    <1> 	dw	2066h,	2146h,	2106h,	2100h	; f	F	21h
   356 000020F7 6720472207220022    <1> 	dw	2067h,	2247h,	2207h,	2200h	; g	G	22h
   357 000020FF 6820482308230023    <1> 	dw	2068h,	2348h,	2308h,	2300h	; h	H	23h
   358 00002107 6A204A240A240024    <1> 	dw	206Ah,	244Ah,	240Ah,	2400h	; j	J	24h
   359 0000210F 6B204B250B250025    <1> 	dw	206Bh,	254Bh,	250Bh,	2500h	; k	K	25h
   360 00002117 6C204C260C260026    <1> 	dw	206Ch,	264Ch,	260Ch,	2600h	; l	L	26h
   361 0000211F 3B003A270000F027    <1> 	dw	003Bh,	273Ah,	0,	27F0h	; ;	:	27h
   362 00002127 270022280000F028    <1> 	dw	0027h,	2822h,	0,	28F0h	; '	"	28h
   363 0000212F 60007E290000F029    <1> 	dw	0060h,	297Eh,	0,	29F0h	; `	~	29h
   364 00002137 0000000000000000    <1> 	dw	0,	0,	0,	0	; Left Shift	2Ah
   365 0000213F 5C007C2B1C2BF02B    <1> 	dw	005Ch,	2B7Ch,	2B1Ch,	2BF0h	; \	|	2Bh
   366 00002147 7A205A2C1A2C002C    <1> 	dw	207Ah,	2C5Ah,	2C1Ah,	2C00h	; z	Z	2Ch
   367 0000214F 7820582D182D002D    <1> 	dw	2078h,	2D58h,	2D18h,	2D00h	; x	X	2Dh
   368 00002157 6320432E032E002E    <1> 	dw	2063h,	2E43h,	2E03h,	2E00h	; c	C	2Eh
   369 0000215F 7620562F162F002F    <1> 	dw	2076h,	2F56h,	2F16h,	2F00h	; v	V	2Fh
   370 00002167 6220423002300030    <1> 	dw	2062h,	3042h,	3002h,	3000h	; b	B	30h
   371                              <1> ;		Normal	Shift	Ctrl	Alt	Key	KeySh	Scan
   372 0000216F 6E204E310E310031    <1> 	dw	206Eh,	314Eh,	310Eh,	3100h	; n	N	31h
   373 00002177 6D204D320D320032    <1> 	dw	206Dh,	324Dh,	320Dh,	3200h	; m	M	32h
   374 0000217F 2C003C330000F033    <1> 	dw	002Ch,	333Ch,	0,	33F0h	; ,	<	33h
   375 00002187 2E003E340000F034    <1> 	dw	002Eh,	343Eh,	0,	34F0h	; .	>	34h
   376 0000218F 2F603F350000F035    <1> 	dw	602Fh,	353Fh,	0,	35F0h	; /	?	35h
   377 00002197 0000000000000000    <1> 	dw	0,	0,	0,	0	; Right Shift	36h
   378 0000219F 2A6000000096F037    <1> 	dw	602Ah,	0,	9600h,	37F0h	; *	PrtSc	37h
   379 000021A7 0000000000000000    <1> 	dw	0,	0,	0,	0	; Alt		38h
   380 000021AF 2000203920392039    <1> 	dw	0020h,	3920h,	3920h,	3920h	; Space		39h
   381 000021B7 0000000000000000    <1> 	dw	0,	0,	0,	0	; Caps Lock	3Ah
   382 000021BF 00000054005E0068    <1> 	dw	0000h,	5400h,	5E00h,	6800h	; F1		3Bh
   383 000021C7 00000055005F0069    <1> 	dw	0000h,	5500h,	5F00h,	6900h	; F2		3Ch
   384 000021CF 000000560060006A    <1> 	dw	0000h,	5600h,	6000h,	6A00h	; F3		3Dh
   385 000021D7 000000570061006B    <1> 	dw	0000h,	5700h,	6100h,	6B00h	; F4		3Eh
   386 000021DF 000000580062006C    <1> 	dw	0000h,	5800h,	6200h,	6C00h	; F5		3Fh
   387 000021E7 000000590063006D    <1> 	dw	0000h,	5900h,	6300h,	6D00h	; F6		40h
   388                              <1> ;		Normal	Shift	Ctrl	Alt	Key	KeySh	Scan
   389 000021EF 0000005A0064006E    <1> 	dw	0000h,	5A00h,	6400h,	6E00h	; F7		41h
   390 000021F7 0000005B0065006F    <1> 	dw	0000h,	5B00h,	6500h,	6F00h	; F8		42h
   391 000021FF 0000005C00660070    <1> 	dw	0000h,	5C00h,	6600h,	7000h	; F9		43h
   392 00002207 0000005D00670071    <1> 	dw	0000h,	5D00h,	6700h,	7100h	; F10		44h
   393 0000220F 0000000000000000    <1> 	dw	0,	0,	0,	0	; Num Lock	45h
   394 00002217 0000000000000000    <1> 	dw	0,	0,	0,	0	; Scroll Lock	46h
   395 0000221F 0077374700770097    <1> 	dw	7700h,	4737h,	7700h,	9700h	; Home	7	47h
   396 00002227 00783848008D0098    <1> 	dw	7800h,	4838h,	8D00h,	9800h	; Up 	8	48h
   397 0000222F 0079394900840099    <1> 	dw	7900h,	4939h,	8400h,	9900h	; PgUp	9	49h
   398 00002237 2D002D4A008EF04A    <1> 	dw	002Dh,	4A2Dh,	8E00h,	4AF0h	; Gray -	4Ah
   399 0000223F 0074344B0073009B    <1> 	dw	7400h,	4B34h,	7300h,	9B00h	; Left	4	4Bh
   400 00002247 F075354C008FF04C    <1> 	dw	75F0h,	4C35h,	8F00h,	4CF0h	; Center5	4Ch
   401 0000224F 0076364D0074009D    <1> 	dw	7600h,	4D36h,	7400h,	9D00h	; Right	6 	4Dh
   402 00002257 2B002B4E0090F04E    <1> 	dw	002Bh,	4E2Bh,	9000h,	4EF0h	; Gray +	4Eh
   403 0000225F 0071314F0075009F    <1> 	dw	7100h,	4F31h,	7500h,	9F00h	; End	1	4Fh
   404 00002267 00723250009100A0    <1> 	dw	7200h,	5032h,	9100h,	0A000h	; Down	2	50h
   405                              <1> ;		Normal	Shift	Ctrl	Alt	Key		Scan
   406 0000226F 00733351007600A1    <1> 	dw	7300h,	5133h,	7600h,	0A100h	; PgDn	3	51h
   407 00002277 00703052009200A2    <1> 	dw	7000h,	5230h,	9200h,	0A200h	; Ins	0	52h
   408 0000227F 00602E53009300A3    <1> 	dw	6000h,	532Eh,	9300h,	0A300h	; Del	.	53h
   409 00002287 0000000000000000    <1> 	dw	0,	0,	0,	0	; SysRq		54h
   410 0000228F 0000000000000000    <1> 	dw	0,	0,	0,	0	; NoKey		55h
   411 00002297 0000000000000000    <1> 	dw	0,	0,	0,	0	; NoKey		56h
   412 0000229F 008500870089008B    <1> 	dw	8500h,	8700h,	8900h,	8B00h	; F11		57h
   413 000022A7 00860088008A008C    <1> 	dw	8600h,	8800h,	8A00h,	8C00h	; F12		58h
   414                              <1> .end:
   415                              <1> scan_xlat_table_size equ (.end-scan_xlat_table)/8
   416                              <1> 
   417                              <1> ;=========================================================================
   418                              <1> ; scan_xlat - Translate scan code to ASCII character / scan code pair
   419                              <1> ; Input:
   420                              <1> ;	AL - scan code
   421                              <1> ; Output:
   422                              <1> ;	AX - ASCII character / scan code pair
   423                              <1> ;-------------------------------------------------------------------------
   424                              <1> scan_xlat:
   425 000022AF 53                  <1> 	push	bx
   426 000022B0 FEC8                <1> 	dec	al
   427 000022B2 3C58                <1> 	cmp	al,scan_xlat_table_size
   428 000022B4 7205                <1> 	jb	.1
   429 000022B6 31C0                <1> 	xor	ax,ax
   430 000022B8 E9AB00              <1> 	jmp	.exit
   431                              <1> 
   432                              <1> .1:
   433 000022BB B700                <1> 	mov	bh,00h				; calculate offset of the key
   434 000022BD 88C3                <1> 	mov	bl,al				; in scan_xlat_table
   435 000022BF D1E3                <1> 	shl	bx,1				; BX = AL * 8
   436 000022C1 D1E3                <1> 	shl	bx,1
   437 000022C3 D1E3                <1> 	shl	bx,1
   438                              <1> 
   439 000022C5 F606170008          <1> 	test	byte [kbd_flags_1],kbd_alt_bit	; is the Alt key pressed?
   440 000022CA 7428                <1> 	jz	.check_ctrl			; Alt key is not pressed
   441 000022CC 2E8B87[F51F]        <1>     cs	mov	ax,word [scan_xlat_table+6+bx]	; Alt codes are in 4th column
   442                              <1> 	; check for numeric Keypad keys
   443 000022D1 2EF687[F01F]10      <1>     cs  test	byte [scan_xlat_table+1+bx],10h ; keypad?
   444 000022D7 7474                <1> 	jz	.check_extended
   445 000022D9 F606960002          <1> 	test	byte [kbd_flags_3],10b		; previous scan code was 0E0h?
   446 000022DE 756D                <1> 	jnz	.check_extended			; ... yes, it is a 0E0h
   447                              <1> 						; and so it is not a keypad key
   448                              <1> 
   449 000022E0 2E8A87[F01F]        <1>     cs	mov	al,byte [scan_xlat_table+1+bx]
   450 000022E5 240F                <1> 	and	al,0Fh				; get the numeric value
   451 000022E7 8A261900            <1> 	mov	ah,byte [kbd_alt_keypad]	; load value from work area
   452 000022EB D50A                <1> 	aad	0Ah				; AL = AH * 10 + AL
   453 000022ED A21900              <1> 	mov	byte [kbd_alt_keypad],al	; store it back to the work area
   454                              <1> 
   455 000022F0 31C0                <1> 	xor	ax,ax				; return nothing
   456 000022F2 EB72                <1> 	jmp	.exit
   457                              <1> 
   458                              <1> .check_ctrl:
   459 000022F4 F606170004          <1> 	test	byte [kbd_flags_1],kbd_ctrl_bit	; is the Ctrl key pressed?
   460 000022F9 7407                <1> 	jz	.check_locks			; Ctrl key is not pressed
   461 000022FB 2E8B87[F31F]        <1>     cs	mov	ax,word [scan_xlat_table+4+bx]	; Ctrl codes are in 3rd column
   462 00002300 EB4B                <1> 	jmp	.check_extended
   463                              <1> 
   464                              <1> .check_locks:
   465 00002302 2EF687[F01F]20      <1>     cs	test	byte [scan_xlat_table+1+bx],20h	; is this key affected by Locks?
   466 00002308 741D                <1> 	jz	.check_shift			; not affected by Locks
   467                              <1> 
   468 0000230A 3C46                <1> 	cmp	al,46h				; Num Lock affects scancodes
   469 0000230C 7309                <1> 	jae	.check_num_lock			; above or equal 47h
   470                              <1> 
   471 0000230E F606170040          <1> 	test	byte [kbd_flags_1],kbd_caps_bit	; is Caps Lock active?
   472 00002313 7412                <1> 	jz	.check_shift			; Caps Lock is not active
   473 00002315 EB07                <1> 	jmp	.lock_active
   474                              <1> 
   475                              <1> .check_num_lock:
   476 00002317 F606170020          <1> 	test    byte [kbd_flags_1],kbd_num_bit	; is Num Lock active?
   477 0000231C 7409                <1> 	jz	.check_shift			; Num Lock is not active
   478                              <1> .lock_active:
   479                              <1> 	; are any of Shift keys active?
   480 0000231E F606170003          <1> 	test	byte [kbd_flags_1],kbd_lshft_bit|kbd_rshft_bit
   481 00002323 7409                <1> 	jz	.shift				; Lock active, Shift inactive
   482 00002325 EB0E                <1> 	jmp	.no_shift			; Lock active, Shift active
   483                              <1> 
   484                              <1> .check_shift:
   485                              <1> 	; are any of Shift keys active?
   486 00002327 F606170003          <1> 	test	byte [kbd_flags_1],kbd_lshft_bit|kbd_rshft_bit
   487 0000232C 7407                <1> 	jz	.no_shift
   488                              <1> .shift:
   489 0000232E 2E8B87[F11F]        <1>     cs	mov	ax,word [scan_xlat_table+2+bx]	; Shift codes are in 2nd column
   490 00002333 EB18                <1> 	jmp	.check_extended
   491                              <1> 
   492                              <1> .no_shift:
   493 00002335 88C4                <1> 	mov	ah,al				; Move scan code to AH
   494 00002337 FEC4                <1> 	inc	ah
   495 00002339 2E8A87[EF1F]        <1>     cs	mov	al,byte [scan_xlat_table+bx]	; Normal codes are in 1st column
   496 0000233E 2EF687[F01F]80      <1>     cs	test	byte [scan_xlat_table+1+bx],80h	; F11 or F12?
   497 00002344 7407                <1> 	jz	.check_extended			; not F11 or F12
   498 00002346 2E8AA7[F01F]        <1>     cs  mov	ah,byte [scan_xlat_table+bx+1]	; Load scan code for F11 or F12
   499 0000234B EB19                <1> 	jmp	.exit
   500                              <1> 
   501                              <1> .check_extended:
   502 0000234D 2EF687[F01F]40      <1>    cs	test	byte [scan_xlat_table+1+bx],40h	; have an extended key?
   503 00002353 7411                <1> 	jz	.exit				; no extended key
   504 00002355 F606960002          <1> 	test	byte [kbd_flags_3],10b		; previous scan code was 0E0h?
   505 0000235A 740A                <1> 	jz	.exit				; ... not a 0E0h
   506 0000235C 3C00                <1> 	cmp	al,00h
   507 0000235E 7504                <1> 	jnz	.ascii_code			; key has an ASCII code
   508 00002360 B0E0                <1> 	mov	al,0E0h				; indicate extended key
   509 00002362 EB02                <1> 	jmp	.exit
   510                              <1> 
   511                              <1> .ascii_code:
   512 00002364 B4E0                <1> 	mov	ah,0E0h				; indicate extended key for a
   513                              <1> 						; key with valid ASCII code
   514                              <1> 						; (Keypad Enter, *, and /)
   515                              <1> 
   516                              <1> .exit:
   517 00002366 5B                  <1> 	pop	bx
   518 00002367 C3                  <1> 	ret
   519                              <1> 
   520                              <1> ;=========================================================================
   521                              <1> ; int_16_fn00 - get keystroke
   522                              <1> ; Input:
   523                              <1> ;	AH = 00h
   524                              <1> ; Output:
   525                              <1> ;	AH = BIOS scan code
   526                              <1> ;	AL = ASCII character
   527                              <1> ; Notes:
   528                              <1> ;	- Waits for the keystroke if keyboard buffer is empty
   529                              <1> ;	- Converts extended keystrokes (101+ key keyboards) to standard
   530                              <1> ;	  keystrokes, discards extended keystrokes without standard analogs
   531                              <1> ;	- Use function AH=10h for extended keystrokes handling
   532                              <1> ;-------------------------------------------------------------------------
   533                              <1> int_16_fn00:
   534 00002368 FB                  <1> 	sti
   535                              <1> .1:
   536 00002369 8B1E1A00            <1> 	mov	bx,word [kbd_buffer_head]
   537 0000236D 3B1E1C00            <1> 	cmp	bx,word [kbd_buffer_tail] ; keystroke available?
   538 00002371 74F6                <1> 	jz	.1			; wait or keystroke
   539 00002373 8B07                <1> 	mov	ax,word [bx]		; get the keystroke
   540 00002375 83C302              <1> 	add	bx,2			; move kbd_buffer_head to the next
   541                              <1> 					;   location
   542 00002378 3B1E8200            <1> 	cmp	bx,word [kbd_buffer_end]
   543 0000237C 7504                <1> 	jne	.2
   544 0000237E 8B1E8000            <1> 	mov	bx,word [kbd_buffer_start]
   545                              <1> .2:
   546 00002382 891E1A00            <1> 	mov	word [kbd_buffer_head],bx
   547 00002386 3CE0                <1> 	cmp	al,0E0h			; a convertible (to standard)
   548                              <1> 					;   extended key?
   549 00002388 7504                <1> 	jne	.3			; not a convertible key
   550 0000238A B000                <1> 	mov	al,00h			; convert to a standard key
   551 0000238C EB2C                <1> 	jmp	.exit
   552                              <1> .3:
   553 0000238E 3CF0                <1> 	cmp	al,0F0h			; an ignored extended key?
   554 00002390 74D7                <1> 	je	.1			; an ignored extended key, get next key
   555 00002392 80FC84              <1> 	cmp	ah,084h			; an ignored extended key?
   556                              <1> 					;   (scancode above 84h)
   557 00002395 77D2                <1> 	ja	.1			; an ignored extended key, get next key
   558 00002397 80FCE0              <1> 	cmp	ah,0E0h			; a convertible ASCII extended key?
   559 0000239A 751E                <1> 	jne	.exit
   560 0000239C 3C0A                <1> 	cmp	al,0Ah			; LF (Ctrl + Keypad Enter)
   561 0000239E 7504                <1> 	jne	.4
   562 000023A0 B41C                <1> 	mov	ah,1Ch			; standard Enter scancode
   563 000023A2 EB16                <1> 	jmp	.exit
   564                              <1> .4:
   565 000023A4 3C0D                <1> 	cmp	al,0Dh			; CR (Keypad Enter)
   566 000023A6 7504                <1> 	jne	.5
   567 000023A8 B41C                <1> 	mov	ah,1Ch			; standard Enter scancode
   568 000023AA EB0E                <1> 	jmp	.exit
   569                              <1> .5:
   570 000023AC 3C2F                <1> 	cmp	al,2Fh			; Keypad /
   571 000023AE 7504                <1> 	jne	.6
   572 000023B0 B435                <1> 	mov	ah,35h			; standard / scancode
   573 000023B2 EB06                <1> 	jmp	.exit
   574                              <1> .6:
   575 000023B4 3C2A                <1> 	cmp	al,2Ah			; Keypad *
   576 000023B6 7502                <1> 	jne	.exit
   577 000023B8 B437                <1> 	mov	ah,37h			; standard * scancode
   578                              <1> .exit:
   579 000023BA E9AE24              <1> 	jmp	int_16_exit
   580                              <1> 
   581                              <1> ;=========================================================================
   582                              <1> ; int_16_fn01 - check for keystroke
   583                              <1> ; Input:
   584                              <1> ;	AH = 01h
   585                              <1> ; Output:
   586                              <1> ;	ZF = 1 - no keystroke available
   587                              <1> ;	ZF = 0 = keystroke is available and put in AX
   588                              <1> ;		AH = BIOS scan code
   589                              <1> ;		AL = ASCII character
   590                              <1> ; Notes:
   591                              <1> ;	- Does not remove keystroke from keyboard buffer
   592                              <1> ;	- Converts extended keystrokes (101+ key keyboards) to standard
   593                              <1> ;	  keystrokes, discards extended keystrokes without standard analogs
   594                              <1> ;	- Use function AH=11h for extended keystrokes handling
   595                              <1> ;-------------------------------------------------------------------------
   596                              <1> int_16_fn01:
   597 000023BD 8B1E1A00            <1> 	mov	bx,word [kbd_buffer_head]
   598 000023C1 8B07                <1> 	mov	ax,word [bx]
   599 000023C3 3B1E1C00            <1> 	cmp	bx,word [kbd_buffer_tail]
   600 000023C7 7436                <1> 	jz	.exit			; no keystroke, exit
   601 000023C9 3CE0                <1> 	cmp	al,0E0h			; a convertible (to standard)
   602                              <1> 					;   extended key?
   603 000023CB 7504                <1> 	jne	.1			; not a convertible key
   604 000023CD B000                <1> 	mov	al,00h			; convert to a standard key
   605 000023CF EB2C                <1> 	jmp	.clear_zf
   606                              <1> .1:
   607 000023D1 3CF0                <1> 	cmp	al,0F0h			; an ignored extended key?
   608 000023D3 742D                <1> 	je	.discard_key		; an ignored extended key, discard
   609 000023D5 80FC84              <1> 	cmp	ah,084h			; an ignored extended key?
   610                              <1> 					;   (scancode above 84h)
   611 000023D8 7728                <1> 	ja	.discard_key		; an ignored extended key, discard
   612 000023DA 80FCE0              <1> 	cmp	ah,0E0h			; a convertible ASCII extended key?
   613 000023DD 751E                <1> 	jne	.clear_zf
   614 000023DF 3C0A                <1> 	cmp	al,0Ah			; LF (Ctrl + Keypad Enter)
   615 000023E1 7504                <1> 	jne	.2
   616 000023E3 B41C                <1> 	mov	ah,1Ch			; standard Enter scancode
   617 000023E5 EB16                <1> 	jmp	.clear_zf
   618                              <1> .2:
   619 000023E7 3C0D                <1> 	cmp	al,0Dh			; CR (Keypad Enter)
   620 000023E9 7504                <1> 	jne	.3
   621 000023EB B41C                <1> 	mov	ah,1Ch			; standard Enter scancode
   622 000023ED EB0E                <1> 	jmp	.clear_zf
   623                              <1> .3:
   624 000023EF 3C2F                <1> 	cmp	al,2Fh			; Keypad /
   625 000023F1 7504                <1> 	jne	.4
   626 000023F3 B435                <1> 	mov	ah,35h			; standard / scancode
   627 000023F5 EB06                <1> 	jmp	.clear_zf
   628                              <1> .4:
   629 000023F7 3C2A                <1> 	cmp	al,2Ah			; Keypad *
   630 000023F9 7502                <1> 	jne	.clear_zf
   631 000023FB B437                <1> 	mov	ah,37h			; standard * scancode
   632                              <1> 
   633                              <1> .clear_zf:
   634 000023FD 09C0                <1> 	or	ax,ax			; clear ZF (AX is always non-zero)
   635                              <1> .exit:
   636 000023FF E96C24              <1> 	jmp	int_16_exitf
   637                              <1> 
   638                              <1> .discard_key:
   639 00002402 83C302              <1> 	add	bx,2			; move kbd_buffer_head to the next
   640                              <1> 					;   location
   641 00002405 3B1E8200            <1> 	cmp	bx,word [kbd_buffer_end]
   642 00002409 7504                <1> 	jne	.5
   643 0000240B 8B1E8000            <1> 	mov	bx,word [kbd_buffer_start]
   644                              <1> .5:
   645 0000240F 891E1A00            <1> 	mov	word [kbd_buffer_head],bx
   646 00002413 EBA8                <1> 	jmp	int_16_fn01		; check for the next key
   647                              <1> 	
   648                              <1> 
   649                              <1> ;=========================================================================
   650                              <1> ; int_16_fn10 - get extended keystroke
   651                              <1> ; Input:
   652                              <1> ;	AH = 10h
   653                              <1> ; Output:
   654                              <1> ;	AH = BIOS scan code
   655                              <1> ;	AL = ASCII character
   656                              <1> ; Note:
   657                              <1> ;	- Waits for the keystroke if keyboard buffer is empty
   658                              <1> ;-------------------------------------------------------------------------
   659                              <1> int_16_fn10:
   660 00002415 FB                  <1> 	sti
   661                              <1> .1:
   662 00002416 8B1E1A00            <1> 	mov	bx,word [kbd_buffer_head]
   663 0000241A 3B1E1C00            <1> 	cmp	bx,word [kbd_buffer_tail] ; keystroke available?
   664 0000241E 74F6                <1> 	jz	.1			; wait or keystroke
   665 00002420 8B07                <1> 	mov	ax,word [bx]		; get the keystroke
   666 00002422 83C302              <1> 	add	bx,2			; move kbd_buffer_head to the next
   667                              <1> 					;   location
   668 00002425 3B1E8200            <1> 	cmp	bx,word [kbd_buffer_end]
   669 00002429 7504                <1> 	jne	.2
   670 0000242B 8B1E8000            <1> 	mov	bx,word [kbd_buffer_start]
   671                              <1> .2:
   672 0000242F 891E1A00            <1> 	mov	word [kbd_buffer_head],bx
   673 00002433 3CF0                <1> 	cmp	al,0F0h			; an extended key?
   674 00002435 7507                <1> 	jne	.exit			; not an extended key
   675 00002437 80FC00              <1> 	cmp	ah,00h			; is it Alt + 240 (F0 00)?
   676 0000243A 7402                <1> 	je	.exit			; yes it is Alt + 240, return ASCII
   677 0000243C B000                <1> 	mov	al,00h			; set ASCII character to zero
   678                              <1> 
   679                              <1> .exit:
   680 0000243E E92A24              <1> 	jmp	int_16_exit
   681                              <1> 
   682                              <1> ;=========================================================================
   683                              <1> ; int_16_fn11 - check for extended keystroke
   684                              <1> ; Input:
   685                              <1> ;	AH = 01h
   686                              <1> ; Output:
   687                              <1> ;	ZF = 1 - no keystroke available
   688                              <1> ;	ZF = 0 = keystroke is available and put in AX
   689                              <1> ;		AH = BIOS scan code
   690                              <1> ;		AL = ASCII character
   691                              <1> ; Note:
   692                              <1> ;	- Does not remove keystroke from keyboard buffer
   693                              <1> ;-------------------------------------------------------------------------
   694                              <1> int_16_fn11:
   695 00002441 8B1E1A00            <1> 	mov	bx,word [kbd_buffer_head]
   696 00002445 8B07                <1> 	mov	ax,word [bx]
   697 00002447 3B1E1C00            <1> 	cmp	bx,word [kbd_buffer_tail]
   698 0000244B 7408                <1> 	jz	.exit			; no keystroke, exit
   699 0000244D 3CF0                <1> 	cmp	al,0F0h			; an extended key?
   700 0000244F 7502                <1> 	jne	.clear_zf		; not a extended key
   701 00002451 B000                <1> 	mov	al,00h			; set scancode to zero
   702                              <1> .clear_zf:
   703 00002453 09C0                <1> 	or	ax,ax			; clear ZF (AX is always non-zero)
   704                              <1> .exit:
   705 00002455 E91624              <1> 	jmp	int_16_exitf
   275                                  %include	"serial1.inc"		; serial port services & detection
   276                              <1> ;========================================================================
   277                              <1> ; serial1.inc -  BIOS Serial Port Communication Services (part 1 of 2)
   278                              <1> ;       INT 14h, function AH=01h
   279                              <1> ;	INT 14h, function AH=02h
   280                              <1> ;	detect_serial
   281                              <1> ;	serial port related definitions and tables
   282                              <1> ;	- see serial2.inc for other INT 14h functions
   283                              <1> ;-------------------------------------------------------------------------
   284                              <1> ;
   285                              <1> ; Compiles with NASM 2.13.02, might work with other versions
   286                              <1> ;
   287                              <1> ; Copyright (C) 2010 - 2023 Sergey Kiselev.
   288                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
   289                              <1> ;
   290                              <1> ; This program is free software: you can redistribute it and/or modify
   291                              <1> ; it under the terms of the GNU General Public License as published by
   292                              <1> ; the Free Software Foundation, either version 3 of the License, or
   293                              <1> ; (at your option) any later version.
   294                              <1> ;
   295                              <1> ; This program is distributed in the hope that it will be useful,
   296                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   297                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   298                              <1> ; GNU General Public License for more details.
   299                              <1> ;
   300                              <1> ; You should have received a copy of the GNU General Public License
   301                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   302                              <1> ;
   303                              <1> ;=========================================================================
   304                              <1> 
   305                              <1> uart_osc	equ	1843200		; 1.8432 MHz is the default UART clock
   306                              <1> one_sec_timeout equ	33135		; 30.18 us intervals in one second
   307                              <1> 
   308                              <1> uart_ier_reg	equ	1		; UART Interrupt Enable Register
   309                              <1> 
   310                              <1> uart_lcr_reg	equ	3		; UART Line Control Register
   311                              <1> uart_lcr_ldiv	equ	80h		; LCR - load divisor bit
   312                              <1> uart_lcr_wlen	equ	03h		; LCR - word length bits
   313                              <1> uart_lcr_stop	equ	04h		; LCR - number of stop bits bit
   314                              <1> uart_lcr_pen	equ	08h		; LCR - parity enable bit
   315                              <1> uart_lcr_peven	equ	10h		; LCR - parity even bit
   316                              <1> 
   317                              <1> uart_mcr_reg	equ	4		; UART Modem Control Register
   318                              <1> uart_mcr_dtr	equ	1		; MCR - data terminal ready (DTR)
   319                              <1> uart_mcr_rts	equ	2		; MCR - request to send (RTS)
   320                              <1> 
   321                              <1> uart_lsr_reg	equ	5		; UART Line Status Register
   322                              <1> uart_lsr_dr	equ	1		; LSR - data ready (DR)
   323                              <1> uart_lsr_thre	equ	20h		; LSR - THR empty (THRE)
   324                              <1> 
   325                              <1> uart_msr_reg	equ	6		; UART Modem Status Register
   326                              <1> uart_msr_cts	equ	10h		; MSR - clear to send (CTS)
   327                              <1> uart_msr_dsr	equ	20h		; MSR - data set ready (DSR)
   328                              <1> 
   329                              <1> uart_err_timeout equ	80h		; timeout error
   330                              <1> 
   331                              <1> num_serial	equ	4		; number of serial ports
   332                              <1> 
   333                              <1> ;=========================================================================
   334                              <1> ; int_14_fn01 - Send character
   335                              <1> ; Input:
   336                              <1> ;	AH = 01h - function 01h - send character
   337                              <1> ;	AL = character to send
   338                              <1> ;	DX = serial port number (0-3)
   339                              <1> ; Output:
   340                              <1> ;	AH = line status (see int_14_fn00 for complete description)
   341                              <1> ;-------------------------------------------------------------------------
   342                              <1> int_14_fn01:
   343 00002458 50                  <1> 	push	ax
   344 00002459 B003                <1> 	mov	al,(uart_mcr_dtr | uart_mcr_rts) ; set DTR and RTS in MCR:
   345                              <1> 					; ready to communicate, request to send
   346 0000245B B730                <1> 	mov	bh,(uart_msr_dsr | uart_msr_cts) ; wait for DSR and CTS in MSR:
   347                              <1> 					; ready to communicate, clear to send
   348 0000245D B320                <1> 	mov	bl,uart_lsr_thre	; and for THRE in LSR:
   349                              <1> 					; UART is ready to accept new character
   350 0000245F E82200              <1> 	call	uart_wait_status
   351 00002462 59                  <1> 	pop	cx
   352 00002463 7506                <1> 	jnz	int_14_timeout		; timeout, original AL is in CL
   353 00002465 88C8                <1> 	mov	al,cl
   354 00002467 EE                  <1> 	out	dx,al			; sent the character
   355 00002468 E9FB22              <1> 	jmp	int_14_exit
   356                              <1> 
   357                              <1> int_14_timeout:
   358 0000246B 88C8                <1> 	mov	al,cl			; original AL saved in CL, restore it
   359 0000246D 80CC80              <1> 	or	ah,uart_err_timeout	; set timeout bit
   360 00002470 E9F322              <1> 	jmp	int_14_exit
   361                              <1> 
   362                              <1> ;=========================================================================
   363                              <1> ; int_14_fn02 - Receive character
   364                              <1> ; Input:
   365                              <1> ;	AH = 02h - function 02h - receive character
   366                              <1> ;	DX = serial port number (0-3)
   367                              <1> ; Output:
   368                              <1> ;	AL = character received
   369                              <1> ;	AH = line status (see int_14_fn00 for complete description)
   370                              <1> ;-------------------------------------------------------------------------
   371                              <1> int_14_fn02:
   372 00002473 50                  <1> 	push	ax
   373 00002474 B001                <1> 	mov	al,uart_mcr_dtr		; set DTR in MCR:
   374                              <1> 					; ready to communicate
   375 00002476 B720                <1> 	mov	bh,uart_msr_dsr		; wait for DSR in MSR:
   376                              <1> 					; ready to communicate
   377 00002478 B301                <1> 	mov	bl,uart_lsr_dr		; and for DT in LSR:
   378                              <1> 					; UART has received a character
   379 0000247A E80700              <1> 	call	uart_wait_status
   380 0000247D 59                  <1> 	pop	cx
   381 0000247E 75EB                <1> 	jnz	int_14_timeout
   382 00002480 EC                  <1> 	in	al,dx			; receive the character
   383 00002481 E9E222              <1> 	jmp	int_14_exit
   384                              <1> 
   385                              <1> ;=========================================================================
   386                              <1> ; uart_wait_status - wait for modem and line status
   387                              <1> ; Input:
   388                              <1> ;	AL = value to write to MCR (Modem Control Register)
   389                              <1> ;	BH = mask to wait for in MSR (Modem Status Register)
   390                              <1> ;	BL = mask to wait for in LSR (Line Status Register)
   391                              <1> ;	DX = UART base address
   392                              <1> ;	SI = address of the timeout value (in seconds)
   393                              <1> ; Output:
   394                              <1> ;	AH = line status
   395                              <1> ;	ZF = 0 - timeout
   396                              <1> ;	CX,BX - destroyed
   397                              <1> ;-------------------------------------------------------------------------
   398                              <1> uart_wait_status:
   399 00002484 52                  <1> 	push	dx
   400 00002485 83C204              <1> 	add	dx,uart_mcr_reg		; DX = UART MCR address
   401 00002488 EE                  <1> 	out	dx,al			; output MCR value
   402 00002489 42                  <1> 	inc	dx
   403 0000248A 42                  <1> 	inc	dx			; DX = UART MSR address
   404                              <1> 					; OPTIMIZATION:
   405                              <1> 					; uart_msr_reg = uart_mcr_reg + 2
   406 0000248B E80A00              <1> 	call	wait_for_port		; wait for MSR status
   407 0000248E 7506                <1> 	jnz	.wait_exit
   408 00002490 4A                  <1> 	dec	dx			; DX = UART LSR address
   409                              <1> 					; OPTIMIZATION:
   410                              <1> 					; uart_lsr_reg = uart_msr_reg - 1
   411 00002491 88DF                <1> 	mov	bh,bl			; BH = LSR mask
   412 00002493 E80200              <1> 	call	wait_for_port		; wait for LSR status
   413                              <1> .wait_exit:
   414 00002496 5A                  <1> 	pop	dx
   415 00002497 C3                  <1> 	ret
   416                              <1> 
   417                              <1> ;=========================================================================
   418                              <1> ; wait_for_port - wait for set bits in a register
   419                              <1> ;
   420                              <1> ; Input:
   421                              <1> ;	BH = mask to wait for (bits that need to be 1)
   422                              <1> ;	DX = register address
   423                              <1> ;	SI = address of the timeout value (in seconds)
   424                              <1> ; Output:
   425                              <1> ;	AH = last port reading
   426                              <1> ;	ZF clear on timeout
   427                              <1> ;	ZF set on success
   428                              <1> ;	AL - trashed
   429                              <1> ;	CX - trashed
   430                              <1> ;-------------------------------------------------------------------------
   431                              <1> wait_for_port:
   432                              <1> 
   433 00002498 53                  <1> 	push	bx
   434 00002499 8A1C                <1> 	mov	bl,byte [SI]		; get the timeout value in seconds
   435                              <1> 
   436                              <1> .loop_outer:
   437 0000249B B96F81              <1> 	mov	cx,one_sec_timeout	; 30.18 us intervals in one second
   438                              <1> 
   439                              <1> .loop_inner:
   440 0000249E EC                  <1> 	in	al,dx			; read the register
   441 0000249F 88C4                <1> 	mov	ah,al			; save register in AH
   442 000024A1 20F8                <1> 	and	al,bh
   443 000024A3 38F8                <1> 	cmp	al,bh			; required bits are set?
   444 000024A5 740E                <1> 	je	.exit
   445                              <1> 
   446                              <1> %ifdef AT_DELAY
   447                              <1> 
   448                              <1> .zero_loop:
   449                              <1> 	in	al,ppi_pb_reg
   450                              <1> 	test	al,refresh_flag
   451                              <1> 	jz	.zero_loop		; wait 15.09 us
   452                              <1> 
   453                              <1> .one_loop:
   454                              <1> 	in	al,ppi_pb_reg
   455                              <1> 	test	al,refresh_flag
   456                              <1> 	jnz	.one_loop		; wait 15.09 us
   457                              <1> 
   458                              <1> %else ; AT_DELAY
   459                              <1> 
   460                              <1> 	; wait 30.17 us (Intel 8088 CPU running on 4.77 MHz)
   461 000024A7 B008                <1>         mov     al,8
   462                              <1> .delay_loop:
   463 000024A9 FEC8                <1>         dec     al
   464 000024AB 75FC                <1>         jnz     .delay_loop
   465                              <1> 
   466                              <1> %endif ; AT_DELAY
   467                              <1> 
   468 000024AD E2EF                <1> 	loop	.loop_inner
   469                              <1> 
   470 000024AF FECB                <1> 	dec	bl
   471 000024B1 75E8                <1> 	jnz	.loop_outer
   472 000024B3 08FF                <1> 	or	bh,bh			; timeout set ZF = 0 (BH != 0)
   473                              <1> 
   474                              <1> .exit:
   475 000024B5 5B                  <1> 	pop	bx
   476 000024B6 C3                  <1> 	ret
   477                              <1> 
   478                              <1> ;=========================================================================
   479                              <1> ; detect_serial - detect and print serial ports
   480                              <1> ; Input:
   481                              <1> ;	none
   482                              <1> ; Output:
   483                              <1> ;	none (updates BIOS data area)
   484                              <1> ;-------------------------------------------------------------------------
   485                              <1> detect_serial:
   486 000024B7 50                  <1> 	push	ax
   487 000024B8 53                  <1> 	push	bx
   488 000024B9 52                  <1> 	push	dx
   489 000024BA 56                  <1> 	push	si
   490 000024BB B024                <1> 	mov	al,e_serial_scan
   491 000024BD E680                <1> 	out	post_reg,al
   492                              <1> 
   493 000024BF BE[1E03]            <1> 	mov	si,msg_serial
   494 000024C2 E85103              <1> 	call	print
   495 000024C5 BB0101              <1> 	mov	bx,0101h		; the default timeout is 1 sec
   496 000024C8 891E7C00            <1> 	mov	word [serial_timeout],bx   ; initialize timeout values
   497 000024CC 891E7E00            <1> 	mov	word [serial_timeout+2],bx ; for all 4 ports
   498 000024D0 31DB                <1> 	xor	bx,bx			; BX = 0
   499                              <1> .detect_loop:
   500 000024D2 BE[3B03]            <1> 	mov	si,msg_serial_com
   501 000024D5 E83E03              <1> 	call	print
   502 000024D8 88D8                <1> 	mov	al,bl
   503 000024DA D0E8                <1> 	shr	al,1
   504 000024DC FEC0                <1> 	inc	al			; AL = COM port number (1..4)
   505 000024DE E89303              <1> 	call	print_digit
   506 000024E1 BE[9300]            <1> 	mov	si,msg_colon
   507 000024E4 E82F03              <1> 	call	print
   508 000024E7 2E8B97[3925]        <1>     cs	mov	dx,word [uart_ier_regs+bx] ; DX = UART IER address
   509 000024EC EC                  <1> 	in	al,dx
   510 000024ED B00F                <1> 	mov	al,0Fh
   511 000024EF EE                  <1> 	out	dx,al			; enable interrupts
   512 000024F0 B000                <1> 	mov	al,00h
   513 000024F2 E6C0                <1> 	out	unused_reg,al		; clear ISA data bus floating signals
   514 000024F4 EC                  <1> 	in	al,dx			; get interrupt enable register to AL
   515 000024F5 3C0F                <1> 	cmp	al,0Fh
   516 000024F7 751C                <1> 	jne	.no_port		; no port at this address
   517 000024F9 B000                <1> 	mov	al,00h
   518 000024FB EE                  <1> 	out	dx,al			; disable interrupts
   519 000024FC B0FF                <1> 	mov	al,0FFh
   520 000024FE E6C0                <1> 	out	unused_reg,al		; set ISA data bus floating signals
   521 00002500 EC                  <1> 	in	al,dx			; get interrupt enable register to AL
   522 00002501 3C00                <1> 	cmp	al,00h
   523 00002503 7510                <1> 	jne	.no_port		; no port at this address
   524 00002505 4A                  <1> 	dec	dx			; DX = UART base address
   525                              <1> 					; OPTIMIZATION:
   526                              <1> 					; uart_base = uart_ier_reg - 1
   527 00002506 8917                <1> 	mov	word [equip_serial+bx],dx ; store port address to the BIOS
   528                              <1> 					; data area
   529 00002508 810610000002        <1> 	add	word [equipment_list],0200h ; increment number of serial ports
   530 0000250E 89D0                <1> 	mov	ax,dx
   531 00002510 E81E03              <1> 	call	print_hex
   532 00002513 EB0A                <1> 	jmp	.next
   533                              <1> 
   534                              <1> .no_port:
   535 00002515 C7070000            <1> 	mov	word [equip_serial+bx],0 ; no port
   536 00002519 BE[8E00]            <1> 	mov	si,msg_none
   537 0000251C E8F702              <1> 	call	print
   538                              <1> 	
   539                              <1> .next:
   540 0000251F 43                  <1> 	inc	bx
   541 00002520 43                  <1> 	inc	bx
   542 00002521 83FB08              <1> 	cmp	bx,(num_serial << 1)	; all serial ports have been scanned?
   543 00002524 7408                <1> 	je	.done
   544 00002526 BE[9600]            <1> 	mov	si,msg_semicolon
   545 00002529 E8EA02              <1> 	call	print
   546 0000252C EBA4                <1> 	jmp	.detect_loop
   547                              <1> 
   548                              <1> .done:
   549 0000252E BE[8B00]            <1> 	mov	si,msg_crlf
   550 00002531 E8E202              <1> 	call	print
   551                              <1> 
   552 00002534 5E                  <1> 	pop	si
   553 00002535 5A                  <1> 	pop	dx
   554 00002536 5B                  <1> 	pop	bx
   555 00002537 58                  <1> 	pop	ax
   556 00002538 C3                  <1> 	ret
   557                              <1> 
   558                              <1> ;-------------------------------------------------------------------------
   559                              <1> ; serial port Interrupt Enable Register addresses - used for port detection
   560 00002539 F903F902            <1> uart_ier_regs	dw	(3F8h + uart_ier_reg), (2F8h + uart_ier_reg)
   561 0000253D E903E902            <1> 		dw	(3E8h + uart_ier_reg), (2E8h + uart_ier_reg)
   562                              <1> 
   563                              <1> ;-------------------------------------------------------------------------
   564                              <1> ; UART divisor values table
   565 00002541 1704                <1> uart_divisors	dw	uart_osc/16/110		; 110 bps
   566 00002543 0003                <1> 		dw	uart_osc/16/150		; 150 bps
   567 00002545 8001                <1> 		dw	uart_osc/16/300		; 300 bps
   568 00002547 C000                <1> 		dw	uart_osc/16/600		; 600 bps
   569 00002549 6000                <1> 		dw	uart_osc/16/1200	; 1200 bps
   570 0000254B 3000                <1> 		dw	uart_osc/16/2400	; 2400 bps
   571 0000254D 1800                <1> 		dw	uart_osc/16/4800	; 4800 bps
   572 0000254F 0C00                <1> 		dw	uart_osc/16/9600	; 9600 bps
   573 00002551 0600                <1> 		dw	uart_osc/16/19200	; 19200 bps
   574 00002553 0300                <1> 		dw	uart_osc/16/38400	; 38400 bps
   575 00002555 0200                <1> 		dw	uart_osc/16/57600	; 57600 bps
   576 00002557 0100                <1> 		dw	uart_osc/16/115200	; 115200 bps
   577                              <1> num_divisors	equ ($-uart_divisors)/2
   276                                  %include	"printer1.inc"		; parallel printer services & detection
   277                              <1> ;========================================================================
   278                              <1> ; printer2.inc - Parallel printer support (part 1 of 2)
   279                              <1> ;	INT 17h, function AH=01h 
   280                              <1> ;	detect_parallel
   281                              <1> ;	- see printer2.inc for other INT 17h functions
   282                              <1> ;-------------------------------------------------------------------------
   283                              <1> ;
   284                              <1> ; Compiles with NASM 2.13.02, might work with other versions
   285                              <1> ;
   286                              <1> ; Copyright (C) 2010 - 2023 Sergey Kiselev.
   287                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
   288                              <1> ;
   289                              <1> ; This program is free software: you can redistribute it and/or modify
   290                              <1> ; it under the terms of the GNU General Public License as published by
   291                              <1> ; the Free Software Foundation, either version 3 of the License, or
   292                              <1> ; (at your option) any later version.
   293                              <1> ;
   294                              <1> ; This program is distributed in the hope that it will be useful,
   295                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   296                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   297                              <1> ; GNU General Public License for more details.
   298                              <1> ;
   299                              <1> ; You should have received a copy of the GNU General Public License
   300                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   301                              <1> ;
   302                              <1> ;=========================================================================
   303                              <1> 
   304                              <1> num_parallel	equ	3		; number of parallel ports
   305                              <1> 
   306                              <1> prn_data_reg	equ	0		; printer data register (out)
   307                              <1> 
   308                              <1> prn_stat_reg	equ	1		; printer status register (in)
   309                              <1> prn_stat_bits	equ	0F8h		; used bits in status register
   310                              <1> prn_stat_invert	equ	048h		; bits 6 and 3 need to be inverted
   311                              <1> prn_stat_busy	equ	80h		; 0 = printer is busy (1 = ready)
   312                              <1> prn_stat_tmout	equ	01h		; 1 = timeout (software error)
   313                              <1> 
   314                              <1> prn_ctrl_reg	equ	2		; printer control register (out)
   315                              <1> prn_ctrl_sel	equ	08h		; 1 = select printer
   316                              <1> prn_ctrl_init	equ	04h		; 0 = initialize printer (1 = normal)
   317                              <1> prn_ctrl_autolf	equ	02h		; 1 = auto linefeed
   318                              <1> prn_ctrl_strobe	equ	01h		; 1 = strobe active
   319                              <1> 
   320                              <1> prn_init_delay	equ	2485		; printer initialization delay, 75 ms
   321                              <1> 
   322                              <1> ;=========================================================================
   323                              <1> ; int_17_fn01 - Initialize printer port
   324                              <1> ; Input:
   325                              <1> ;	AH = 1 - function 01h - initialize printer port
   326                              <1> ;	DX = printer port number (0-2)
   327                              <1> ; Output:
   328                              <1> ;	AH = printer status (see int_17_fn00 for complete description)
   329                              <1> ;-------------------------------------------------------------------------
   330                              <1> int_17_fn01:
   331 00002559 42                  <1> 	inc	dx
   332 0000255A 42                  <1> 	inc	dx			; DX = prn_ctrl_reg
   333                              <1> 					; OPTIMIZATION:
   334                              <1> 					; prn_ctrl_reg = prn_data_reg + 2
   335 0000255B B008                <1> 	mov	al,prn_ctrl_sel		; init bit = 0, initialize printer
   336 0000255D EE                  <1> 	out	dx,al
   337 0000255E 51                  <1> 	push	cx
   338 0000255F B9B509              <1> 	mov	cx,prn_init_delay
   339 00002562 E80BF1              <1> 	call	delay_15us
   340 00002565 59                  <1> 	pop	cx
   341 00002566 B00C                <1> 	mov	al,(prn_ctrl_sel | prn_ctrl_init)
   342 00002568 EE                  <1> 	out	dx,al			; deactivate init bit
   343 00002569 4A                  <1> 	dec	dx			; OPTIMIZATION:
   344                              <1> 					; prn_stat_reg = prn_ctrl_reg - 1
   345 0000256A E9CC2A              <1> 	jmp	int_17_status		; exit returning status
   346                              <1> 
   347                              <1> ;=========================================================================
   348                              <1> ; detect_parallel - detect and print parallel ports
   349                              <1> ; Input:
   350                              <1> ;	none
   351                              <1> ; Output:
   352                              <1> ;	none (updates BIOS data area)
   353                              <1> ; Notes:
   354                              <1> ; 	- If parallel port is found at 3BCh the following parallel port
   355                              <1> ;	  enumeration is used:
   356                              <1> ;	  LPT1 - 3BCh, LPT2 - 378h, LPT3 - 278h
   357                              <1> ;	- If parallel port is not found at 3BCh, the enumeration is:
   358                              <1> ;	  LPT1 - 378h, LPT2 - 278h, LPT3 - none
   359                              <1> ;-------------------------------------------------------------------------
   360                              <1> detect_parallel:
   361 0000256D 50                  <1> 	push	ax
   362 0000256E 53                  <1> 	push	bx
   363 0000256F 52                  <1> 	push	dx
   364 00002570 56                  <1> 	push	si
   365 00002571 B025                <1> 	mov	al,e_parallel_scan
   366 00002573 E680                <1> 	out	post_reg,al
   367                              <1> 
   368 00002575 BB1414              <1> 	mov	bx,1414h		; default timeout is 20 seconds
   369 00002578 891E7800            <1> 	mov	word [printer_timeout],bx   ; initialize timeout values
   370 0000257C 891E7A00            <1> 	mov	word [printer_timeout+2],bx ; for all 4 ports
   371 00002580 31DB                <1> 	xor	bx,bx			; BX = 0
   372 00002582 31FF                <1> 	xor	di,di			; DI = 0
   373                              <1> .detect_loop:
   374 00002584 2E8B95[FD25]        <1>     cs	mov	dx,word [parallel_base+di] ; DX = parallel port address
   375 00002589 B05A                <1> 	mov	al,05Ah			; just some test value
   376 0000258B EE                  <1> 	out	dx,al			; write it to the printer data register
   377 0000258C B0FF                <1> 	mov	al,0FFh
   378 0000258E E6C0                <1> 	out	unused_reg,al		; set ISA data bus floating signals
   379 00002590 EC                  <1> 	in	al,dx
   380 00002591 3C5A                <1> 	cmp	al,05Ah			; compare with the test value
   381 00002593 750B                <1> 	jne	.no_port		; no port at this address
   382 00002595 895708              <1> 	mov	word [equip_parallel+bx],dx ; store port address to the BIOS
   383                              <1> 					; data area
   384 00002598 810610000040        <1> 	add	word [equipment_list],4000h ; increment number of printer ports
   385 0000259E EB09                <1> 	jmp	.next
   386                              <1> 
   387                              <1> .no_port:
   388 000025A0 C747080000          <1> 	mov	word [equip_parallel+bx],0 ; no port
   389 000025A5 09FF                <1> 	or	di,di			; no printer port at 3BCh?
   390 000025A7 7402                <1> 	jz	.next_skip_3BC		; don't increment LPTx number
   391                              <1> .next:
   392 000025A9 43                  <1> 	inc	bx
   393 000025AA 43                  <1> 	inc	bx
   394                              <1> 
   395                              <1> .next_skip_3BC:
   396 000025AB 47                  <1> 	inc	di
   397 000025AC 47                  <1> 	inc	di
   398 000025AD 83FF06              <1> 	cmp	di,(num_parallel << 1)	; all parallel ports have been scanned?
   399 000025B0 7402                <1> 	je	.print			; done with detection, print findings
   400 000025B2 EBD0                <1> 	jmp	.detect_loop
   401                              <1> 
   402                              <1> .print:
   403 000025B4 BE[3F03]            <1> 	mov	si,msg_parallel
   404 000025B7 E85C02              <1> 	call	print
   405 000025BA 31DB                <1> 	xor	bx,bx
   406                              <1> 
   407                              <1> .print_loop:
   408 000025BC BE[5C03]            <1> 	mov	si,msg_parallel_lpt
   409 000025BF E85402              <1> 	call	print
   410 000025C2 88D8                <1> 	mov	al,bl
   411 000025C4 D0E8                <1> 	shr	al,1
   412 000025C6 FEC0                <1> 	inc	al			; AL = LPT port number (1..3)
   413 000025C8 E8A902              <1> 	call	print_digit
   414 000025CB BE[9300]            <1> 	mov	si,msg_colon
   415 000025CE E84502              <1> 	call	print
   416 000025D1 8B4708              <1> 	mov	ax,word [equip_parallel+bx] ; get parallel port address
   417 000025D4 09C0                <1> 	or	ax,ax			; parallel interface installed?
   418 000025D6 7405                <1> 	jz	.print_no_port
   419 000025D8 E85602              <1> 	call	print_hex
   420 000025DB EB06                <1> 	jmp	.print_next
   421                              <1> 
   422                              <1> .print_no_port:
   423 000025DD BE[8E00]            <1> 	mov	si,msg_none
   424 000025E0 E83302              <1> 	call	print
   425                              <1> 
   426                              <1> .print_next:
   427 000025E3 43                  <1> 	inc	bx
   428 000025E4 43                  <1> 	inc	bx
   429 000025E5 83FB06              <1> 	cmp	bx,(num_parallel << 1)	; all parallel ports have been printed?
   430 000025E8 7408                <1> 	je	.done
   431 000025EA BE[9600]            <1> 	mov	si,msg_semicolon
   432 000025ED E82602              <1> 	call	print
   433 000025F0 EBCA                <1> 	jmp	.print_loop
   434                              <1> 
   435                              <1> .done:
   436 000025F2 BE[8B00]            <1> 	mov	si,msg_crlf
   437 000025F5 E81E02              <1> 	call	print
   438                              <1> 
   439 000025F8 5E                  <1> 	pop	si
   440 000025F9 5A                  <1> 	pop	dx
   441 000025FA 5B                  <1> 	pop	bx
   442 000025FB 58                  <1> 	pop	ax
   443 000025FC C3                  <1> 	ret
   444                              <1> 
   445                              <1> ;-------------------------------------------------------------------------
   446                              <1> ; parallel port base addresses - used for port detection
   447 000025FD BC0378037802        <1> parallel_base	dw	3BCh, 378h, 278h
   277                                  %ifdef PS2_MOUSE
   278                                  %ifndef SECOND_PIC
   279                                  %error "PS2_MOUSE depends on SECOND_PIC. Please fix config.inc."
   280                                  %endif ; SECOND_PIC
   281                                  %include	"ps2aux.inc"
   282                                  %endif
   283                                  %include	"sound.inc"		; sound test
   284                              <1> ;=========================================================================
   285                              <1> ; sound.inc - Play power-on sound. This also tests PIT and PORT B functionality
   286                              <1> ;-------------------------------------------------------------------------
   287                              <1> ;
   288                              <1> ; Compiles with NASM 2.13.02, might work with other versions
   289                              <1> ;
   290                              <1> ; Copyright (C) 2010 - 2023 Sergey Kiselev.
   291                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
   292                              <1> ;
   293                              <1> ; This program is free software: you can redistribute it and/or modify
   294                              <1> ; it under the terms of the GNU General Public License as published by
   295                              <1> ; the Free Software Foundation, either version 3 of the License, or
   296                              <1> ; (at your option) any later version.
   297                              <1> ;
   298                              <1> ; This program is distributed in the hope that it will be useful,
   299                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   300                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   301                              <1> ; GNU General Public License for more details.
   302                              <1> ;
   303                              <1> ; You should have received a copy of the GNU General Public License
   304                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   305                              <1> ;
   306                              <1> ;=========================================================================
   307                              <1> 
   308 00002603 6908                <1> notes	dw	pic_freq/554		; D flat
   309 00002605 FFFF                <1> 	dw	-1			; silent
   310 00002607 D310                <1> 	dw	pic_freq/277		; D flat
   311 00002609 980C                <1> 	dw	pic_freq/370		; G flat
   312 0000260B D310                <1> 	dw	pic_freq/277		; D flat
   313 0000260D 3B0B                <1> 	dw	pic_freq/415		; A flat
   314 0000260F 0000                <1> 	dw	0
   315                              <1> 
   316                              <1> ;=========================================================================
   317                              <1> ; sound - Play power-on sound.
   318                              <1> ; Input:
   319                              <1> ;	none
   320                              <1> ; Output:
   321                              <1> ;	none, destroys some registers
   322                              <1> ;-------------------------------------------------------------------------
   323                              <1> sound:
   324 00002611 FC                  <1> 	cld
   325 00002612 BE[0326]            <1> 	mov	si,notes		; set SI to notes table
   326                              <1> 
   327 00002615 B0B6                <1> 	mov	al,0B6h			; set PIC channel 2 to mode 3
   328 00002617 E643                <1> 	out	pit_ctl_reg,al
   329                              <1> 
   330                              <1> .loop:
   331 00002619 2EAD                <1>     cs	lodsw				; load next note to AX
   332 0000261B 83F800              <1> 	cmp	ax,0
   333 0000261E 7422                <1> 	jz	.exit
   334 00002620 7C0C                <1> 	jl	.silent			; don't turn on speaker if silent note
   335 00002622 E642                <1> 	out	pit_ch2_reg,al		; load divisor's low byte to PIC
   336 00002624 88E0                <1> 	mov	al,ah
   337 00002626 E642                <1> 	out	pit_ch2_reg,al		; load divisor's high byte to PIC
   338                              <1> 
   339 00002628 E461                <1> 	in	al,ppi_pb_reg		; read current value of PORT B
   340 0000262A 0C03                <1>         or      al,03h			; turn on the speaker
   341 0000262C E661                <1>         out     ppi_pb_reg,al		; write the new value
   342                              <1> 
   343                              <1> .silent:
   344 0000262E B90030              <1> 	mov	cx,3000h
   345 00002631 E83CF0              <1> 	call	delay_15us		; delay while note is playing
   346                              <1> 
   347 00002634 E461                <1> 	in	al,ppi_pb_reg		; read current value of PORT B
   348 00002636 24FC                <1> 	and	al,0FCh			; turn off the speaker
   349 00002638 E661                <1>         out     ppi_pb_reg,al		; write the new value
   350                              <1> 
   351 0000263A B90001              <1>         mov     cx,0100h
   352 0000263D E830F0              <1> 	call	delay_15us		; delay after the note
   353                              <1>         
   354 00002640 EBD7                <1>         jmp     .loop			; play the next note
   355                              <1> .exit:
   356 00002642 C3                  <1> 	ret
   357                              <1> 
   358                              <1> ;=========================================================================
   359                              <1> ; beep - Play a beep sound
   360                              <1> ; Input:
   361                              <1> ;	BL - duration in 0.1 second
   362                              <1> ; Output:
   363                              <1> ;	BL = 0
   364                              <1> ;-------------------------------------------------------------------------
   365                              <1> beep:
   366 00002643 50                  <1> 	push	ax
   367 00002644 B0B6                <1> 	mov	al,0B6h			; set PIC channel 2 to mode 3
   368 00002646 E643                <1> 	out	pit_ctl_reg,al
   369 00002648 B8A904              <1> 	mov	ax,1193			; approximately 1000 Hz
   370 0000264B E642                <1> 	out	pit_ch2_reg,al		; load divisor's low byte to PIC
   371 0000264D 88E0                <1> 	mov	al,ah
   372 0000264F E642                <1> 	out	pit_ch2_reg,al		; load divisor's high byte to PIC
   373 00002651 E461                <1> 	in	al,ppi_pb_reg		; read current value of PORT B
   374 00002653 0C03                <1> 	or	al,03h			; turn on the speaker
   375 00002655 E661                <1> 	out	ppi_pb_reg,al		; write the new value
   376                              <1> .loop:
   377 00002657 B90A1A              <1> 	mov	cx,6666			; 0.1 second delay
   378 0000265A E813F0              <1> 	call	delay_15us
   379 0000265D FECB                <1> 	dec	bl
   380 0000265F 75F6                <1> 	jnz	.loop
   381 00002661 3403                <1> 	xor	al,03h			; turn off the speaker
   382 00002663 E661                <1> 	out	ppi_pb_reg,al		; write the new value
   383 00002665 58                  <1> 	pop	ax
   384 00002666 C3                  <1> 	ret
   284                                  %include	"cpu.inc"		; CPU and FPU detection
   285                              <1> ;=========================================================================
   286                              <1> ; cpu.inc - Detect and print CPU type and FPU presence
   287                              <1> ;-------------------------------------------------------------------------
   288                              <1> ;
   289                              <1> ; Compiles with NASM 2.13.02, might work with other versions
   290                              <1> ;
   291                              <1> ; Copyright (C) 2010 - 2023 Sergey Kiselev.
   292                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
   293                              <1> ;
   294                              <1> ; This program is free software: you can redistribute it and/or modify
   295                              <1> ; it under the terms of the GNU General Public License as published by
   296                              <1> ; the Free Software Foundation, either version 3 of the License, or
   297                              <1> ; (at your option) any later version.
   298                              <1> ;
   299                              <1> ; This program is distributed in the hope that it will be useful,
   300                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
   301                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   302                              <1> ; GNU General Public License for more details.
   303                              <1> ;
   304                              <1> ; You should have received a copy of the GNU General Public License
   305                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
   306                              <1> ;
   307                              <1> ;=========================================================================
   308                              <1> 
   309                              <1> flags_tf	equ	0100h		; TF flag - enables single-step
   310                              <1> 
   311                              <1> ;=========================================================================
   312                              <1> ; detect_cpu - detect and print CPU type
   313                              <1> ; Note:
   314                              <1> ;	- Designed to detect 8088, 80C88, and V20 CPU. Likely will return
   315                              <1> ;	  incorrect results if used on other CPU types.
   316                              <1> ;-------------------------------------------------------------------------
   317                              <1> detect_cpu:
   318 00002667 50                  <1> 	push	ax
   319 00002668 56                  <1> 	push	si
   320 00002669 B021                <1> 	mov	al,e_cpu_detect
   321 0000266B E680                <1> 	out	post_reg,al
   322                              <1> 
   323 0000266D BE[D800]            <1> 	mov	si,msg_cpu
   324 00002670 E8A301              <1> 	call	print
   325                              <1> 
   326                              <1> ; test for NEC V20
   327 00002673 B80101              <1> 	mov	ax,0101h
   328 00002676 D510                <1> 	aad	10h			; NEC V20 ignores the argument
   329 00002678 3C0B                <1> 	cmp	al,0Bh			; and always does AL = AL * 0Ah + AH
   330 0000267A 7452                <1> 	je	.nec_v20
   331                              <1> 
   332                              <1> ; not NEC V20, test for various 8088 versions
   333                              <1> .i8088:					; 8088 - NMOS version of 8088
   334 0000267C FA                  <1> 	cli				; disable interrupts
   335 0000267D 1E                  <1> 	push	ds
   336 0000267E 31C0                <1> 	xor	ax,ax
   337 00002680 8ED8                <1> 	mov	ds,ax			; interrupt table segment
   338 00002682 B8[F626]            <1> 	mov	ax,.int_01		; new int 01h offset
   339 00002685 87060400            <1> 	xchg	ax,word [4]		; switch with original int 1 offset
   340 00002689 50                  <1> 	push	ax			; save to stack
   341 0000268A 8CC8                <1> 	mov	ax,cs			; new int 01h segment
   342 0000268C 87060600            <1> 	xchg	ax,word [6]		; switch with original int 1 segment
   343 00002690 50                  <1> 	push	ax			; save to stack
   344 00002691 9C                  <1> 	pushf				; push flags to stack (save)
   345 00002692 9C                  <1> 	pushf				; push flags to stack (modify)
   346 00002693 58                  <1> 	pop	ax			; and move them to AX
   347 00002694 0D0001              <1> 	or	ax,flags_tf		; set TF
   348 00002697 50                  <1> 	push	ax
   349 00002698 31C0                <1> 	xor	ax,ax			; AX = 0
   350 0000269A 9D                  <1> 	popf				; load modified value to FLAGS register
   351                              <1> 					; enable single-step
   352 0000269B 90                  <1> 	nop
   353 0000269C 1E                  <1> 	push	ds			; Harris 80C88 disables interrupts
   354                              <1> 					; after PUSH SREG instructions
   355                              <1> .push_sreg:				; and will not single-step to here
   356 0000269D 1F                  <1> 	pop	ds			; 1981 and newer 8088 disable interrupts
   357                              <1> 					; after modifying segment registers
   358                              <1> .pop_sreg:				; and will not single-step to here
   359 0000269E 90                  <1> 	nop
   360 0000269F 9D                  <1> 	popf				; restore original FLAGS, disable
   361                              <1> 					; single-step
   362                              <1> 
   363 000026A0 5E                  <1> 	pop	si			; get original int 01h segment
   364 000026A1 89360600            <1> 	mov	word [6],si		; save it to interrupt table
   365 000026A5 5E                  <1> 	pop	si			; get original int 01h offset
   366 000026A6 89360400            <1> 	mov	word [4],si		; save it to interrupt table
   367 000026AA 1F                  <1> 	pop	ds
   368 000026AB FB                  <1> 	sti				; enable interrupts
   369 000026AC 83F801              <1> 	cmp	ax,0001h		; if AX = 0001h - we have INTEL (C) 1978
   370 000026AF 740D                <1> 	jz	.i8088_78
   371                              <1> 
   372 000026B1 83F802              <1> 	cmp	ax,0002h
   373 000026B4 7410                <1> 	jz	.i8088_81
   374                              <1> 
   375                              <1> .harris:				; Harris / Intersil 80C88
   376 000026B6 BE[A101]            <1> 	mov	si,msg_cpu_harris
   377 000026B9 E85A01              <1> 	call	print
   378 000026BC EB16                <1> 	jmp	.cpu_freq
   379                              <1> 
   380                              <1> .i8088_78:
   381 000026BE BE[1201]            <1> 	mov	si,msg_cpu_8088_78
   382 000026C1 E85201              <1> 	call	print
   383 000026C4 EB0E                <1> 	jmp	.cpu_freq
   384                              <1> 
   385                              <1> .i8088_81:
   386 000026C6 BE[7201]            <1> 	mov	si,msg_cpu_8088_81
   387 000026C9 E84A01              <1> 	call	print
   388 000026CC EB06                <1> 	jmp	.cpu_freq
   389                              <1> 
   390                              <1> .nec_v20:
   391 000026CE BE[B701]            <1> 	mov	si,msg_cpu_nec_v20
   392 000026D1 E84201              <1> 	call	print
   393                              <1> 
   394                              <1> .cpu_freq:
   395                              <1> 
   396                              <1> %ifdef TURBO_MODE
   397                              <1> %ifdef BIOS_SETUP
   398                              <1> ; print CPU clock frequency
   399                              <1> 
   400 000026D4 BE[B600]            <1> 	mov	si,msg_at
   401 000026D7 E83C01              <1> 	call	print
   402                              <1> 
   403 000026DA 50                  <1> 	push	ax
   404 000026DB E8D0E8              <1> 	call	get_config_a		; read BIOS configuration byte A
   405 000026DE E89D00              <1> 	call	print_cpu_clk
   406 000026E1 58                  <1> 	pop	ax
   407                              <1> 
   408                              <1> %endif ; BIOS_SETUP
   409                              <1> %endif ; TURBO_MODE
   410                              <1> 
   411 000026E2 BE[8B00]            <1> 	mov	si,msg_crlf
   412 000026E5 E82E01              <1> 	call	print
   413                              <1> 
   414 000026E8 83F801              <1> 	cmp	ax,0001h		; if AX = 0001h - we have INTEL (C) 1978
   415 000026EB 7506                <1> 	jnz	.exit
   416 000026ED BE[2101]            <1> 	mov	si,msg_cpu_bug
   417 000026F0 E82301              <1> 	call	print
   418                              <1> 
   419                              <1> .exit:
   420 000026F3 5E                  <1> 	pop	si
   421 000026F4 58                  <1> 	pop	ax
   422 000026F5 C3                  <1> 	ret
   423                              <1> 
   424                              <1> ; stack frame after "push bp"
   425                              <1> ; BP - word [BP]
   426                              <1> ; IP - word [BP+2]
   427                              <1> ; CS - word [BP+4]
   428                              <1> ; FLAGS - word [BP+6]
   429                              <1> .int_01:
   430 000026F6 55                  <1> 	push	bp
   431 000026F7 89E5                <1> 	mov	bp,sp
   432 000026F9 817E02[9E26]        <1> 	cmp	word [bp+2],.pop_sreg	; if IP = .pop_sreg we have '78 CPU
   433 000026FE 7504                <1> 	jne	.1
   434 00002700 B001                <1> 	mov	al,01h			; (C) INTEL '79
   435 00002702 EB09                <1> 	jmp	.int_01_exit
   436                              <1> .1:
   437 00002704 817E02[9D26]        <1> 	cmp	word [bp+2],.push_sreg	; if IP = .push_sreg it is not Harris
   438 00002709 7502                <1> 	jne	.int_01_exit
   439 0000270B B002                <1> 	mov	al,02h			; not Harris / Intersil 80C88
   440                              <1> .int_01_exit:
   441 0000270D 5D                  <1> 	pop	bp
   442 0000270E CF                  <1> 	iret
   443                              <1> 
   444                              <1> ;=========================================================================
   445                              <1> ; detect_fpu - detect and print FPU (mathematics coprocessor) presence
   446                              <1> ;-------------------------------------------------------------------------
   447                              <1> test_word	equ	03FEh		; right at the end of interrupt table
   448                              <1> detect_fpu:
   449 0000270F 50                  <1> 	push	ax
   450 00002710 51                  <1> 	push	cx
   451 00002711 56                  <1> 	push	si
   452 00002712 B022                <1> 	mov	al,e_fpu_detect
   453 00002714 E680                <1> 	out	post_reg,al
   454                              <1> 
   455 00002716 BE[F500]            <1> 	mov	si,msg_fpu
   456 00002719 E8FA00              <1> 	call	print
   457 0000271C DBE3                <1> 	fninit				; initialize coprocessor
   458 0000271E B90300              <1> 	mov	cx,3
   459                              <1> .wait:
   460 00002721 E2FE                <1> 	loop	.wait			; wait for coprocessor to initialize
   461                              <1> 					;   (can't use fwait, since it could
   462                              <1> 					;   be no coprocessor at all)
   463 00002723 8B0EFE03            <1> 	mov	cx,word [test_word]	; save test_word to CX
   464 00002727 C706FE030000        <1> 	mov	word [test_word],0000h	; clear space for control word
   465 0000272D D93EFE03            <1> 	fnstcw	word [test_word]	; store control word
   466 00002731 813EFE03FF03        <1> 	cmp	word [test_word],03FFh	; 8087 sets control word to 03FFh
   467 00002737 750D                <1> 	jne	.no_fpu			;   after finit
   468                              <1> 
   469                              <1> .fpu:
   470 00002739 BE[BF01]            <1> 	mov	si,msg_fpu_present
   471 0000273C E8D700              <1> 	call	print
   472 0000273F 830E100002          <1> 	or	word [equipment_list],equip_fpu ; update equipment word
   473 00002744 EB06                <1> 	jmp	.exit
   474                              <1> 
   475                              <1> .no_fpu:
   476                              <1> 
   477 00002746 BE[1503]            <1> 	mov	si,msg_absent
   478 00002749 E8CA00              <1> 	call	print
   479                              <1> 
   480                              <1> .exit:
   481 0000274C 890EFE03            <1> 	mov	word [test_word],cx	; restore initial value of test_word
   482                              <1> 
   483 00002750 5E                  <1> 	pop	si
   484 00002751 59                  <1> 	pop	cx
   485 00002752 58                  <1> 	pop	ax
   486 00002753 C3                  <1> 	ret
   487                              <1> 
   488                              <1> %ifdef MACHINE_FE2010A
   489                              <1> ;=========================================================================
   490                              <1> ; detect_chipset - detect and print chipset type
   491                              <1> ; Input:
   492                              <1> ;	none
   493                              <1> ; Output:
   494                              <1> ;	none
   495                              <1> ; Note: This subroutine also disables DRAM refresh on both FE2010A and PT8010AF
   496                              <1> ;-------------------------------------------------------------------------
   497                              <1> detect_chipset:
   498 00002754 50                  <1> 	push	ax
   499 00002755 56                  <1> 	push	si
   500 00002756 BE[CC01]            <1> 	mov	si,msg_chipset
   501 00002759 E8BA00              <1> 	call	print
   502 0000275C BE[E901]            <1> 	mov	si,msg_fe2010a
   503 0000275F B054                <1> 	mov	al,54h			; channel 1, LSB only, mode 2, binary
   504 00002761 E643                <1> 	out	pit_ctl_reg,al		; used for DRAM refresh on IBM PC/XT/AT
   505 00002763 B012                <1> 	mov	al,12h			; or for delays (using port_b, bit 4)
   506 00002765 E641                <1>         out     pit_ch1_reg,al		; pulse every 15ms
   507 00002767 B040                <1> 	mov	al,40h			; this disables refresh on FE2010A
   508 00002769 E643                <1> 	out	pit_ctl_reg,al		; but not on PT8010AF
   509 0000276B E441                <1> 	in	al,pit_ch1_reg
   510 0000276D 3C12                <1> 	cmp	al,12h			; should be 12h on FE2010A
   511 0000276F 7403                <1> 	je	.print_chipset
   512 00002771 BE[FB01]            <1> 	mov	si,msg_pt8010af
   513                              <1> 
   514                              <1> .print_chipset:
   515 00002774 E89F00              <1> 	call	print
   516 00002777 B054                <1> 	mov	al,54h			; channel 1, LSB only, mode 2, binary
   517 00002779 E643                <1> 	out	pit_ctl_reg,al		; this disables memory refresh
   518 0000277B 58                  <1> 	pop	ax
   519 0000277C 5E                  <1> 	pop	si
   520 0000277D C3                  <1> 	ret
   521                              <1> 
   522                              <1> %endif ; MACHINE_FE2010A
   523                              <1> 
   524                              <1> %ifdef TURBO_MODE
   525                              <1> %ifdef BIOS_SETUP
   526                              <1> ;=========================================================================
   527                              <1> ; print_cpu_clk - Print CPU clock frequency
   528                              <1> ; Input:
   529                              <1> ;	AL - NVRAM CPU clock frequency configuration (bits 1:0)
   530                              <1> ;		0 - 4.77 MHz / Normal
   531                              <1> ;		1 - 7.16 MHz / Turbo
   532                              <1> ;		2 - 9.55 MHz (FE2010A)
   533                              <1> ; Output:
   534                              <1> ;	none
   535                              <1> ;-------------------------------------------------------------------------
   536                              <1> print_cpu_clk:
   537 0000277E 50                  <1> 	push	ax
   538 0000277F 56                  <1> 	push	si
   539 00002780 2403                <1> 	and	al,nvram_trbo_mask	; get turbo bits
   540                              <1> %ifdef MACHINE_FE2010A
   541 00002782 BE[C400]            <1> 	mov	si,msg_clk_7_16mhz
   542 00002785 3C01                <1> 	cmp	al,1
   543 00002787 740A                <1> 	je	.print
   544 00002789 BE[CE00]            <1> 	mov	si,msg_clk_9_55mhz
   545 0000278C 3C02                <1> 	cmp	al,2
   546 0000278E 7403                <1> 	je	.print
   547                              <1> %endif ; MACHINE_FE2010A
   548                              <1> %ifdef MACHINE_XI8088
   549                              <1> 	mov	si,msg_clk_turbo
   550                              <1> 	cmp	al,1
   551                              <1> 	je	.print
   552                              <1> %endif ; MACHINE_XI8088
   553 00002790 BE[BA00]            <1> 	mov	si,msg_clk_4_77mhz
   554                              <1> 
   555                              <1> .print:
   556 00002793 E88000              <1> 	call    print
   557 00002796 5E                  <1> 	pop	si
   558 00002797 58                  <1> 	pop	ax
   559 00002798 C3                  <1> 	ret
   560                              <1> %endif ; BIOS_SETUP
   561                              <1> 
   562                              <1> ;=========================================================================
   563                              <1> ; set_cpu_clk - Set CPU clock frequency
   564                              <1> ; Input:
   565                              <1> ;	AL - NVRAM CPU clock frequency configuration
   566                              <1> ;		0 - 4.77 MHz / Normal
   567                              <1> ;		1 - 7.16 MHz / Turbo
   568                              <1> ;		2 - 9.55 MHz (FE2010A)
   569                              <1> ; Output:
   570                              <1> ;	none
   571                              <1> ;-------------------------------------------------------------------------
   572                              <1> set_cpu_clk:
   573                              <1> %ifdef MACHINE_FE2010A
   574 00002799 3C01                <1> 	cmp	al, 1 
   575 0000279B 7413                <1> 	je	set_cpu_clk_7_16mhz
   576 0000279D 3C02                <1> 	cmp	al, 2
   577 0000279F 7429                <1> 	je	set_cpu_clk_9_55mhz
   578 000027A1 EB01                <1> 	jmp	set_cpu_clk_4_77mhz   
   579                              <1> %endif ; MACHINE_FE2010A
   580                              <1> %ifdef MACHINE_XI8088
   581                              <1> 	cmp	al,1
   582                              <1> 	je	set_cpu_clk_turbo
   583                              <1> 	jmp	set_cpu_clk_4_77mhz   
   584                              <1> %endif ; MACHINE_XI8088
   585 000027A3 C3                  <1> 	ret
   586                              <1> 
   587                              <1> ;=========================================================================
   588                              <1> ; set_cpu_clk_4_77mhz - Set CPU clock at 4.77 MHz
   589                              <1> ; set_cpu_clk_7_16mhz - Set CPU clock at 7.16 MHz
   590                              <1> ; set_cpu_clk_9_55mhz - Set CPU clock at 9.55 MHz
   591                              <1> ; set_cpu_clk_turbo - Set CPU clock at turbo frequency (system dependent)
   592                              <1> ; Input:
   593                              <1> ;	none
   594                              <1> ; Output:
   595                              <1> ;	none
   596                              <1> ;-------------------------------------------------------------------------
   597                              <1> %ifdef MACHINE_FE2010A
   598                              <1> set_cpu_clk_4_77mhz:
   599 000027A4 50                  <1> 	push ax
   600 000027A5 A01000              <1> 	mov	al,byte [equipment_list] ; get lower byte of the equipment list
   601 000027A8 2402                <1> 	and	al,equip_fpu		; isolate FPU installed bit
   602 000027AA 0C01                <1> 	or	al,fe_par_disable	; disable memory parity checking
   603 000027AC E663                <1> 	out	fe_config_reg,al	; clear bits 7-5 - 4.77 MHz CPU clock
   604 000027AE 58                  <1> 	pop ax
   605 000027AF C3                  <1> 	ret
   606                              <1> 
   607                              <1> set_cpu_clk_7_16mhz:
   608 000027B0 50                  <1> 	push ax
   609 000027B1 E8FAE7              <1> 	call	get_config_a
   610 000027B4 88C4                <1> 	mov	ah,al
   611 000027B6 A01000              <1> 	mov	al,byte [equipment_list] ; get lower byte of the equipment list
   612 000027B9 2402                <1> 	and	al,equip_fpu		; isolate FPU installed bit
   613 000027BB 0C01                <1> 	or	al,fe_par_disable	; disable memory parity checking
   614 000027BD 0C40                <1> 	or	al,fe_clk_7_norm	; set bit 6 - 7.15 MHz CPU clock
   615 000027BF F6C410              <1> 	test	ah,nvram_fast_ws	; nvram_fast_ws = 1 - Normal wait states
   616 000027C2 7502                <1> 	jnz	.set_config
   617 000027C4 0C60                <1> 	or	al,fe_clk_7_fast
   618                              <1> 
   619                              <1> .set_config:
   620 000027C6 E663                <1> 	out	fe_config_reg,al
   621 000027C8 58                  <1> 	pop ax
   622 000027C9 C3                  <1> 	ret
   623                              <1> 
   624                              <1> set_cpu_clk_9_55mhz:
   625 000027CA 50                  <1> 	push ax
   626 000027CB E8E0E7              <1> 	call	get_config_a
   627 000027CE 88C4                <1> 	mov	ah,al
   628 000027D0 A01000              <1> 	mov	al,byte [equipment_list] ; get lower byte of the equipment list
   629 000027D3 2402                <1> 	and	al,equip_fpu		; isolate FPU installed bit
   630 000027D5 0C01                <1> 	or	al,fe_par_disable	; disable memory parity checking
   631 000027D7 0C80                <1> 	or	al,fe_clk_9_norm	; set bit 7 - 9.54 MHz CPU clock
   632 000027D9 F6C410              <1> 	test	ah,nvram_fast_ws
   633 000027DC 7502                <1> 	jnz	.set_config		; nvram_fast_ws = 1 - Normal wait states
   634 000027DE 0CC0                <1> 	or	al,fe_clk_9_fast
   635                              <1> 
   636                              <1> .set_config:
   637 000027E0 E663                <1> 	out	fe_config_reg,al
   638 000027E2 58                  <1> 	pop ax
   639 000027E3 C3                  <1> 	ret
   640                              <1> %endif ; MACHINE_FE2010A
   641                              <1> %ifdef MACHINE_XI8088
   642                              <1> set_cpu_clk_4_77mhz:
   643                              <1> 	push	ax
   644                              <1> 	in	al,ppi_pb_reg
   645                              <1> 	and	al,0FBh			; clear bit 2 (turbo enable bit)
   646                              <1> 	out	ppi_pb_reg,al
   647                              <1> 	pop	ax
   648                              <1> 	ret
   649                              <1> 
   650                              <1> set_cpu_clk_turbo:
   651                              <1> 	push	ax
   652                              <1> 	in	al,ppi_pb_reg
   653                              <1> 	or	al,04h			; set bit 2 (turbo enable bit)
   654                              <1> 	out	ppi_pb_reg,al
   655                              <1> 	pop	ax
   656                              <1> 	ret
   657                              <1> %endif ; MACHINE_XI8088
   658                              <1> %endif ; TURBO_MODE
   285                                  
   286                                  %ifdef SECOND_PIC
   287                                  
   288                                  ;=========================================================================
   289                                  ; int_ignore2 - signal end of interrupt to PIC if hardware interrupt, return
   290                                  ;-------------------------------------------------------------------------
   291                                  int_ignore2:
   292                                  	push	ax
   293                                  	mov	al,20h
   294                                  	out	pic2_reg0,al	; signal EOI to the slave PIC
   295                                  	out	pic1_reg0,al	; signal EOI to the master PIC
   296                                  	pop	ax
   297                                  	iret
   298                                  
   299                                  ;=========================================================================
   300                                  ; int_71 - IRQ9 ISR, emulate IRQ2
   301                                  ;-------------------------------------------------------------------------
   302                                  int_71:
   303                                  	push	ax
   304                                  	mov	al,20h
   305                                  	out	pic2_reg0,al	; signal EOI to the slave PIC
   306                                  	pop	ax
   307                                  	int	0Ah		; call IRQ2 ISR
   308                                  	iret
   309                                  
   310                                  ;=========================================================================
   311                                  ; int_75 - IRQ13 ISR, emulate NMI by FPU
   312                                  ;-------------------------------------------------------------------------
   313                                  int_75:
   314                                  	push	ax
   315                                  	mov	al,20h
   316                                  	out	pic2_reg0,al	; signal EOI to the slave PIC
   317                                  	out	pic1_reg0,al	; signal EOI to the master PIC
   318                                  	pop	ax
   319                                  	int	02h		; call NMI ISR
   320                                  	iret
   321                                  
   322                                  %endif ; SECOND_PIC
   323                                  
   324                                  ;=========================================================================
   325                                  ; boot_os -Boot the OS
   326                                  ;-------------------------------------------------------------------------
   327                                  boot_os:
   328                                  
   329                                  ;-------------------------------------------------------------------------
   330                                  ; Check for F1 (setup key), run setup utility if pressed
   331                                  
   332 000027E4 B401                    	mov	ah,01h
   333 000027E6 CD16                    	int	16h
   334 000027E8 740E                    	jz	.no_key
   335 000027EA B400                    	mov	ah,00h
   336 000027EC CD16                    	int	16h			; read the keystroke
   337 000027EE 3D003B                  	cmp	ax,3B00h		; F1?
   338 000027F1 7505                    	jne	.no_key
   339 000027F3 800E120001              	or	byte [post_flags],post_setup
   340                                  .no_key:
   341                                  
   342 000027F8 F606120001              	test	byte [post_flags],post_setup
   343 000027FD 7403                    	jz	.no_setup
   344                                  
   345                                  %ifdef BIOS_SETUP
   346 000027FF E87CE9                  	call	nvram_setup
   347                                  %endif ; BIOS_SETUP
   348                                  
   349                                  .no_setup:
   350                                  
   351                                  %ifdef TURBO_MODE
   352                                  %ifdef BIOS_SETUP
   353 00002802 E8A9E7                  	call	get_config_a		; read BIOS configuration byte A
   354 00002805 2403                    	and	al,nvram_trbo_mask
   355 00002807 E88FFF                  	call	set_cpu_clk		; set CPU clock
   356                                  %endif ; BIOS_SETUP
   357                                  %endif ; TURBO_MODE
   358                                  
   359 0000280A B000                    	mov	al,e_boot		; boot the OS POST code
   360 0000280C E680                    	out	post_reg,al
   361                                  
   362 0000280E BE[3404]                	mov	si,msg_boot
   363 00002811 E80200                  	call	print
   364 00002814 CD19                    	int	19h			; boot the OS
   365                                  
   366                                  ;=========================================================================
   367                                  ; print - print ASCIIZ string to the console
   368                                  ; Input:
   369                                  ;	CS:SI - pointer to string to print
   370                                  ; Output:
   371                                  ;	none
   372                                  ;-------------------------------------------------------------------------
   373                                  print:
   374 00002816 9C                      	pushf
   375 00002817 50                      	push	ax
   376 00002818 53                      	push	bx
   377 00002819 56                      	push	si
   378 0000281A 1E                      	push	ds
   379 0000281B 0E                      	push	cs
   380 0000281C 1F                      	pop	ds
   381 0000281D FC                      	cld
   382                                  .1:
   383 0000281E AC                      	lodsb
   384 0000281F 08C0                    	or	al,al
   385 00002821 7408                    	jz	.exit
   386 00002823 B40E                    	mov	ah,0Eh
   387 00002825 B30F                    	mov	bl,0Fh
   388 00002827 CD10                    	int	10h
   389 00002829 EBF3                    	jmp	.1
   390                                  .exit:
   391 0000282B 1F                      	pop	ds
   392 0000282C 5E                      	pop	si
   393 0000282D 5B                      	pop	bx
   394 0000282E 58                      	pop	ax
   395 0000282F 9D                      	popf
   396 00002830 C3                      	ret
   397                                  
   398                                  ;=========================================================================
   399                                  ; print_hex - print 16-bit number in hexadecimal
   400                                  ; Input:
   401                                  ;	AX - number to print
   402                                  ; Output:
   403                                  ;	none
   404                                  ;-------------------------------------------------------------------------
   405                                  print_hex:
   406 00002831 86C4                    	xchg	al,ah
   407 00002833 E80600                  	call	print_byte		; print the upper byte
   408 00002836 86C4                    	xchg	al,ah
   409 00002838 E80100                  	call	print_byte		; print the lower byte
   410 0000283B C3                      	ret
   411                                  
   412                                  ;=========================================================================
   413                                  ; print_byte - print a byte in hexadecimal
   414                                  ; Input:
   415                                  ;	AL - byte to print
   416                                  ; Output:
   417                                  ;	none
   418                                  ;-------------------------------------------------------------------------
   419                                  print_byte:
   420 0000283C D0C0                    	rol	al,1
   421 0000283E D0C0                    	rol	al,1
   422 00002840 D0C0                    	rol	al,1
   423 00002842 D0C0                    	rol	al,1
   424 00002844 E82D00                  	call	print_digit
   425 00002847 D0C0                    	rol	al,1
   426 00002849 D0C0                    	rol	al,1
   427 0000284B D0C0                    	rol	al,1
   428 0000284D D0C0                    	rol	al,1
   429 0000284F E82200                  	call	print_digit
   430 00002852 C3                      	ret
   431                                  
   432                                  ;=========================================================================
   433                                  ; print_dec - print 16-bit number in decimal
   434                                  ; Input:
   435                                  ;	AX - number to print
   436                                  ; Output:
   437                                  ;	none
   438                                  ;-------------------------------------------------------------------------
   439                                  print_dec:
   440 00002853 50                      	push	ax
   441 00002854 51                      	push	cx
   442 00002855 52                      	push	dx
   443 00002856 B90A00                  	mov	cx,10		; base = 10
   444 00002859 E80400                  	call	.print_rec
   445 0000285C 5A                      	pop	dx
   446 0000285D 59                      	pop	cx
   447 0000285E 58                      	pop	ax
   448 0000285F C3                      	ret
   449                                  
   450                                  .print_rec:			; print all digits recursively
   451 00002860 52                      	push	dx
   452 00002861 31D2                    	xor	dx,dx		; DX = 0
   453 00002863 F7F1                    	div	cx		; AX = DX:AX / 10, DX = DX:AX % 10
   454 00002865 83F800                  	cmp	ax,0
   455 00002868 7403                    	je	.below10
   456 0000286A E8F3FF                  	call	.print_rec	; print number / 10 recursively
   457                                  .below10:
   458 0000286D 89D0                    	mov	ax,dx		; reminder is in DX
   459 0000286F E80200                  	call	print_digit	; print reminder
   460 00002872 5A                      	pop	dx
   461 00002873 C3                      	ret
   462                                  
   463                                  ;=========================================================================
   464                                  ; print_digit - print hexadecimal digit
   465                                  ; Input:
   466                                  ;	AL - bits 3...0 - digit to print (0...F)
   467                                  ; Output:
   468                                  ;	none
   469                                  ;-------------------------------------------------------------------------
   470                                  print_digit:
   471 00002874 50                      	push	ax
   472 00002875 53                      	push	bx
   473 00002876 240F                    	and	al,0Fh
   474 00002878 0430                    	add	al,'0'			; convert to ASCII
   475 0000287A 3C39                    	cmp	al,'9'			; less or equal 9?
   476 0000287C 7602                    	jna	.1
   477 0000287E 0407                    	add	al,'A'-'9'-1		; a hex digit
   478                                  .1:
   479 00002880 B40E                    	mov	ah,0Eh			; Int 10 function 0Eh - teletype output
   480 00002882 B307                    	mov	bl,07h			; just in case we're in graphic mode
   481 00002884 CD10                    	int	10h
   482 00002886 5B                      	pop	bx
   483 00002887 58                      	pop	ax
   484 00002888 C3                      	ret
   485                                  
   486                                  %ifdef EBDA_SIZE
   487                                  ;=========================================================================
   488                                  ; reserve_ebda - reserve EBDA (Extended BIOS Data Area) if using PS2_MOUSE
   489                                  ; Input:
   490                                  ;	AX = memory size in KiB
   491                                  ; Notes:
   492                                  ;	- Assumes that EBDA memory was cleaned
   493                                  ;	- Does not reserve EBDA if PS/2 auxiliary device is not detected
   494                                  ;-------------------------------------------------------------------------
   495                                  reserve_ebda:
   496                                  	push	ax
   497                                  	push	cx
   498                                  	test	word [equipment_list],equip_mouse
   499                                  	jz	.no_mouse
   500                                  	mov	ax,word [memory_size]	; get conventional memory size
   501                                  	sub	ax,EBDA_SIZE		; substract EBDA size
   502                                  	mov	word [memory_size],ax	; store new conventional memory size
   503                                  	mov	cl,6
   504                                  	shl	ax,cl			; convert to segment
   505                                  	mov	word [ebda_segment],ax	; store EBDA segment to BIOS variable
   506                                  	push	ds
   507                                  	mov	ds,ax
   508                                  	mov	ax,EBDA_SIZE
   509                                      	mov	byte [ebda_size],al	; store EBDA size to EBDA
   510                                  	pop	ds
   511                                  	push	si
   512                                  	mov	si,msg_ebda
   513                                  	call	print
   514                                  	call	print_dec
   515                                  	mov	si,msg_kib
   516                                  	call	print
   517                                  	pop	si
   518                                  .no_mouse:
   519                                  	pop	cx
   520                                  	pop	ax
   521                                  	ret
   522                                  %endif ; EBDA_SIZE
   523                                  
   524                                  ;=========================================================================
   525                                  ; print display type
   526                                  ;-------------------------------------------------------------------------
   527                                  print_display:
   528 00002889 BE[0D02]                	mov	si,msg_disp
   529 0000288C E887FF                  	call	print
   530 0000288F BE[2A02]                	mov	si,msg_disp_ega		; assume EGA or later
   531 00002892 833EA80000              	cmp	word [vga_table_ptr],0	; check if BIOS Video Save/Override
   532                                  					; Pointer Table address is initialized
   533 00002897 751D                    	jnz	.print_disp
   534 00002899 833EAA0000              	cmp	word [vga_table_ptr+2],0
   535 0000289E 7516                    	jnz	.print_disp
   536                                  					; Not an EGA/VGA - check equipment word
   537 000028A0 A01000                  	mov	al,byte [equipment_list] ; get equipment - low byte
   538 000028A3 2430                    	and	al,equip_video		; get video adapter type
   539 000028A5 BE[6502]                	mov	si,msg_disp_mda
   540 000028A8 3C30                    	cmp	al,equip_mono		; monochrome?
   541 000028AA 740A                    	jz	.print_disp
   542 000028AC BE[4902]                	mov	si,msg_disp_cga_80
   543 000028AF 3C20                    	cmp	al,equip_color_80	; CGA 80x25?
   544 000028B1 7403                    	jz	.print_disp
   545 000028B3 BE[5702]                	mov	si,msg_disp_cga_40	; Must be CGA 40x25
   546                                  .print_disp:
   547 000028B6 E85DFF                  	call	print
   548 000028B9 C3                      	ret
   549                                  
   550                                  %ifdef PS2_MOUSE
   551                                  
   552                                  ;=========================================================================
   553                                  ; print PS/2 mouse presence
   554                                  ;-------------------------------------------------------------------------
   555                                  
   556                                  print_mouse:
   557                                  	mov	si,msg_mouse
   558                                  	call	print
   559                                  	mov	si,msg_absent
   560                                  	test	byte [equipment_list],equip_mouse
   561                                  	jz	.print_mouse
   562                                  	mov	si,msg_present
   563                                  .print_mouse:
   564                                  	call	print
   565                                  	ret
   566                                  
   567                                  %endif ; PS2_MOUSE
   568                                  
   569                                  ;=========================================================================	
   570                                  ; interrupt_table - offsets only (BIOS segment is always 0F000h)
   571                                  ;-------------------------------------------------------------------------
   572                                  interrupt_table:
   573 000028BA [535F]                  	dw	int_dummy		; INT 00 - Divide by zero
   574 000028BC [535F]                  	dw	int_dummy		; INT 01 - Single step
   575 000028BE [C342]                  	dw	int_02			; INT 02 - Non-maskable interrupt
   576 000028C0 [535F]                  	dw	int_dummy		; INT 03 - Debugger breakpoint
   577 000028C2 [535F]                  	dw	int_dummy		; INT 04 - Integer overlow (into)
   578 000028C4 [545F]                  	dw	int_05			; INT 05 - BIOS Print Screen
   579 000028C6 [535F]                  	dw	int_dummy		; INT 06
   580 000028C8 [535F]                  	dw	int_dummy		; INT 07
   581 000028CA [A55E]                  	dw	int_08			; INT 08 - IRQ0 - Timer Channel 0
   582 000028CC [8749]                  	dw	int_09			; INT 09 - IRQ1 - Keyboard
   583 000028CE [235F]                  	dw	int_ignore		; INT 0A - IRQ2
   584 000028D0 [235F]                  	dw	int_ignore		; INT 0B - IRQ3
   585 000028D2 [235F]                  	dw	int_ignore		; INT 0C - IRQ4
   586 000028D4 [235F]                  	dw	int_ignore		; INT 0D - IRQ5
   587 000028D6 [574F]                  	dw	int_0E			; INT 0E - IRQ6 - Floppy
   588 000028D8 [235F]                  	dw	int_ignore		; INT 0F - IRQ7
   589 000028DA [6550]                  	dw	int_10			; INT 10 - BIOS Video Services
   590 000028DC [4D58]                  	dw	int_11			; INT 11 - BIOS Get Equipment List
   591 000028DE [4158]                  	dw	int_12			; INT 12 - BIOS Get Memory Size
   592 000028E0 [594C]                  	dw	int_13			; INT 13 - BIOS Floppy Disk Services
   593 000028E2 [2947]                  	dw	int_14			; INT 14 - BIOS Serial Communications
   594 000028E4 [5958]                  	dw	int_15			; INT 15 - BIOS Misc. System Services
   595 000028E6 [2E48]                  	dw	int_16			; INT 16 - BIOS Keyboard Services
   596 000028E8 [D24F]                  	dw	int_17			; INT 17 - BIOS Parallel Printer svc.
   597 000028EA [5043]                  	dw	int_18			; INT 18 - BIOS Start ROM BASIC
   598 000028EC [F246]                  	dw	int_19			; INT 19 - BIOS Boot the OS
   599 000028EE [6E5E]                  	dw	int_1A			; INT 1A - BIOS Time Services
   600 000028F0 [535F]                  	dw	int_dummy		; INT 1B - DOS Keyboard Break
   601 000028F2 [535F]                  	dw	int_dummy		; INT 1C - User Timer Tick
   602 000028F4 [A450]                  	dw	int_1D			; INT 1D - Video Parameters Table
   603 000028F6 [C74F]                  	dw	int_1E			; INT 1E - Floppy Parameters Table
   604                                  %ifndef MACHINE_XT
   605 000028F8 [390A]                  	dw	int_1F			; INT 1F - Font For Graphics Mode
   606                                  %else ; MACHINE_XT
   607                                  	dw	int_ignore
   608                                  %endif ; MACHINE_XT
   609                                  
   610                                  %ifdef SECOND_PIC
   611                                  interrupt_table2:
   612                                  	dw	int_70			; INT 70 - IRQ8 - RTC
   613                                  	dw	int_71			; INT 71 - IRQ9 - redirection
   614                                  	dw	int_ignore2		; INT 72 - IRQ10
   615                                  	dw	int_ignore2		; INT 73 - IRQ11
   616                                  %ifndef PS2_MOUSE
   617                                  	dw	int_ignore2		; INT 74 - IRQ12 - PS/2 mouse
   618                                  %else ; PS2_MOUSE
   619                                  	dw	int_74			; INT 74 - IRQ12 - PS/2 mouse
   620                                  %endif ; PS2_MOUSE
   621                                  	dw	int_75			; INT 75 - IRQ13 - FPU
   622                                  	dw	int_ignore2		; INT 76 - IRQ14
   623                                  	dw	int_ignore2		; INT 77 - IRQ15
   624                                  %endif ; SECOND_PIC
   625                                  
   626                                  ;=========================================================================
   627                                  ; cold_start, warm_start - BIOS POST (Power on Self Test) starts here
   628                                  ;-------------------------------------------------------------------------	
   629 000028FA FF<rep 1761h>           	setloc	0E05Bh		; POST Entry Point
   629          ******************       warning: Inserting 5985 bytes [-w+user]
   630                                  cold_start:
   631 0000405B B84000                  	mov	ax,biosdseg
   632 0000405E 8ED8                    	mov	ds,ax
   633 00004060 C70672000000            	mov	word [warm_boot],0	; indicate cold boot
   634                                  
   635                                  warm_start:
   636 00004066 FA                      	cli				; disable interrupts
   637 00004067 FC                      	cld				; clear direction flag
   638 00004068 B001                    	mov	al,e_cpu_test
   639 0000406A E680                    	out	post_reg,al		; POST start code
   640                                  
   641                                  ;-------------------------------------------------------------------------
   642                                  ; test CPU's FLAG register
   643                                  
   644 0000406C 31C0                    	xor	ax,ax			; AX = 0
   645 0000406E 724A                    	jb	cpu_fail
   646 00004070 7048                    	jo	cpu_fail
   647 00004072 7846                    	js	cpu_fail
   648 00004074 7544                    	jnz	cpu_fail
   649 00004076 7B42                    	jpo	cpu_fail
   650 00004078 83C001                  	add	ax,1			; AX = 1
   651 0000407B 743D                    	jz	cpu_fail
   652 0000407D 7A3B                    	jpe	cpu_fail
   653 0000407F 2D0280                  	sub	ax,8002h
   654 00004082 7836                    	js	cpu_fail
   655 00004084 40                      	inc	ax
   656 00004085 7133                    	jno	cpu_fail
   657 00004087 D1E0                    	shl	ax,1
   658 00004089 732F                    	jnb	cpu_fail
   659 0000408B 752D                    	jnz	cpu_fail
   660 0000408D D1E0                    	shl	ax,1
   661 0000408F 7229                    	jb	cpu_fail
   662                                  
   663                                  ;-------------------------------------------------------------------------
   664                                  ; Test CPU registers
   665                                  
   666 00004091 B8AAAA                  	mov	ax,0AAAAh
   667                                  .1:
   668 00004094 8ED8                    	mov	ds,ax
   669 00004096 8CDB                    	mov	bx,ds
   670 00004098 8EC3                    	mov	es,bx
   671 0000409A 8CC1                    	mov	cx,es
   672 0000409C 8ED1                    	mov	ss,cx
   673 0000409E 8CD2                    	mov	dx,ss
   674 000040A0 89D5                    	mov	bp,dx
   675 000040A2 89EC                    	mov	sp,bp
   676 000040A4 89E6                    	mov	si,sp
   677 000040A6 89F7                    	mov	di,si
   678 000040A8 81FFAAAA                	cmp	di,0AAAAh
   679 000040AC 7506                    	jnz	.2
   680 000040AE 89F8                    	mov	ax,di
   681 000040B0 F7D0                    	not	ax
   682 000040B2 EBE0                    	jmp	.1
   683                                  .2:
   684 000040B4 81FF5555                	cmp	di,5555h
   685 000040B8 741A                    	jz	cpu_ok
   686                                  
   687                                  cpu_fail:
   688 000040BA B052                    	mov	al,e_cpu_fail
   689 000040BC E680                    	out	post_reg,al
   690                                  
   691                                  ;-------------------------------------------------------------------------
   692                                  ; CPU error: continious beep - 400 Hz
   693                                  
   694 000040BE B0B6                    	mov	al,0B6h
   695 000040C0 E643                    	out	pit_ctl_reg,al		; PIT - channel 2 mode 3
   696 000040C2 B8A60B                  	mov	ax,pic_freq/400		; 400 Hz signal
   697 000040C5 E642                    	out	pit_ch2_reg,al
   698 000040C7 88E0                    	mov	al,ah
   699 000040C9 E642                    	out	pit_ch2_reg,al
   700 000040CB E461                    	in	al,ppi_pb_reg
   701 000040CD 0C03                    	or	al,3			; turn speaker on and enable
   702 000040CF E661                    	out	ppi_pb_reg,al		; PIT channel 2 to speaker
   703                                  
   704                                  .1:
   705 000040D1 F4                      	hlt
   706 000040D2 EBFD                    	jmp	.1
   707                                  
   708                                  ;-------------------------------------------------------------------------
   709                                  ; CPU test passed
   710                                  
   711                                  cpu_ok:
   712                                  
   713                                  ;-------------------------------------------------------------------------
   714                                  ; disable NMI, turbo mode, and video output on CGA and MDA
   715                                  
   716 000040D4 B002                    	mov	al,e_init_cfg
   717 000040D6 E680                    	out	post_reg,al
   718                                  
   719                                  %ifdef AT_NMI
   720                                  	mov	al,0Dh & nmi_disa_mask
   721                                  	out	rtc_addr_reg,al		; disable NMI
   722                                  	jmp	$+2
   723                                  	in	al,rtc_data_reg		; dummy read to keep RTC happy
   724                                  %else ; AT_NMI
   725 000040D8 B000                    	mov	al,nmi_disable
   726 000040DA E6A0                    	out	nmi_mask_reg,al		; disable NMI
   727                                  %endif ; AT_NMI
   728                                  
   729                                  %ifdef MACHINE_XI8088
   730                                  	mov	al,iochk_disable	; clear and disable ~IOCHK
   731                                  	out	ppi_pb_reg,al
   732                                  	mov	al,00h			; clear turbo bit
   733                                  	out	ppi_pb_reg,al		; and also turn off the speaker
   734                                  %endif ; MACHINE_XI8088
   735                                  
   736                                  %ifdef MACHINE_FE2010A
   737 000040DC B001                    	mov	al,fe_par_disable	; Disable parity checking
   738 000040DE E663                    	out	fe_config_reg,al	; FE2010A chipset configuration register
   739 000040E0 B0B0                    	mov	al,10110000b		; Clear keyboard, disable keyboard clock
   740                                  					; disable IOCHCK NMI, disable MB DRAM NMI
   741 000040E2 E661                    	out	ppi_pb_reg,al		; Disable parity and IOCHK
   742                                  %endif ; MACHINE_FE2010A
   743                                  
   744                                  %ifdef MACHINE_BOOK8088
   745                                  	mov	al,00h			; clear turbo bit
   746                                  	out	ppi_pb_reg,al		; and also turn off the speaker
   747                                  %endif ; MACHINE_BOOK8088
   748                                  
   749                                  %ifdef MACHINE_XT
   750                                  	mov	al,ppi_cwd_value	; PPI port A and port C inputs
   751                                  	out	ppi_cwd_reg,al		; PPI control word register
   752                                  	mov	al,10100101b		; Clear keyboard, disable keyboard clock
   753                                  					; disable IOCHCK NMI, enable MB DRAM NMI
   754                                  	out	ppi_pb_reg,al
   755                                  %endif ; MACHINE_XT
   756                                  
   757 000040E4 B000                    	mov	al,00h
   758 000040E6 BAD803                  	mov	dx,cga_mode_reg
   759 000040E9 EE                      	out	dx,al			; disable video output on CGA
   760 000040EA FEC0                    	inc	al
   761 000040EC BAB803                  	mov	dx,mda_mode_reg		; disable video output on MDA
   762 000040EF EE                      	out	dx,al			; and set MDA high-resolution mode bit
   763                                  
   764                                  ;-------------------------------------------------------------------------
   765                                  ; Initialize DMAC (8237)
   766                                   
   767 000040F0 B003                    	mov	al,e_init_dmac
   768 000040F2 E680                    	out	post_reg,al
   769 000040F4 E60D                     	out	0Dh,al			; DMA Master Clear register - reset DMA
   770                                  %ifdef MACHINE_XT
   771                                  					; set up DRAM refresh on DMA channel 0
   772                                  	mov	al,0ffh			; 16-bit memory refresh counter = 0FFFFh
   773                                  	out	dmac_ch0_count_reg,al	; write low byte
   774                                  	nop
   775                                  	out	dmac_ch0_count_reg,al	; write high byte
   776                                  	inc	ax			; al = 0
   777                                  	out	dmac_mask_reg,al	; enable DMA channel 0
   778                                  	mov	al,58h			; single mode, auto-init, read, channel 0
   779                                  %else ; MACHINE_XT
   780 000040F6 B040                     	mov	al,40h			; single mode, verify, channel 0
   781                                  %endif ; MACHINE_XT
   782 000040F8 E60B                     	out	dmac_mode_reg,al	; DMA Mode register
   783 000040FA B041                     	mov	al,41h			; single mode, verify, channel 1
   784 000040FC E60B                     	out	dmac_mode_reg,al	; DMA Mode register
   785 000040FE B042                     	mov	al,42h			; single mode, verify, channel 2
   786 00004100 E60B                     	out	dmac_mode_reg,al	; DMA Mode register
   787 00004102 B043                     	mov	al,43h			; single mode, verify, channel 3
   788 00004104 E60B                     	out	dmac_mode_reg,al	; DMA Mode register
   789 00004106 B000                     	mov	al,0			; DMA Command register bits:
   790                                   					; DACK active low, DREQ active high,
   791                                   					; late write, fixed priority,
   792                                   					; normal timing, controller enable
   793                                   					; channel 0 addr hold disable
   794                                   					; memory to memory disable
   795 00004108 E608                     	out	08h,al			; DMA Command register
   796 0000410A E681                     	out	81h,al			; DMA Page, channel 2
   797 0000410C E682                     	out	82h,al			; DMA Page, channel 3
   798 0000410E E683                     	out	83h,al			; DMA Page, channels 0,1
   799                                  
   800                                  ;-------------------------------------------------------------------------
   801                                  ; Test first 32 KiB (MIN_RAM_SIZE) of RAM
   802                                  
   803 00004110 B004                    	mov	al,e_low_ram_test
   804 00004112 E680                    	out	post_reg,al
   805 00004114 31F6                    	xor	si,si
   806 00004116 31FF                    	xor	di,di
   807 00004118 8EDF                    	mov	ds,di
   808 0000411A 8EC7                    	mov	es,di
   809 0000411C 8B167204                	mov	dx,word [warm_boot+biosdseg*16] ; save soft reset flag to DX
   810 00004120 B8AA55                  	mov	ax,55AAh		; first test pattern
   811 00004123 B90040                  	mov	cx,MIN_RAM_SIZE*512	; RAM size to test in words
   812 00004126 F3AB                        rep	stosw				; store test pattern
   813 00004128 B90040                  	mov	cx,MIN_RAM_SIZE*512	; RAM size to test in words
   814                                  .1:
   815 0000412B AD                      	lodsw
   816 0000412C 3DAA55                  	cmp	ax,55AAh		; compare to the test pattern
   817 0000412F 7524                    	jne	low_ram_fail
   818 00004131 E2F8                    	loop	.1
   819 00004133 31F6                    	xor	si,si
   820 00004135 31FF                    	xor	di,di
   821 00004137 B855AA                  	mov	ax,0AA55h		; second test pattern
   822 0000413A B90040                  	mov	cx,MIN_RAM_SIZE*512	; RAM size to test in words
   823 0000413D F3AB                        rep stosw				; store test pattern
   824 0000413F B90040                  	mov	cx,MIN_RAM_SIZE*512	; RAM size to test in words
   825                                  .2:
   826 00004142 AD                      	lodsw
   827 00004143 3D55AA                  	cmp	ax,0AA55h		; compare to the test pattern
   828 00004146 750D                    	jne	low_ram_fail
   829 00004148 E2F8                    	loop	.2
   830 0000414A 31FF                    	xor	di,di
   831 0000414C 31C0                    	xor	ax,ax			; zero
   832 0000414E B90040                  	mov	cx,MIN_RAM_SIZE*512	; RAM size to test in words
   833 00004151 F3AB                        rep stosw				; zero the memory
   834 00004153 EB29                    	jmp	low_ram_ok		; test passed
   835                                  
   836                                  low_ram_fail:
   837 00004155 B054                    	mov	al,e_low_ram_fail	; test failed
   838 00004157 E680                    	out	post_reg,al
   839                                  
   840                                  ;-------------------------------------------------------------------------
   841                                  ;  Low memory error: beep - pause - beep - pause ... - 400 Hz
   842                                  
   843 00004159 B0B6                    	mov	al,0B6h
   844 0000415B E643                    	out	pit_ctl_reg,al		; PIT - channel 2 mode 3
   845 0000415D B8A60B                  	mov	ax,pic_freq/400		; 400 Hz signal
   846 00004160 E642                    	out	pit_ch2_reg,al
   847 00004162 88E0                    	mov	al,ah
   848 00004164 E642                    	out	pit_ch2_reg,al
   849 00004166 E461                    	in	al,ppi_pb_reg
   850                                  .1:
   851 00004168 0C03                    	or	al,3			; turn speaker on and enable
   852 0000416A E661                    	out	ppi_pb_reg,al		; PIT channel 2 to speaker
   853 0000416C B90000                  	mov	cx,0
   854                                  .2:
   855 0000416F 90                      	nop
   856 00004170 E2FD                    	loop	.2
   857 00004172 24FC                    	and	al,0FCh			; turn of speaker
   858 00004174 E661                    	out	ppi_pb_reg,al
   859 00004176 B90000                  	mov	cx,0
   860                                  .3:
   861 00004179 90                      	nop
   862 0000417A E2FD                    	loop	.3
   863 0000417C EBEA                    	jmp	.1
   864                                  
   865                                  ;-------------------------------------------------------------------------
   866                                  ; Low memory test passed
   867                                  
   868                                  low_ram_ok:
   869 0000417E 89167204                	mov	word [warm_boot+biosdseg*16],dx ; restore soft reset flag
   870                                  
   871                                  ;-------------------------------------------------------------------------
   872                                  ; Set up stack - using upper 256 bytes of interrupt table
   873                                  
   874 00004182 B83000                  	mov	ax,0030h
   875 00004185 8ED0                    	mov	ss,ax
   876 00004187 BC0001                  	mov	sp,0100h
   877                                  
   878                                  ;-------------------------------------------------------------------------
   879                                  ; Initialize interrupt table
   880                                  
   881 0000418A B005                    	mov     al,e_int_table
   882 0000418C E680                    	out	post_reg,al
   883 0000418E 0E                      	push	cs
   884 0000418F 1F                      	pop	ds
   885 00004190 31FF                    	xor	di,di
   886 00004192 8EC7                    	mov	es,di
   887 00004194 BE[BA28]                	mov	si,interrupt_table
   888 00004197 B92000                  	mov	cx,0020h		; 32 Interrupt vectors
   889 0000419A B800F0                  	mov	ax,bioscseg
   890                                  .1:
   891 0000419D A5                      	movsw				; copy ISR address (offset part)
   892 0000419E AB                      	stosw				; store segment part
   893 0000419F E2FC                    	loop	.1
   894                                  %ifdef SECOND_PIC
   895                                  	mov	di,70h*4		; starting from IRQ 70
   896                                  	mov	si,interrupt_table2
   897                                  	mov	cx,8			; 8 Interrupt vectors
   898                                  .2:
   899                                  	movsw				; copy ISR address (offset part)
   900                                  	stosw				; store segment part
   901                                  	loop	.2
   902                                  %endif ; SECOND_PIC
   903                                  
   904                                  ;-------------------------------------------------------------------------
   905                                  ; set DS to BIOS data area
   906                                  
   907 000041A1 B84000                  	mov	ax,biosdseg		; DS = BIOS data area
   908 000041A4 8ED8                    	mov	ds,ax
   909                                  
   910                                  ;-------------------------------------------------------------------------
   911                                  ; Initialize PIT (8254 timer)
   912                                  
   913 000041A6 B036                    	mov	al,36h			; channel 0, LSB & MSB, mode 3, binary
   914 000041A8 E643                    	out	pit_ctl_reg,al
   915 000041AA B000                    	mov	al,0
   916 000041AC E640                    	out	pit_ch0_reg,al
   917 000041AE E640                    	out	pit_ch0_reg,al
   918 000041B0 B054                    	mov	al,54h			; channel 1, LSB only, mode 2, binary
   919 000041B2 E643                    	out	pit_ctl_reg,al		; used for DRAM refresh on IBM PC/XT/AT
   920 000041B4 B012                    	mov	al,12h			; or for delays (using port_b, bit 4)
   921 000041B6 E641                    	out	pit_ch1_reg,al		; pulse every 15ms
   922                                  
   923                                  ;-------------------------------------------------------------------------
   924                                  ; Play "power on" sound - also tests PIT functionality
   925                                  
   926 000041B8 B006                    	mov     al,e_pit_init
   927 000041BA E680                    	out	post_reg,al
   928 000041BC E852E4                  	call	sound
   929                                  
   930                                  ;-------------------------------------------------------------------------
   931                                  ; Initialize PIC (8259)
   932                                  
   933 000041BF B007                    	mov	al,e_pic_init
   934 000041C1 E680                    	out	post_reg,al
   935                                  %ifdef SECOND_PIC
   936                                  	mov	al,11h			; ICW1 - edge triggered, cascade, ICW4
   937                                  	out	pic1_reg0,al
   938                                  	out	pic2_reg0,al
   939                                  	mov	al,8			; ICW2 - interrupt vector offset = 8
   940                                  	out	pic1_reg1,al
   941                                  	mov	al,70h			; ICW2 - interrupt vector offset = 70h
   942                                  	out	pic2_reg1,al
   943                                  	mov	al,4			; ICW3 - slave is connected to IR2
   944                                  	out	pic1_reg1,al
   945                                  	mov	al,2			; ICW3 - slave ID = 2 (IR2)
   946                                  	out	pic2_reg1,al
   947                                  	mov	al,1			; ICW4 - 8086/8088
   948                                  	out	pic1_reg1,al
   949                                  	out	pic2_reg1,al
   950                                  %else
   951 000041C3 B013                    	mov	al,13h			; ICW1 - edge triggered, single, ICW4
   952 000041C5 E620                    	out	pic1_reg0,al
   953 000041C7 B008                    	mov	al,8			; ICW2 - interrupt vector offset = 8
   954 000041C9 E621                    	out	pic1_reg1,al
   955 000041CB B009                    	mov	al,9			; ICW4 - buffered mode, 8086/8088
   956 000041CD E621                    	out	pic1_reg1,al
   957                                  %endif ; SECOND_PIC
   958                                  
   959                                  ;-------------------------------------------------------------------------
   960                                  ; initialize keyboard controller (8242), keyboard and PS/2 auxiliary device
   961                                  
   962 000041CF B008                    	mov	al,e_kbd_init
   963 000041D1 E680                    	out	post_reg,al
   964                                  %ifdef AT_KEYBOARD
   965                                  	call	kbc_init
   966                                  %else ; AT_KEYBOARD
   967                                  %ifndef MACHINE_BOOK8088
   968 000041D3 E461                    	in	al,ppi_pb_reg
   969 000041D5 243F                    	and	al,00111111b		; set keyboard clock low
   970 000041D7 E661                    	out	ppi_pb_reg,al
   971 000041D9 B95629                  	mov	cx,10582		; hold clock low for 20 ms
   972                                  .kbd_reset_wait:
   973 000041DC E2FE                    	loop	.kbd_reset_wait
   974 000041DE 0CC0                    	or	al,11000000b		; set keyboard clear bit, enable clock
   975 000041E0 E661                    	out	ppi_pb_reg,al
   976 000041E2 247F                    	and	al,01111111b		; unset keyboard clear bit
   977 000041E4 E661                    	out	ppi_pb_reg,al
   978                                  %endif ; MACHINE_BOOK8088
   979 000041E6 B9E803                  	mov	cx,1000
   980                                  .kbd_flush:
   981 000041E9 B401                    	mov 	ah,01h
   982 000041EB CD16                    	int	16h
   983 000041ED 7404                    	jz	.kbd_no_key
   984 000041EF B400                    	mov	ah,00h
   985 000041F1 CD16                    	int	16h
   986                                  .kbd_no_key:
   987 000041F3 E2F4                    	loop	.kbd_flush
   988                                  
   989                                  %endif ; AT_KEYBOARD
   990                                  
   991 000041F5 E8C309                  	call	kbd_buffer_init		; setup keyboard buffer
   992                                  
   993                                  ;-------------------------------------------------------------------------
   994                                  ; enable interrupts
   995                                  
   996 000041F8 B009                    	mov	al,e_int_ena
   997 000041FA E680                    	out	post_reg,al
   998                                  %ifdef SECOND_PIC
   999                                  	mov	al,0B8h		; OSW1: unmask timer, keyboard, IRQ2 and FDC
  1000                                  	out	pic1_reg1,al
  1001                                  %ifndef PS2_MOUSE
  1002                                  	mov	al,0FDh		; OSW1: unmask IRQ9
  1003                                  %else
  1004                                  	mov	al,0EDh		; OSW1: unmask IRQ9 and IRQ12
  1005                                  %endif ; PS2_MOUSE
  1006                                  	out	pic2_reg1,al
  1007                                  %else
  1008 000041FC B0BC                    	mov	al,0BCh		; OSW1: unmask timer, keyboard and FDC
  1009 000041FE E621                    	out	pic1_reg1,al
  1010                                  %endif ; SECOND_PIC
  1011 00004200 FB                      	sti
  1012                                  
  1013 00004201 B080                    	mov	al,nmi_enable
  1014 00004203 E6A0                    	out	nmi_mask_reg,al	; enable NMIs
  1015                                  
  1016                                  %ifdef MACHINE_FE2010A or MACHINE_XT
  1017                                  ;-------------------------------------------------------------------------
  1018                                  ; Read video mode switches into equipment_list
  1019 00004205 E461                    	in	al,ppi_pb_reg
  1020                                  %ifdef MACHINE_FE2010A
  1021 00004207 24FD                    	and	al,0FDh		; clear switch select bit - select SW5-SW8
  1022                                  %endif ; MACHINE_FE2010A
  1023                                  %ifdef MACHINE_XT
  1024                                  	or	al,08h		; set switch select bit - select SW5-SW8
  1025                                  %endif ; MACHINE_XT
  1026 00004209 E661                    	out	ppi_pb_reg,al
  1027 0000420B E462                    	in	al,ppi_pc_reg	; read switches SW5-SW8
  1028 0000420D 2403                    	and	al,03h		; video mode is in SW5 and SW6
  1029 0000420F B104                    	mov	cl,4
  1030 00004211 D2E0                    	shl	al,cl		; move video mode to bits 5-4
  1031 00004213 08061000                	or	[equipment_list],al
  1032                                  %endif ; MACHINE_FE2010A or MACHINE_XT
  1033                                  %ifdef MACHINE_BOOK8088
  1034                                  	or	byte [equipment_list],equip_color_80 ; built-in CGA
  1035                                  %endif ; MACHINE_BOOK8088
  1036                                  ; 
  1037                                  ;-------------------------------------------------------------------------
  1038                                  ; look for video BIOS, initialize it if present
  1039                                  
  1040 00004217 B010                    	mov	al,e_vid_bios_scan
  1041 00004219 E680                    	out	post_reg,al
  1042 0000421B BA00C0                  	mov	dx,0C000h
  1043 0000421E BB00C8                  	mov	bx,0C800h
  1044 00004221 E87216                  	call	extension_scan
  1045 00004224 833E670000              	cmp	word [67h],0
  1046 00004229 740F                    	jz	.no_video_bios
  1047 0000422B B011                    	mov	al,e_vid_bios_init
  1048 0000422D E680                    	out	post_reg,al
  1049 0000422F FF1E6700                	call	far [67h]
  1050 00004233 B84000                  	mov	ax,biosdseg		; DS = BIOS data area
  1051 00004236 8ED8                    	mov	ds,ax
  1052                                  ; set video bits to 00 - EGA or later (Video adapter with BIOS)		
  1053                                  ;	and	word [equipment_list],~equip_video
  1054 00004238 EB1F                    	jmp	.video_initialized
  1055                                  
  1056                                  .no_video_bios:
  1057 0000423A B012                    	mov	al,e_vid_no_bios
  1058 0000423C E680                    	out	post_reg,al
  1059 0000423E 8A261000                	mov	ah,byte [equipment_list] ; get equipment - low byte
  1060 00004242 80E430                  	and	ah,equip_video		; get video adapter type
  1061 00004245 B007                    	mov	al,07h			; monochrome 80x25 mode
  1062 00004247 80FC30                  	cmp	ah,equip_mono		; monochrome?
  1063 0000424A 7409                    	jz	.set_mode
  1064 0000424C B003                    	mov	al,03h			; color 80x25 mode
  1065 0000424E 80FC20                  	cmp	ah,equip_color_80	; 80x25 color?
  1066 00004251 7402                    	jz	.set_mode
  1067 00004253 B001                    	mov	al,01h			; color 40x24 mode
  1068                                  
  1069                                  .set_mode:
  1070 00004255 B400                    	mov	ah,00h			; INT 10, AH=00 - Set video mode
  1071 00004257 CD10                    	int	10h
  1072                                  
  1073                                  .video_initialized:
  1074                                  
  1075                                  ;-------------------------------------------------------------------------
  1076                                  ; print the copyright message
  1077                                  
  1078 00004259 BE[0000]                	mov	si,msg_copyright
  1079 0000425C E8B7E5                  	call	print
  1080                                  
  1081                                  %ifdef AT_RTC
  1082                                  
  1083                                  ;-------------------------------------------------------------------------
  1084                                  ; Initialize RTC / NVRAM
  1085                                  ; Read equipment byte from CMOS and set it in BIOS data area
  1086 0000425F E860CC                  	call	rtc_init
  1087                                  
  1088                                  %endif ; AT_RTC
  1089                                  
  1090                                  %ifdef BIOS_SETUP
  1091 00004262 BE[6004]                	mov	si,msg_setup		; print setup prompt
  1092 00004265 E8AEE5                  	call	print
  1093                                  %endif ; BIOS_SETUP
  1094                                  
  1095                                  
  1096                                  ;-------------------------------------------------------------------------
  1097                                  ; detect and print availability of various equipment
  1098                                  
  1099 00004268 E8FCE3                  	call	detect_cpu		; detect and print CPU type
  1100 0000426B E8A1E4                  	call	detect_fpu		; detect and print FPU presence
  1101                                  %ifdef MACHINE_FE2010A
  1102 0000426E E8E3E4                  	call	detect_chipset		; detect and print chipset type
  1103                                  %endif ; MACHINE_FE2010A
  1104                                  %ifdef AT_RTC
  1105 00004271 E8B8CC                  	call	print_rtc		; print current RTC time
  1106                                  %endif ; AT_RTC
  1107 00004274 E812E6                  	call	print_display		; print display type
  1108                                  %ifdef PS2_MOUSE
  1109                                  	call	print_mouse		; print mouse presence
  1110                                  %endif ; PS2_MOUSE
  1111 00004277 E83DE2                  	call	detect_serial		; detect serial ports and print findings
  1112 0000427A E8F0E2                  	call	detect_parallel		; detect parallel ports and print
  1113                                  					; findings
  1114 0000427D E8F3DC                  	call	detect_floppy		; detect floppy drive types
  1115 00004280 E827DD                  	call	print_floppy		; print floppy drive types
  1116                                  
  1117 00004283 E86615                  	call	detect_ram		; detect RAM, get RAM size in AX
  1118 00004286 E8D116                  	call	test_ram		; test RAM, get tested RAM size in AX
  1119                                  
  1120 00004289 BE[A103]                	mov	si,msg_ram_total
  1121 0000428C E887E5                  	call	print
  1122 0000428F E8C1E5                  	call	print_dec		; print RAM size
  1123 00004292 BE[BF03]                	mov	si,msg_kib
  1124 00004295 E87EE5                  	call	print
  1125                                  
  1126                                  ; FE2010A - Configure chipset according to detected equipment
  1127                                  %ifdef MACHINE_FE2010A
  1128                                  ; Write settings for emulated DIP switches
  1129 00004298 A01000                  	mov	al,byte [equipment_list] ; switches are in low byte of equipment
  1130 0000429B 24CE                    	and	al,0CEh			; keep floppy, memory size, and FPU bits
  1131 0000429D E662                    	out	fe_control_reg,al
  1132                                  ; Enable FPU NMI if needed, and lock chipset configuration
  1133 0000429F 2402                    	and	al,equip_fpu		; enable NMI if the FPU is installed
  1134 000042A1 0C08                    	or	al,fe_config_lock	; set lock chipset configuration bit
  1135 000042A3 E663                    	out	fe_config_reg,al
  1136                                  %endif ; MACHINE_FE2010A
  1137                                  
  1138                                  %ifdef EBDA_SIZE
  1139                                  	call	reserve_ebda		; reserve EBDA if needed
  1140                                  
  1141                                  	mov	si,msg_ram_avail
  1142                                  	call	print
  1143                                  	mov	ax,word [memory_size]
  1144                                  	call	print_dec		; print remaining RAM size
  1145                                  	mov	si,msg_kib
  1146                                  	call	print
  1147                                  %endif ; EBDA_SIZE
  1148                                  
  1149 000042A5 E8F214                  	call	detect_rom_ext		; detect and initialize extension ROMs
  1150                                  
  1151 000042A8 E939E5                  	jmp boot_os
  1152                                  
  1153                                  ;=========================================================================
  1154                                  ; int_02 - NMI
  1155                                  ; Note: Xi 8088 only implements IOCHK NMI, system board parity is not
  1156                                  ;	implemented
  1157                                  ;-------------------------------------------------------------------------
  1158 000042AB FF<rep 18h>             	setloc	0E2C3h			; NMI Entry Point
  1158          ******************       warning: Inserting 24 bytes [-w+user]
  1159                                  int_02:
  1160 000042C3 50                      	push	ax
  1161                                  %ifdef AT_NMI
  1162                                  	mov	al,0Dh & nmi_disa_mask
  1163                                  	call	rtc_read		; disable NMI
  1164                                  %else
  1165 000042C4 B000                    	mov	al,nmi_disable
  1166 000042C6 E6A0                    	out	nmi_mask_reg,al
  1167                                  %endif ; AT_NMI
  1168 000042C8 E461                    	in	al,ppi_pb_reg		; read Port B
  1169 000042CA 88C4                    	mov	ah,al
  1170 000042CC 0C08                    	or	al,iochk_disable	; clear and disable ~IOCHK
  1171 000042CE E661                    	out	ppi_pb_reg,al
  1172 000042D0 A840                    	test	al,iochk_status
  1173 000042D2 7506                    	jnz	.iochk_nmi
  1174 000042D4 88E0                    	mov	al,ah
  1175 000042D6 E661                    	out	ppi_pb_reg,al		; restore original bits
  1176 000042D8 EB23                    	jmp	.exit
  1177                                  
  1178                                  .iochk_nmi:
  1179 000042DA 56                      	push	si
  1180 000042DB BE[FF42]                	mov	si,msg_iochk_nmi
  1181 000042DE E835E5                  	call	print
  1182 000042E1 5E                      	pop	si
  1183                                  .1:
  1184 000042E2 B400                    	mov	ah,0h
  1185 000042E4 CD16                    	int	16h
  1186 000042E6 0C20                    	or	al,20h			; convert to lower case
  1187 000042E8 3C64                    	cmp	al,'d'
  1188 000042EA 7411                    	je	.exit			; leave NMIs disabled and exit
  1189 000042EC 3C69                    	cmp	al,'i'
  1190 000042EE 7409                    	je	.ignore			; enable NMIs and exit
  1191 000042F0 3C72                    	cmp	al,'r'
  1192 000042F2 7503E964FD              	je	cold_start
  1193 000042F7 EBE9                    	jmp	.1
  1194                                  .ignore:
  1195                                  %ifdef AT_NMI
  1196                                  	mov	al,0Dh | nmi_enable
  1197                                  	call	rtc_read		; enable NMI
  1198                                  %else
  1199 000042F9 B080                    	mov	al,nmi_enable
  1200 000042FB E6A0                    	out	nmi_mask_reg,al
  1201                                  %endif ; AT_NMI
  1202                                  .exit:
  1203 000042FD 58                      	pop	ax
  1204 000042FE CF                      	iret
  1205                                  
  1206                                  msg_iochk_nmi:
  1207 000042FF 494F43484B204E4D49-     	db	"IOCHK NMI detected. Type 'i' to ignore, 'd' to disable NMIs, or 'r' to reboot."
  1207 00004308 206465746563746564-
  1207 00004311 2E2054797065202769-
  1207 0000431A 2720746F2069676E6F-
  1207 00004323 72652C202764272074-
  1207 0000432C 6F2064697361626C65-
  1207 00004335 204E4D49732C206F72-
  1207 0000433E 2027722720746F2072-
  1207 00004347 65626F6F742E       
  1208 0000434D 0D0A00                  	db	0Dh, 0Ah, 00h
  1209                                  
  1210                                  ;=========================================================================
  1211                                  ; int_18 - execute ROM BASIC
  1212                                  ; Note:
  1213                                  ;	Prints an error message since we don't have ROM BASIC
  1214                                  ;-------------------------------------------------------------------------
  1215                                  int_18:
  1216 00004350 BE[F303]                	mov	si,msg_no_basic
  1217 00004353 E8C0E4                  	call	print
  1218                                  .1:
  1219 00004356 F4                      	hlt
  1220 00004357 EBFD                    	jmp	.1
  1221                                  
  1222                                  ;=========================================================================
  1223                                  ; int_19 - load and execute the boot sector
  1224                                  ;-------------------------------------------------------------------------
  1225 00004359 FF<rep 399h>            	setloc	0E6F2h			; INT 19 Entry Point
  1225          ******************       warning: Inserting 921 bytes [-w+user]
  1226                                  int_19:
  1227 000046F2 E9F311                  	jmp	ipl
  1228                                  
  1229                                  ;=========================================================================
  1230                                  ; configuration data table
  1231                                  ;-------------------------------------------------------------------------
  1232                                  	setloc	0E6F5h
  1233                                  config_table:
  1234 000046F5 0800                    	dw	.size			; bytes 0 and 1: size of the table
  1235                                  .bytes:
  1236 000046F7 FE                      	db	MODEL_BYTE		; byte 2: model
  1237 000046F8 00                      	db	00h			; byte 3: submodel = 0
  1238 000046F9 00                      	db	00h			; byte 4: release = 0
  1239                                  %ifdef SECOND_PIC
  1240                                  %ifdef AT_RTC
  1241                                  	db	01110000b		; byte 5: feature byte 1
  1242                                  ;		|||||||`-- system has dual bus (ISA and MCA)
  1243                                  ;		||||||`-- bus is Micro Channel instead of ISA
  1244                                  ;		|||||`-- extended BIOS area allocated (usually on top of RAM)
  1245                                  ;		||||`-- wait for external event (INT 15h/AH=41h) supported
  1246                                  ;		|||`-- INT 15h/AH=4Fh called upon INT 09h
  1247                                  ;		||`-- real time clock installed
  1248                                  ;		|`-- 2nd interrupt controller installed
  1249                                  ;		`-- DMA channel 3 used by hard disk BIOS
  1250                                  %else ; AT_RTC
  1251                                  	db	01010000b		; byte 5: feature byte 1
  1252                                  ;		|||||||`-- system has dual bus (ISA and MCA)
  1253                                  ;		||||||`-- bus is Micro Channel instead of ISA
  1254                                  ;		|||||`-- extended BIOS area allocated (usually on top of RAM)
  1255                                  ;		||||`-- wait for external event (INT 15h/AH=41h) supported
  1256                                  ;		|||`-- INT 15h/AH=4Fh called upon INT 09h
  1257                                  ;		||`-- real time clock installed
  1258                                  ;		|`-- 2nd interrupt controller installed
  1259                                  ;		`-- DMA channel 3 used by hard disk BIOS
  1260                                  %endif ; AT_RTC
  1261                                  %else ; SECOND_PIC
  1262                                  %ifdef AT_RTC
  1263 000046FA 20                      	db	00100000b		; byte 5: feature byte 1
  1264                                  ;		|||||||`-- system has dual bus (ISA and MCA)
  1265                                  ;		||||||`-- bus is Micro Channel instead of ISA
  1266                                  ;		|||||`-- extended BIOS area allocated (usually on top of RAM)
  1267                                  ;		||||`-- wait for external event (INT 15h/AH=41h) supported
  1268                                  ;		|||`-- INT 15h/AH=4Fh called upon INT 09h
  1269                                  ;		||`-- real time clock installed
  1270                                  ;		|`-- 2nd interrupt controller installed
  1271                                  ;		`-- DMA channel 3 used by hard disk BIOS
  1272                                  %else ; AT_RTC
  1273                                  	db	00000000b		; byte 5: feature byte 1
  1274                                  ;		|||||||`-- system has dual bus (ISA and MCA)
  1275                                  ;		||||||`-- bus is Micro Channel instead of ISA
  1276                                  ;		|||||`-- extended BIOS area allocated (usually on top of RAM)
  1277                                  ;		||||`-- wait for external event (INT 15h/AH=41h) supported
  1278                                  ;		|||`-- INT 15h/AH=4Fh called upon INT 09h
  1279                                  ;		||`-- real time clock installed
  1280                                  ;		|`-- 2nd interrupt controller installed
  1281                                  ;		`-- DMA channel 3 used by hard disk BIOS
  1282                                  %endif ; AT_RTC
  1283                                  %endif ; SECOND_PIC
  1284 000046FB 00                      	db	00h			; byte 6: feature byte 2
  1285 000046FC 00                      	db	00h			; byte 7: feature byte 3
  1286 000046FD 00                      	db	00h			; byte 8: feature byte 4
  1287 000046FE 00                      	db	00h			; byte 9: feature byte 5
  1288                                  .size	equ	$-.bytes
  1289                                  
  1290                                  ;=========================================================================
  1291                                  ; Includes with fixed entry points (for IBM compatibility)
  1292                                  ;-------------------------------------------------------------------------
  1293                                  
  1294                                  %include	"serial2.inc"		; INT 14 - BIOS Serial Communications
  1295                              <1> ;========================================================================
  1296                              <1> ; serial2.inc -  BIOS Serial Port Communication Services (part 2 of 2)
  1297                              <1> ;       INT 14h, function AH=00h
  1298                              <1> ;       INT 14h, function AH=03h
  1299                              <1> ;       INT 14h, function AH=04h
  1300                              <1> ;       INT 14h, function AH=05h
  1301                              <1> ;	- see serial1.inc for other INT 14h functions
  1302                              <1> ;-------------------------------------------------------------------------
  1303                              <1> ;
  1304                              <1> ; Compiles with NASM 2.13.02, might work with other versions
  1305                              <1> ;
  1306                              <1> ; Copyright (C) 2010 - 2023 Sergey Kiselev.
  1307                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
  1308                              <1> ;
  1309                              <1> ; This program is free software: you can redistribute it and/or modify
  1310                              <1> ; it under the terms of the GNU General Public License as published by
  1311                              <1> ; the Free Software Foundation, either version 3 of the License, or
  1312                              <1> ; (at your option) any later version.
  1313                              <1> ;
  1314                              <1> ; This program is distributed in the hope that it will be useful,
  1315                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  1316                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  1317                              <1> ; GNU General Public License for more details.
  1318                              <1> ;
  1319                              <1> ; You should have received a copy of the GNU General Public License
  1320                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  1321                              <1> ;
  1322                              <1> ;=========================================================================
  1323                              <1> 
  1324                              <1> ;=========================================================================
  1325                              <1> ; int_14 - BIOS Serial Port Communication Services
  1326                              <1> ;-------------------------------------------------------------------------
  1327 000046FF FF<rep 2Ah>         <1> 	setloc	0E729h			; INT 14 Entry Point
  1327          ******************  <1>  warning: Inserting 42 bytes [-w+user]
  1328                              <1> int_14:
  1329 00004729 FB                  <1> 	sti
  1330 0000472A 51                  <1> 	push	cx
  1331 0000472B 52                  <1> 	push	dx
  1332 0000472C 56                  <1> 	push	si
  1333 0000472D 1E                  <1> 	push	ds
  1334 0000472E 53                  <1> 	push	bx
  1335 0000472F BB4000              <1> 	mov	bx,biosdseg
  1336 00004732 8EDB                <1> 	mov	ds,bx
  1337 00004734 80FC06              <1> 	cmp	ah,.max/2
  1338 00004737 732B                <1> 	jae	int_14_error		; invalid function number specified
  1339 00004739 83FA04              <1> 	cmp	dx,num_serial
  1340 0000473C 7326                <1> 	jae	int_14_error		; invalid port number specified
  1341 0000473E BE7C00              <1> 	mov	si,serial_timeout	; serial port timeout setting in BDA
  1342 00004741 01D6                <1> 	add	si,dx			; [SI] = timeout for the selected port
  1343 00004743 89D3                <1> 	mov	bx,dx
  1344 00004745 D1E3                <1> 	shl	bx,1
  1345 00004747 8B17                <1> 	mov	dx,word [equip_serial+bx] ; DX = serial port address
  1346 00004749 09D2                <1> 	or	dx,dx
  1347 0000474B 7417                <1> 	jz	int_14_error		; specified port is not installed
  1348 0000474D B700                <1> 	mov	bh,0
  1349 0000474F 88E3                <1> 	mov	bl,ah
  1350 00004751 D1E3                <1> 	shl	bx,1
  1351 00004753 2EFFA7[5847]        <1>     cs	jmp	near [.dispatch+bx]
  1352                              <1> .dispatch:
  1353 00004758 [6C47]              <1> 	dw	int_14_fn00
  1354 0000475A [5824]              <1> 	dw	int_14_fn01
  1355 0000475C [7324]              <1> 	dw	int_14_fn02
  1356 0000475E [A147]              <1> 	dw	int_14_fn03
  1357 00004760 [AB47]              <1> 	dw	int_14_fn04
  1358 00004762 [0548]              <1> 	dw	int_14_fn05
  1359                              <1> .max	equ	$-.dispatch
  1360                              <1> 
  1361                              <1> int_14_error:
  1362 00004764 31C0                <1> 	xor	ax,ax
  1363                              <1> 
  1364                              <1> int_14_exit:
  1365 00004766 5B                  <1> 	pop	bx
  1366 00004767 1F                  <1> 	pop	ds
  1367 00004768 5E                  <1> 	pop	si
  1368 00004769 5A                  <1> 	pop	dx
  1369 0000476A 59                  <1> 	pop	cx
  1370 0000476B CF                  <1> 	iret
  1371                              <1> 
  1372                              <1> ;=========================================================================
  1373                              <1> ; int_14_fn00 - Initialize serial port
  1374                              <1> ; Input:
  1375                              <1> ;	AH = 0 - function 00h - initialize serial port
  1376                              <1> ;	AL - initialization parameters
  1377                              <1> ;		bit 1,0	= 10	- 7 data bits
  1378                              <1> ;			= 11	- 8 data bits
  1379                              <1> ;		bit 2	= 0	- 1 stop bit
  1380                              <1> ;			= 1	- 2 stop bits
  1381                              <1> ;		bit 3	= 0	- parity disable
  1382                              <1> ;			= 1	- parity enable
  1383                              <1> ;		bit 4	= 0	- odd parity (if parity enabled)
  1384                              <1> ;			= 1	- even parity (if parity enabled)
  1385                              <1> ;		bit 7-5 = 000	- 110 bps
  1386                              <1> ;			= 001	- 150 bps
  1387                              <1> ;			= 010	- 300 bps
  1388                              <1> ;			= 011	- 600 bps
  1389                              <1> ;			= 100	- 1200 bps
  1390                              <1> ;			= 101	- 2400 bps
  1391                              <1> ;			= 110	- 4800 bps
  1392                              <1> ;			= 111	- 9600 bps
  1393                              <1> ;	DX = serial port number (0-3)
  1394                              <1> ; Output:
  1395                              <1> ;	AL = modem status
  1396                              <1> ;		bit 0	= 1	- delta clear to send
  1397                              <1> ;		bit 1	= 1	- delta data set ready
  1398                              <1> ;		bit 2	= 1	- trailing edge ring indicator
  1399                              <1> ;		bit 3	= 1	- delta data carrier detect
  1400                              <1> ;		bit 4	= 1	- clear to send
  1401                              <1> ;		bit 5	= 1	- data set ready
  1402                              <1> ;		bit 6	= 1	- ring indicator
  1403                              <1> ;		bit 7	= 1	- data carrier detect
  1404                              <1> ;	AH = line status
  1405                              <1> ;		bit 0	= 1	- data ready
  1406                              <1> ;		bit 1	= 1	- overrun error
  1407                              <1> ;		bit 2	= 1	- parity error
  1408                              <1> ;		bit 3	= 1	- framing error
  1409                              <1> ;		bit 4	= 1	- break interrupt
  1410                              <1> ;		bit 5	= 1	- transmitter holding register
  1411                              <1> ;		bit 6	= 1	- transmitter empty
  1412                              <1> ;		bit 7	= 1	- error in RCVR FIFO
  1413                              <1> ;-------------------------------------------------------------------------
  1414                              <1> int_14_fn00:
  1415 0000476C 88C4                <1> 	mov	ah,al			; save AL to AH
  1416 0000476E 83C203              <1> 	add	dx,uart_lcr_reg		; DX = UART LCR address
  1417 00004771 B080                <1> 	mov	al,uart_lcr_ldiv	; AL = LCR load divisor bit
  1418 00004773 EE                  <1> 	out	dx,al
  1419 00004774 31DB                <1> 	xor	bx,bx
  1420 00004776 88E3                <1> 	mov	bl,ah
  1421 00004778 80E3E0              <1> 	and	bl,0E0h			; get divisor bits from init params
  1422 0000477B D0EB                <1> 	shr	bl,1
  1423 0000477D D0EB                <1> 	shr	bl,1
  1424 0000477F D0EB                <1> 	shr	bl,1
  1425 00004781 D0EB                <1> 	shr	bl,1
  1426 00004783 2E8B9F[4125]        <1>     cs	mov	bx,word [uart_divisors+bx] ; get the divisor value
  1427 00004788 83EA03              <1> 	sub	dx,uart_lcr_reg		; DX = UART base address
  1428 0000478B 88D8                <1> 	mov	al,bl
  1429 0000478D EE                  <1> 	out	dx,al			; output divisor - low byte
  1430 0000478E 42                  <1> 	inc	dx			; DX = UART base address + 1
  1431 0000478F 88F8                <1> 	mov	al,bh
  1432 00004791 EE                  <1> 	out	dx,al			; output divisor - high byte
  1433 00004792 42                  <1> 	inc	dx
  1434 00004793 42                  <1> 	inc	dx			; DX = UART LCR address
  1435 00004794 88E0                <1> 	mov	al,ah			; AL = initialization parameters
  1436 00004796 241F                <1> 	and	al,(uart_lcr_wlen | uart_lcr_stop | uart_lcr_pen | uart_lcr_peven)
  1437                              <1> 					; get control bits
  1438 00004798 EE                  <1> 	out	dx,al			; set LCR
  1439 00004799 4A                  <1> 	dec	dx
  1440 0000479A 4A                  <1> 	dec	dx			; DX = UART IER address
  1441                              <1> 					; OPTIMIZATION:
  1442                              <1> 					; uart_ier_reg = uart_lcr_reg - 2
  1443 0000479B B000                <1> 	mov	al,0
  1444 0000479D EE                  <1> 	out	dx,al			; disable interrupts
  1445 0000479E 4A                  <1> 	dec	dx			; DX = UART base address
  1446                              <1> 					; OPTIMIZATION:
  1447                              <1> 					; uart_base = uart_ier_reg - 1
  1448 0000479F EB00                <1> 	jmp	int_14_fn03		; exit returning modem and line status
  1449                              <1> 
  1450                              <1> ;=========================================================================
  1451                              <1> ; int_14_fn03 - Return serial port status
  1452                              <1> ; Input:
  1453                              <1> ;	AH = 03h - function 03h - return serial port status
  1454                              <1> ;	DX = serial port number (0-3)
  1455                              <1> ; Output:
  1456                              <1> ;	AL = modem status (see int_14_fn00 for complete description)
  1457                              <1> ;	AH = line status (see int_14_fn00 for complete description)
  1458                              <1> ;-------------------------------------------------------------------------
  1459                              <1> int_14_fn03:
  1460 000047A1 83C205              <1> 	add	dx,uart_lsr_reg		; DX = UART LSR address
  1461 000047A4 EC                  <1> 	in	al,dx
  1462 000047A5 88C4                <1> 	mov	ah,al
  1463 000047A7 42                  <1> 	inc	dx			; DX = UART MSR address
  1464 000047A8 EC                  <1> 	in	al,dx
  1465 000047A9 EBBB                <1> 	jmp	int_14_exit
  1466                              <1> 
  1467                              <1> ;=========================================================================
  1468                              <1> ; int_14_fn04 - Extended initialize serial port
  1469                              <1> ; Input:
  1470                              <1> ;	AH = 04h - function 04h - extended initialize serial port
  1471                              <1> ;	AL - break status:
  1472                              <1> ;		00h = no break
  1473                              <1> ;		01h = break
  1474                              <1> ;	BH - parity:
  1475                              <1> ;		00h = no parity
  1476                              <1> ;		01h = odd parity
  1477                              <1> ;		02h = even parity
  1478                              <1> ;		03h = stick parity odd
  1479                              <1> ;		04h = stick parity even
  1480                              <1> ;	BL - stop bits:
  1481                              <1> ;		00h = 1 stop bit
  1482                              <1> ;		01h = 2 stop bits (or 1.5 stop bits for 5 bit word length)
  1483                              <1> ;	CH - word length:
  1484                              <1> ;		00h = 5 bits
  1485                              <1> ;		01h = 6 bits
  1486                              <1> ;		02h = 7 bits
  1487                              <1> ;		03h = 8 bits
  1488                              <1> ;	CL - bps rate:
  1489                              <1> ;		00h = 110 bps
  1490                              <1> ;		01h = 150 bps
  1491                              <1> ;		02h = 300 bps
  1492                              <1> ;		03h = 600 bps
  1493                              <1> ;		04h = 1200 bps
  1494                              <1> ;		05h = 2400 bps
  1495                              <1> ;		06h = 6000 bps
  1496                              <1> ;		07h = 9600 bps
  1497                              <1> ;		08h = 19200 bps
  1498                              <1> ;		09h = 38400 bps
  1499                              <1> ;		0Ah = 57600 bps
  1500                              <1> ;		0Bh = 115200 bps
  1501                              <1> ;	DX = serial port number (0-3)
  1502                              <1> ; Output:
  1503                              <1> ;	AL = modem status (see int_14_fn00 for complete description)
  1504                              <1> ;	AH = line status (see int_14_fn00 for complete description)
  1505                              <1> ;-------------------------------------------------------------------------
  1506                              <1> int_14_fn04:
  1507 000047AB 88C4                <1> 	mov	ah,al			; save AL to AH
  1508 000047AD 80F90C              <1> 	cmp	cl,num_divisors
  1509 000047B0 73EF                <1> 	jae	int_14_fn03		; invalid divisor value
  1510                              <1> 					; exit returning modem and line status
  1511 000047B2 83C203              <1> 	add	dx,uart_lcr_reg		; DX = UART LCR address
  1512 000047B5 B080                <1> 	mov	al,uart_lcr_ldiv	; AL = LCR load divisor bit
  1513 000047B7 EE                  <1> 	out	dx,al
  1514 000047B8 31DB                <1> 	xor	bx,bx
  1515 000047BA 88CB                <1> 	mov	bl,cl			; get divisor number from parameters
  1516 000047BC D0E3                <1> 	shl	bl,1			; index to the word table
  1517 000047BE 2E8B9F[4125]        <1>     cs	mov	bx,word [uart_divisors+bx] ; get the divisor value
  1518 000047C3 83EA03              <1> 	sub	dx,uart_lcr_reg		; DX = UART base address
  1519 000047C6 88D8                <1> 	mov	al,bl
  1520 000047C8 EE                  <1> 	out	dx,al			; output divisor - low byte
  1521 000047C9 42                  <1> 	inc	dx			; DX = UART base address + 1
  1522 000047CA 88F8                <1> 	mov	al,bh
  1523 000047CC EE                  <1> 	out	dx,al			; output divisor - high byte
  1524 000047CD 42                  <1> 	inc	dx
  1525 000047CE 42                  <1> 	inc	dx			; DX = UART LCR address
  1526                              <1> 
  1527 000047CF 80E401              <1> 	and	ah,01h			; break setting (mask defined bits)
  1528 000047D2 88E0                <1> 	mov	al,ah			; add it to AL (LCR setting)
  1529                              <1> 
  1530 000047D4 D0E0                <1> 	shl	al,1
  1531 000047D6 D0E0                <1> 	shl	al,1
  1532 000047D8 D0E0                <1> 	shl	al,1			; make place for parity settings
  1533                              <1> 	
  1534 000047DA 5B                  <1> 	pop	bx			; get original BX value from the stack
  1535 000047DB 53                  <1> 	push	bx			; push it back to the stack
  1536                              <1> 
  1537 000047DC 80FF01              <1> 	cmp	bh,1			; parity setting
  1538 000047DF 7609                <1> 	jbe	.set_parity		; no parity or odd parity
  1539 000047E1 FECF                <1> 	dec	bh
  1540 000047E3 80E703              <1> 	and	bh,03h			; get the valid bits only
  1541 000047E6 D0E7                <1> 	shl	bh,1
  1542 000047E8 FEC7                <1> 	inc	bh			; 010 -> 011, 011 -> 101, 100 -> 111
  1543                              <1> 
  1544                              <1> .set_parity:
  1545 000047EA 08F8                <1> 	or	al,bh			; add it to AL (LCR setting)
  1546                              <1> 
  1547 000047EC D0E0                <1> 	shl	al,1			; make place for stop bit setting
  1548                              <1> 	
  1549 000047EE 80E301              <1> 	and	bl,01h			; get stop bits (defined bit only)
  1550 000047F1 08D8                <1> 	or	al,bl			; add it to AL (LCR setting)
  1551                              <1> 
  1552 000047F3 D0E0                <1> 	shl	al,1
  1553 000047F5 D0E0                <1> 	shl	al,1			; make place for word length setting
  1554                              <1> 
  1555 000047F7 80E503              <1> 	and	ch,03h			; get word length (mask defined bits)
  1556 000047FA 08E8                <1> 	or	al,ch			; add it to AL (LCR setting)
  1557                              <1> 
  1558 000047FC EE                  <1> 	out	dx,al			; set LCR
  1559 000047FD 4A                  <1> 	dec	dx
  1560 000047FE 4A                  <1> 	dec	dx			; DX = UART IER address
  1561                              <1> 					; OPTIMIZATION:
  1562                              <1> 					; uart_ier_reg = uart_lcr_reg - 2
  1563 000047FF B000                <1> 	mov	al,0
  1564 00004801 EE                  <1> 	out	dx,al			; disable interrupts
  1565 00004802 4A                  <1> 	dec	dx			; DX = UART base address
  1566                              <1> 					; OPTIMIZATION:
  1567                              <1> 					; uart_base = uart_ier_reg - 1
  1568 00004803 EB9C                <1> 	jmp	int_14_fn03		; exit returning modem and line status
  1569                              <1> 
  1570                              <1> ;=========================================================================
  1571                              <1> ; int_14_fn05 - Extended serial port control
  1572                              <1> ; Input:
  1573                              <1> ;	AH = 05h - function 05h - extended serial port control
  1574                              <1> ;	AL - sub-function:
  1575                              <1> ;		00h = read modem control register
  1576                              <1> ;		01h = write modem control register
  1577                              <1> ;			BL = modem control register
  1578                              <1> ;	DX = serial port number (0-3)
  1579                              <1> ; Output:
  1580                              <1> ;	AX = status	
  1581                              <1> ;	sub-function AL = 00h:
  1582                              <1> ;		BL = modem control register
  1583                              <1> ;-------------------------------------------------------------------------
  1584                              <1> int_14_fn05:
  1585 00004805 2401                <1> 	and	al,01h			; sub-function (get the valid bit)
  1586 00004807 750D                <1> 	jnz	int_14_fn05_01
  1587                              <1> 
  1588                              <1> ;-------------------------------------------------------------------------
  1589                              <1> ; sub-function 00h - read modem control register
  1590                              <1> ; int_14_fn05_00:
  1591 00004809 83C203              <1> 	add	dx,uart_lcr_reg		; DX = UART MCR address
  1592 0000480C EC                  <1> 	in	al,dx
  1593 0000480D 5B                  <1> 	pop	bx			; get BX from the stack
  1594 0000480E 88C3                <1> 	mov	bl,al			; BL = MCR content
  1595 00004810 53                  <1> 	push	bx			; put BX back to the stack
  1596 00004811 83EA03              <1> 	sub	dx,uart_lcr_reg		; DX = UART base address
  1597 00004814 EB8B                <1> 	jmp	int_14_fn03		; exit returning modem and line status
  1598                              <1> 
  1599                              <1> ;-------------------------------------------------------------------------
  1600                              <1> ; sub-function 01h - write modem control register
  1601                              <1> int_14_fn05_01:
  1602 00004816 83C203              <1> 	add	dx,uart_lcr_reg		; DX = UART MCR address
  1603 00004819 5B                  <1> 	pop	bx			; get BX from the stack
  1604 0000481A 53                  <1> 	push	bx			; put BX back to the stack
  1605 0000481B 88D8                <1> 	mov	al,bl			; BL = new MCR content
  1606 0000481D EE                  <1> 	out	dx,al
  1607 0000481E 83EA03              <1> 	sub	dx,uart_lcr_reg		; DX = UART base address
  1608 00004821 E97DFF              <1> 	jmp	int_14_fn03		; exit returning modem and line status
  1295                                  %include	"keyboard.inc"		; INT 16, INT 09
  1296                              <1> ;=========================================================================
  1297                              <1> ; keyboard.inc - Keyboard support
  1298                              <1> ;       INT 16h - BIOS Keyboard Services
  1299                              <1> ;		- function AH=02h
  1300                              <1> ;		- function AH=03h
  1301                              <1> ;		- function AH=05h
  1302                              <1> ;		- function AH=12h
  1303                              <1> ;		- see scancode.inc for other (scancode related)
  1304                              <1> ;                 INT 16h functions
  1305                              <1> ;       INT 09h - IRQ1 interrupt handler
  1306                              <1> ;-------------------------------------------------------------------------
  1307                              <1> ;
  1308                              <1> ; Compiles with NASM 2.13.02, might work with other versions
  1309                              <1> ;
  1310                              <1> ; Copyright (C) 2010 - 2023 Sergey Kiselev.
  1311                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
  1312                              <1> ;
  1313                              <1> ; This program is free software: you can redistribute it and/or modify
  1314                              <1> ; it under the terms of the GNU General Public License as published by
  1315                              <1> ; the Free Software Foundation, either version 3 of the License, or
  1316                              <1> ; (at your option) any later version.
  1317                              <1> ;
  1318                              <1> ; This program is distributed in the hope that it will be useful,
  1319                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  1320                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  1321                              <1> ; GNU General Public License for more details.
  1322                              <1> ;
  1323                              <1> ; You should have received a copy of the GNU General Public License
  1324                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  1325                              <1> ;
  1326                              <1> ;=========================================================================
  1327                              <1> 
  1328                              <1> ;=========================================================================
  1329                              <1> ; Scan codes and keyboard flags
  1330                              <1> ;-------------------------------------------------------------------------
  1331                              <1> 
  1332                              <1> ; scancodes for special keys
  1333                              <1> 
  1334                              <1> kbd_num_code	equ	45h
  1335                              <1> kbd_scroll_code	equ	46h
  1336                              <1> kbd_caps_code	equ	3ah
  1337                              <1> kbd_ctrl_code	equ	1dh
  1338                              <1> kbd_alt_code	equ	38h
  1339                              <1> kbd_rshift_code	equ	36h
  1340                              <1> kbd_prtsc_code	equ	37h
  1341                              <1> kbd_lshift_code	equ	2ah
  1342                              <1> kbd_ins_code	equ	52h
  1343                              <1> kbd_del_code	equ	53h
  1344                              <1> 
  1345                              <1> ; Bits for the various modifier keys
  1346                              <1> 
  1347                              <1> kbd_rshft_bit	equ	1
  1348                              <1> kbd_lshft_bit	equ	2
  1349                              <1> kbd_ctrl_bit	equ	4
  1350                              <1> kbd_alt_bit	equ	8
  1351                              <1> kbd_scroll_bit	equ	10h
  1352                              <1> kbd_num_bit	equ	20h
  1353                              <1> kbd_caps_bit	equ	40h
  1354                              <1> kbd_ins_bit	equ	80h
  1355                              <1> 
  1356                              <1> ;=========================================================================
  1357                              <1> ; int_16 - BIOS keyboard functions
  1358                              <1> ;-------------------------------------------------------------------------
  1359 00004824 FF<rep Ah>          <1> 	setloc	0E82Eh
  1359          ******************  <1>  warning: Inserting 10 bytes [-w+user]
  1360                              <1> int_16:
  1361                              <1> ;	call	int_trace		; DEBUG
  1362 0000482E 53                  <1> 	push	bx
  1363 0000482F 1E                  <1> 	push	ds
  1364 00004830 BB4000              <1> 	mov	bx,biosdseg
  1365 00004833 8EDB                <1> 	mov	ds,bx
  1366 00004835 80FC13              <1> 	cmp	ah,.num_func
  1367 00004838 7331                <1> 	jae	int_16_exit
  1368 0000483A B700                <1> 	mov	bh,0
  1369 0000483C 88E3                <1> 	mov	bl,ah
  1370 0000483E D1E3                <1> 	shl	bx,1
  1371 00004840 2EFFA7[4548]        <1>     cs	jmp	near [.dispatch+bx]
  1372                              <1> 
  1373                              <1> .dispatch:
  1374 00004845 [6823]              <1> 	dw	int_16_fn00		; read char from buffer, wait if empty
  1375 00004847 [BD23]              <1> 	dw	int_16_fn01		; check buffer, do not clear
  1376 00004849 [7448]              <1> 	dw	int_16_fn02		; get shift status
  1377                              <1> %ifdef AT_KEYBOARD
  1378                              <1> 	dw	int_16_fn03		; set delays
  1379                              <1> %else ; AT_KEYBOARD
  1380 0000484B [6B48]              <1> 	dw	int_16_exit		; not implemented on XT
  1381                              <1> %endif ; AT_KEYBOARD
  1382 0000484D [6B48]              <1> 	dw	int_16_exit		; keyclick
  1383 0000484F [7948]              <1> 	dw	int_16_fn05		; write to keyboard buffer
  1384 00004851 [6B48]              <1> 	dw	int_16_exit		; 06
  1385 00004853 [6B48]              <1> 	dw	int_16_exit		; 07
  1386 00004855 [6B48]              <1> 	dw	int_16_exit		; 08
  1387 00004857 [6B48]              <1> 	dw	int_16_exit		; 09
  1388 00004859 [6B48]              <1> 	dw	int_16_exit		; 0A
  1389 0000485B [6B48]              <1> 	dw	int_16_exit		; 0B
  1390 0000485D [6B48]              <1> 	dw	int_16_exit		; 0C
  1391 0000485F [6B48]              <1> 	dw	int_16_exit		; 0D
  1392 00004861 [6B48]              <1> 	dw	int_16_exit		; 0E
  1393 00004863 [6B48]              <1> 	dw	int_16_exit		; 0F
  1394 00004865 [1524]              <1> 	dw	int_16_fn10		; get enhanced keystroke
  1395 00004867 [4124]              <1> 	dw	int_16_fn11		; check enhanced keystroke
  1396 00004869 [A248]              <1> 	dw	int_16_fn12		; get enhanced shift flags
  1397                              <1> .num_func	equ	($-.dispatch)/2
  1398                              <1> 
  1399                              <1> int_16_exit:
  1400 0000486B 1F                  <1> 	pop	ds
  1401 0000486C 5B                  <1> 	pop	bx
  1402 0000486D CF                  <1> 	iret
  1403                              <1> 
  1404                              <1> int_16_exitf:
  1405 0000486E 1F                  <1> 	pop	ds
  1406 0000486F 5B                  <1> 	pop	bx
  1407 00004870 FB                  <1> 	sti
  1408 00004871 CA0200              <1> 	retf	2
  1409                              <1> 
  1410                              <1> ;=========================================================================
  1411                              <1> ; int_16_fn02 - get shift flags
  1412                              <1> ; Input:
  1413                              <1> ;	AH = 02h
  1414                              <1> ; Output:
  1415                              <1> ;	AL - shift flags
  1416                              <1> ;            AL bits:
  1417                              <1> ;		7 - Insert active
  1418                              <1> ;		6 - Caps Lock active
  1419                              <1> ;		5 - Num Lock active
  1420                              <1> ;		4 - Scroll Lock active
  1421                              <1> ;		3 - Alt key pressed (either Alt on 101/102-key keyboards)
  1422                              <1> ;		2 - Ctrl key pressed (either Ctrl on 101/102-key keyboards)
  1423                              <1> ;		1 - left shift key pressed
  1424                              <1> ;		0 - right shift key pressed
  1425                              <1> ;-------------------------------------------------------------------------
  1426                              <1> int_16_fn02:
  1427 00004874 A01700              <1> 	mov	al,byte [kbd_flags_1]
  1428 00004877 EBF2                <1> 	jmp	int_16_exit
  1429                              <1> 
  1430                              <1> %ifdef AT_KEYBOARD
  1431                              <1> 
  1432                              <1> ;=========================================================================
  1433                              <1> ; int_16_fn03 - set keyboard typematic rate
  1434                              <1> ; Input:
  1435                              <1> ;	AH = 03
  1436                              <1> ;	AL - subfunction
  1437                              <1> ;	     00 - set typematic rate to default
  1438                              <1> ;	     01 - increase initial delay
  1439                              <1> ;	     02 - slow typematic rate by 1/2
  1440                              <1> ;	     04 - turn off typematic chars
  1441                              <1> ;	     05 - set typematic rate/delay
  1442                              <1> ;	BH - repeat delay (AL=5)
  1443                              <1> ;		0 - 250ms	2 - 750ms
  1444                              <1> ;		1 - 500ms	3 - 1000ms
  1445                              <1> ;	BL - typematic rate, one of the following  (AL=5)
  1446                              <1> ;		00 - 30.0	01 - 26.7	02 - 24.0	03 - 21.8
  1447                              <1> ;		04 - 20.0	05 - 18.5	06 - 17.1	07 - 16.0
  1448                              <1> ;		08 - 15.0	09 - 13.3	0A - 12.0	0B - 10.9
  1449                              <1> ;		0C - 10.0	0D - 9.2	0E - 8.6	0F - 8.0
  1450                              <1> ;		10 - 7.5	11 - 6.7	12 - 6.0	13 - 5.5
  1451                              <1> ;		14 - 5.0	15 - 4.6	16 - 4.3	17 - 4.0
  1452                              <1> ;		18 - 3.7	19 - 3.3	1A - 3.0	1B - 2.7
  1453                              <1> ;		1C - 2.5	1D - 2.3	1E - 2.1	1F - 2.0
  1454                              <1> ; Output:
  1455                              <1> ;	none
  1456                              <1> ;-------------------------------------------------------------------------
  1457                              <1> int_16_fn03:
  1458                              <1> 	cmp	al,05
  1459                              <1> 	jne	.exit			; only AL = 5 implemented
  1460                              <1> 	push	bx
  1461                              <1> 	push	cx
  1462                              <1> 	mov	al,kbc_cmd_kbd_dis	; disable keyboard interface
  1463                              <1> 	call	kbc_write_command
  1464                              <1> 	and	bh,3			; legal BH values from 0 to 3
  1465                              <1> 	mov	cl,5
  1466                              <1> 	shl	bh,cl
  1467                              <1> 	and	bl,1Fh			; legal BL values from 0 to 1F
  1468                              <1> 	mov	al,dev_cmd_rate
  1469                              <1> 	call	kbc_kb_send
  1470                              <1> 	mov	al,bh
  1471                              <1> 	call	kbc_kb_send
  1472                              <1> 	mov	al,kbc_cmd_kbd_ena	; enable keyboard interface
  1473                              <1> 	call	kbc_write_command
  1474                              <1> 	mov	al,04h			; FIXME: Use dev_cmd_enable instead?
  1475                              <1> 	call	kbc_kb_send
  1476                              <1> 	pop	cx
  1477                              <1> 	pop	bx
  1478                              <1> .exit:
  1479                              <1> 	jmp	int_16_exit
  1480                              <1> 
  1481                              <1> %endif ; AT_KEYBOARD
  1482                              <1> 
  1483                              <1> ;=========================================================================
  1484                              <1> ; int_16_fn05 - store keystroke in keyboard buffer
  1485                              <1> ; Input:
  1486                              <1> ;	AH = 05h
  1487                              <1> ;	CH = BIOS scan code
  1488                              <1> ;	CL = ACII character
  1489                              <1> ; Output:
  1490                              <1> ;	AL - status
  1491                              <1> ;	     00h - success
  1492                              <1> ;	     01h - keyboard buffer full
  1493                              <1> ;-------------------------------------------------------------------------
  1494                              <1> int_16_fn05:
  1495 00004879 56                  <1> 	push	si
  1496 0000487A B001                <1> 	mov	al,1			; assume no space
  1497 0000487C FA                  <1> 	cli				; critical section
  1498 0000487D 8B1E1C00            <1> 	mov	bx,word [kbd_buffer_tail]
  1499 00004881 89DE                <1> 	mov	si,bx
  1500 00004883 83C302              <1> 	add	bx,2
  1501 00004886 3B1E8200            <1> 	cmp	bx,word [kbd_buffer_end]
  1502 0000488A 7504                <1> 	jne	.1
  1503 0000488C 8B1E8000            <1> 	mov	bx,word [kbd_buffer_start]
  1504                              <1> .1:
  1505 00004890 3B1E1A00            <1> 	cmp	bx,word [kbd_buffer_head]
  1506 00004894 7408                <1> 	je	.no_space		; no space in buffer
  1507 00004896 890C                <1> 	mov	word [si],cx
  1508 00004898 891E1C00            <1> 	mov	word [kbd_buffer_tail],bx
  1509 0000489C B000                <1> 	mov	al,0			; stored successfully
  1510                              <1> .no_space:
  1511 0000489E FB                  <1> 	sti
  1512 0000489F 5E                  <1> 	pop	si
  1513 000048A0 EBC9                <1> 	jmp	int_16_exit
  1514                              <1> 
  1515                              <1> ;=========================================================================
  1516                              <1> ; int_16_fn12 - get extended shift flags
  1517                              <1> ; Input:
  1518                              <1> ;	AH = 12h
  1519                              <1> ; Output:
  1520                              <1> ;	AL - shift flags 1 (same as returned by function AH=02)
  1521                              <1> ;	AH - shift flags 2
  1522                              <1> ;            AH bits:
  1523                              <1> ;		7 - SysRq key pressed
  1524                              <1> ;		6 - Caps Lock pressed
  1525                              <1> ;		5 - Num Lock pressed
  1526                              <1> ;		4 - Scroll Lock pressed
  1527                              <1> ;		3 - right Alt key pressed
  1528                              <1> ;		2 - right Ctrl key pressed
  1529                              <1> ;		1 - left Alt key pressed
  1530                              <1> ;		0 - left Ctrl key pressed
  1531                              <1> ;-------------------------------------------------------------------------
  1532                              <1> int_16_fn12:
  1533 000048A2 8A261800            <1> 	mov	ah,byte [kbd_flags_2]
  1534 000048A6 80E47F              <1> 	and	ah,7Fh			; clear final SysRq bit
  1535 000048A9 F6C404              <1> 	test	ah,00000100b		; test current SysRq bit
  1536 000048AC 7403                <1> 	je	.1
  1537 000048AE 80CC80              <1> 	or	ah,80h			; set final SysRq bit
  1538                              <1> .1:
  1539 000048B1 80E4F3              <1> 	and	ah,11110011b		; clear right Alt/Ctrl bits
  1540 000048B4 A09600              <1> 	mov	al,byte [kbd_flags_3]
  1541 000048B7 240C                <1> 	and	al,00001100b		; get right Alt/Ctrl bits
  1542 000048B9 08C4                <1> 	or	ah,al			; copy to AH
  1543 000048BB A01700              <1> 	mov	al,byte [kbd_flags_1]
  1544 000048BE EBAB                <1> 	jmp	int_16_exit
  1545                              <1> 
  1546                              <1> ;=========================================================================
  1547                              <1> ; int_09 - Keyboard hardware interrupt (IRQ1) handler
  1548                              <1> ;-------------------------------------------------------------------------
  1549 000048C0 FF<rep C7h>         <1> 	setloc	0E987h			; INT 09 Entry Point
  1549          ******************  <1>  warning: Inserting 199 bytes [-w+user]
  1550                              <1> int_09:
  1551 00004987 50                  <1> 	push	ax
  1552 00004988 53                  <1> 	push	bx
  1553 00004989 1E                  <1> 	push	ds
  1554                              <1> 
  1555 0000498A B84000              <1> 	mov	ax,biosdseg
  1556 0000498D 8ED8                <1> 	mov	ds,ax
  1557                              <1> 
  1558                              <1> %ifdef AT_KEYBOARD
  1559                              <1> %ifndef DISABLE_KBD_DURING_INTERRUPTS
  1560                              <1> 	mov	al,kbc_cmd_kbd_dis	; disable keyboard interface
  1561                              <1> 	call    kbc_write_command
  1562                              <1> %endif
  1563                              <1> %endif ; AT_KEYBOARD
  1564 0000498F E460                <1> 	in	al,ppi_pa_reg		; get keyboard data / scancode
  1565                              <1> %ifndef MACHINE_BOOK8088
  1566 00004991 88C4                <1> 	mov	ah,al			; save it in AH
  1567 00004993 E461                <1> 	in	al,ppi_pb_reg		; read PPI port B, control
  1568 00004995 0C80                <1> 	or	al,10000000b		; set keyboard clear bit
  1569 00004997 E661                <1> 	out	ppi_pb_reg,al		; write it back to PPI port B
  1570 00004999 247F                <1> 	and	al,01111111b		; unset keyboard clear bit
  1571 0000499B E661                <1> 	out	ppi_pb_reg,al		; write it back to PPI port B
  1572 0000499D 88E0                <1> 	mov	al,ah			; restore AL / scancode
  1573                              <1> %endif ; MACHINE_BOOK8088
  1574 0000499F FB                  <1> 	sti
  1575                              <1> %ifdef AT_KEYBOARD
  1576                              <1> 	mov	ah,4Fh
  1577                              <1> 	stc
  1578                              <1> 	int	15h			; keyboard intercept
  1579                              <1> 	jnc	keyboard_int_exit	; CF = 0, ignore scan code
  1580                              <1> %else ; AT_KEYBOARD
  1581 000049A0 3CFF                <1> 	cmp	al,0FFh			; check for overrun
  1582 000049A2 7503E9CF01          <1> 	jz	keyboard_int_exit
  1583                              <1> %endif ; AT_KEYBOARD
  1584                              <1> ; check for KBC response codes
  1585                              <1> 
  1586 000049A7 3CEE                <1> 	cmp	al,0EEh			; echo response?
  1587 000049A9 7503E9C801          <1> 	je      keyboard_int_exit
  1588 000049AE 3CFA                <1> 	cmp	al,0FAh			; acknowledge?
  1589 000049B0 7508                <1> 	jne     .2
  1590 000049B2 800E970010          <1> 	or	byte [kbd_flags_4],10h	; set ack bit
  1591 000049B7 E9BC01              <1> 	jmp	keyboard_int_exit
  1592                              <1> .2:
  1593 000049BA 3CFE                <1> 	cmp	al,0FEh			; resend command?
  1594 000049BC 7508                <1> 	jne	.3
  1595 000049BE 800E970020          <1> 	or	byte [kbd_flags_4],20h	; set resend bit
  1596 000049C3 E9B001              <1> 	jmp	keyboard_int_exit
  1597                              <1> 
  1598                              <1> ; Note: other KBC response codes have their MSB bit set and will be ignored
  1599                              <1> 
  1600                              <1> .3:
  1601                              <1> 
  1602                              <1> ; check for 0E0h and 0E1h scancodes, set flags in kbd_flags_3
  1603                              <1> 
  1604 000049C6 3CE0                <1> 	cmp	al,0E0h
  1605 000049C8 750D                <1> 	jne	.4
  1606 000049CA 800E960002          <1> 	or	byte [kbd_flags_3],10b	; set E0 flag
  1607 000049CF 80269600FE          <1> 	and	byte [kbd_flags_3],0FEh	; clear E1 flag
  1608 000049D4 E99F01              <1> 	jmp	keyboard_int_exit
  1609                              <1> .4:
  1610 000049D7 3CE1                <1> 	cmp	al,0E1h
  1611 000049D9 750D                <1> 	jne	.5
  1612 000049DB 800E960001          <1> 	or	byte [kbd_flags_3],1	; set E1 flag
  1613 000049E0 80269600FD          <1> 	and	byte [kbd_flags_3],0FDh	; clear E0 Flag
  1614 000049E5 E98E01              <1> 	jmp	keyboard_int_exit
  1615                              <1> 
  1616                              <1> ; check for various <Ctrl>+<Alt>+<Key> combinations:
  1617                              <1> 
  1618                              <1> .5:
  1619 000049E8 8A1E1700            <1> 	mov	bl,byte [kbd_flags_1]
  1620 000049EC 80E30C              <1> 	and	bl,kbd_alt_bit|kbd_ctrl_bit
  1621 000049EF 80FB0C              <1> 	cmp	bl,kbd_alt_bit|kbd_ctrl_bit
  1622 000049F2 752D                <1> 	jne	.6
  1623 000049F4 3C53                <1> 	cmp	al,kbd_del_code		; <Ctrl>+<Alt>+<Del>?
  1624 000049F6 750B                <1> 	jne	.check_turbo_off
  1625 000049F8 C70672003412        <1> 	mov	word [warm_boot],1234h ; warm boot flag
  1626 000049FE EA[6640]00F0        <1> 	jmp	0F000h:warm_start	; reboot
  1627                              <1> 
  1628                              <1> ; handle turbo mode switch combinations
  1629                              <1> .check_turbo_off:
  1630                              <1> 
  1631                              <1> %ifdef TURBO_MODE
  1632 00004A03 3C4A                <1> 	cmp	al,4Ah			; gray - scancode
  1633 00004A05 7506                <1> 	jne	.check_turbo_mid
  1634                              <1> 
  1635 00004A07 E89ADD              <1> 	call	set_cpu_clk_4_77mhz
  1636 00004A0A E96901              <1> 	jmp	keyboard_int_exit
  1637                              <1> 
  1638                              <1> .check_turbo_mid:
  1639                              <1> %ifdef MACHINE_FE2010A
  1640 00004A0D 3C37                <1> 	cmp	al,37h			; * scancode
  1641 00004A0F 7506                <1> 	jne	.check_turbo_hi
  1642                              <1> 
  1643 00004A11 E89CDD              <1> 	call	set_cpu_clk_7_16mhz
  1644 00004A14 E95F01              <1> 	jmp	keyboard_int_exit
  1645                              <1> %endif ; MACHINE_FE2010A
  1646                              <1> 
  1647                              <1> .check_turbo_hi:
  1648 00004A17 3C4E                <1> 	cmp	al,4Eh			; gray + scancode
  1649 00004A19 7506                <1> 	jne	.6
  1650                              <1> 
  1651                              <1> %ifdef MACHINE_FE2010A
  1652 00004A1B E8ACDD              <1> 	call	set_cpu_clk_9_55mhz
  1653                              <1> %else ; MACHINE_FE2010A
  1654                              <1> 	call	set_cpu_clk_turbo
  1655                              <1> %endif ; MACHINE_FE2010A
  1656 00004A1E E95501              <1> 	jmp	keyboard_int_exit
  1657                              <1> 
  1658                              <1> %endif ; TURBO_MODE
  1659                              <1> 
  1660                              <1> ; Check for the INS key here. This one needs to toggle the ins bit
  1661                              <1> ; in the keyboard flags variables.
  1662                              <1> 
  1663                              <1> .6:
  1664 00004A21 3C52                <1> 	cmp	al,kbd_ins_code
  1665 00004A23 7508                <1> 	jne	.7
  1666 00004A25 800E180080          <1> 	or	byte [kbd_flags_2],kbd_ins_bit ; set INS bit
  1667 00004A2A E90A01              <1> 	jmp	.translate	   	; pass on INS key
  1668                              <1> 
  1669                              <1> .7:
  1670 00004A2D 3CD2                <1> 	cmp	al,kbd_ins_code+80h	; INS "break" scan code
  1671 00004A2F 750D                <1> 	jne     .8
  1672 00004A31 802618007F          <1> 	and	byte [kbd_flags_2],~kbd_ins_bit ; clear INS bit
  1673 00004A36 8036170080          <1> 	xor     byte [kbd_flags_1],kbd_ins_bit ; toggle INS bit
  1674 00004A3B E93301              <1> 	jmp     .no_buffer
  1675                              <1> 
  1676                              <1> ; handle the left and right Shift keys
  1677                              <1> 
  1678                              <1> .8:
  1679 00004A3E 3C2A                <1> 	cmp	al,kbd_lshift_code
  1680 00004A40 7508                <1> 	jne	.9
  1681 00004A42 800E170002          <1> 	or	byte [kbd_flags_1],kbd_lshft_bit ; set left Shift bit
  1682 00004A47 E92701              <1> 	jmp	.no_buffer
  1683                              <1> .9:
  1684 00004A4A 3CAA                <1> 	cmp	al,kbd_lshift_code+80h
  1685 00004A4C 7508                <1> 	jne     .10
  1686 00004A4E 80261700FD          <1> 	and     byte [kbd_flags_1],~kbd_lshft_bit ; clear left Shift bit
  1687 00004A53 E91B01              <1> 	jmp     .no_buffer
  1688                              <1> .10:
  1689 00004A56 3C36                <1> 	cmp	al,kbd_rshift_code
  1690 00004A58 7508                <1> 	jne	.11
  1691 00004A5A 800E170001          <1> 	or	byte [kbd_flags_1],kbd_rshft_bit ; set right Shift bit
  1692 00004A5F E90F01              <1> 	jmp	.no_buffer
  1693                              <1> .11:
  1694 00004A62 3CB6                <1> 	cmp	al,kbd_rshift_code+80h
  1695 00004A64 7508                <1> 	jne     .12
  1696 00004A66 80261700FE          <1> 	and	byte [kbd_flags_1],~kbd_rshft_bit ; clear right Shift bit
  1697 00004A6B E90301              <1> 	jmp	.no_buffer
  1698                              <1> 
  1699                              <1> ; handle the Alt key
  1700                              <1> 
  1701                              <1> .12:
  1702 00004A6E 3C38                <1> 	cmp	al,kbd_alt_code
  1703 00004A70 7508                <1> 	jne	.13
  1704 00004A72 800E170008          <1> 	or	byte [kbd_flags_1],kbd_alt_bit ; set Alt bit
  1705 00004A77 E9F700              <1> 	jmp	.no_buffer
  1706                              <1> .13:
  1707 00004A7A 3CB8                <1> 	cmp	al,kbd_alt_code+80h
  1708 00004A7C 751C                <1> 	jne	.14
  1709 00004A7E 80261700F7          <1> 	and	byte [kbd_flags_1],~kbd_alt_bit ; clear Alt bit
  1710 00004A83 803E190000          <1> 	cmp	byte [kbd_alt_keypad],0		; anything in Alt + Keypad area
  1711 00004A88 7503E9E400          <1> 	je	.no_buffer				; nothing there - exit
  1712 00004A8D A01900              <1> 	mov	al,byte [kbd_alt_keypad]	; put it in the buffer
  1713 00004A90 C606190000          <1> 	mov	byte [kbd_alt_keypad],0		; zero the buffer
  1714 00004A95 B400                <1> 	mov	ah,0
  1715 00004A97 E9B600              <1> 	jmp	.put_in_buffer
  1716                              <1> 
  1717                              <1> ; handle the Ctrl key
  1718                              <1> 
  1719                              <1> .14:
  1720 00004A9A 3C1D                <1> 	cmp	al,kbd_ctrl_code
  1721 00004A9C 7508                <1> 	jne	.15
  1722 00004A9E 800E170004          <1> 	or	byte [kbd_flags_1],kbd_ctrl_bit ; set Ctrl bit
  1723 00004AA3 E9CB00              <1> 	jmp	.no_buffer
  1724                              <1> .15:
  1725 00004AA6 3C9D                <1> 	cmp	al,kbd_ctrl_code+80h
  1726 00004AA8 7508                <1> 	jne	.16
  1727 00004AAA 80261700FB          <1> 	and	byte [kbd_flags_1],~kbd_ctrl_bit ; clear Ctrl bit
  1728 00004AAF E9BF00              <1> 	jmp	.no_buffer
  1729                              <1> 
  1730                              <1> ; handle the Caps Lock key
  1731                              <1> 
  1732                              <1> .16:
  1733 00004AB2 3C3A                <1> 	cmp	al,kbd_caps_code
  1734 00004AB4 750D                <1> 	jne	.17
  1735 00004AB6 800E180040          <1> 	or	byte [kbd_flags_2],kbd_caps_bit ; set Caps Lock bit
  1736 00004ABB 8036170040          <1> 	xor	byte [kbd_flags_1],kbd_caps_bit ; toggle Caps Lock bit
  1737 00004AC0 E9AE00              <1> 	jmp	.no_buffer
  1738                              <1> .17:
  1739 00004AC3 3CBA                <1> 	cmp	al,kbd_caps_code+80h
  1740 00004AC5 7508                <1> 	jne	.18
  1741 00004AC7 80261800BF          <1> 	and	byte [kbd_flags_2],~kbd_caps_bit ; clear Caps Lock bit
  1742 00004ACC E9D000              <1> 	jmp	set_LEDs
  1743                              <1> 
  1744                              <1> ; check if print screen key was pressed
  1745                              <1> 
  1746                              <1> .18:
  1747 00004ACF 3C37                <1> 	cmp	al,kbd_prtsc_code
  1748 00004AD1 750A                <1> 	jne	.test_scroll_loc
  1749 00004AD3 F606960002          <1> 	test	byte [kbd_flags_3],10b	; test E0 flag
  1750 00004AD8 7403                <1> 	jz	.test_scroll_loc	; jump if no 0E0h flag (Keypad *)
  1751 00004ADA E9B500              <1> 	jmp	print_screen
  1752                              <1> 
  1753                              <1> ; handle the Scroll Lock (046h) key and Ctrl-Break combination (0E0h, 046h)
  1754                              <1> 
  1755                              <1> .test_scroll_loc:
  1756 00004ADD 3C46                <1> 	cmp	al,kbd_scroll_code
  1757 00004ADF 7528                <1> 	jne	.19
  1758 00004AE1 F606960002          <1> 	test	byte [kbd_flags_3],10b	; test E0 flag
  1759 00004AE6 7415                <1> 	jz	.scroll_lock		; jump if no 0E0h flag (Scroll Lock)
  1760                              <1> 
  1761                              <1> ; handle Ctrl-Break
  1762                              <1> 
  1763 00004AE8 8B1E8000            <1> 	mov	bx,word [kbd_buffer_start] ; empty keyboard buffer
  1764 00004AEC 891E1A00            <1> 	mov	word [kbd_buffer_head],bx
  1765 00004AF0 891E1C00            <1> 	mov	word [kbd_buffer_tail],bx
  1766 00004AF4 800E710080          <1> 	or	byte [break_flag],80h	; set Ctrl-Break flag
  1767 00004AF9 CD1B                <1> 	int	1Bh			; call INT 1Bh - Ctrl-Break handler
  1768 00004AFB EB74                <1> 	jmp	.no_buffer
  1769                              <1> 
  1770                              <1> ; handle Scroll Lock
  1771                              <1> 
  1772                              <1> .scroll_lock:
  1773 00004AFD 800E180010          <1> 	or	byte [kbd_flags_2],kbd_scroll_bit ; set Scroll Lock bit
  1774 00004B02 8036170010          <1> 	xor	byte [kbd_flags_1],kbd_scroll_bit ; toggle Scroll Lock bit
  1775 00004B07 EB68                <1> 	jmp	.no_buffer
  1776                              <1> .19:
  1777 00004B09 3CC6                <1> 	cmp	al,kbd_scroll_code+80h
  1778 00004B0B 7508                <1> 	jne	.20
  1779 00004B0D 80261800EF          <1> 	and	byte [kbd_flags_2],~kbd_scroll_bit ; clear Scroll Lock bit
  1780 00004B12 E98A00              <1> 	jmp	set_LEDs
  1781                              <1> 
  1782                              <1> ; handle the Num Lock
  1783                              <1> 
  1784                              <1> .20:
  1785 00004B15 3C45                <1> 	cmp	al,kbd_num_code
  1786 00004B17 7513                <1> 	jne	.21
  1787 00004B19 F606170004          <1> 	test	byte [kbd_flags_1],kbd_ctrl_bit	; Ctrl+Num Lock (Pause)?
  1788 00004B1E 755E                <1> 	jnz	pause			; jump if pause
  1789 00004B20 800E180020          <1> 	or	byte [kbd_flags_2],kbd_num_bit ; set Num Lock bit
  1790 00004B25 8036170020          <1> 	xor	byte [kbd_flags_1],kbd_num_bit ; toggle Num Lock bit
  1791 00004B2A EB45                <1> 	jmp	.no_buffer
  1792                              <1> .21:
  1793 00004B2C 3CC5                <1> 	cmp	al,kbd_num_code+80h
  1794 00004B2E 7507                <1> 	jne	.translate
  1795 00004B30 80261800DF          <1> 	and	byte [kbd_flags_2],~kbd_num_bit ; clear Num Lock bit
  1796 00004B35 EB68                <1> 	jmp	set_LEDs
  1797                              <1> 
  1798                              <1> ; translate keyboard scan code to ASCII and BIOS scan code
  1799                              <1> 
  1800                              <1> .translate:
  1801 00004B37 F606180008          <1> 	test	byte [kbd_flags_2],08h	; check pause flag
  1802 00004B3C 7407                <1> 	jz	.check_release
  1803 00004B3E 80261800F7          <1> 	and	byte [kbd_flags_2],~08h	; clear pause flag
  1804 00004B43 EB2C                <1> 	jmp	.no_buffer		; don't put key in buffer
  1805                              <1> .check_release:
  1806 00004B45 A880                <1> 	test	al,80h			; ignore key release and KBC responses
  1807 00004B47 7528                <1> 	jnz	.no_buffer
  1808                              <1> 
  1809 00004B49 E863D7              <1> 	call	scan_xlat
  1810 00004B4C 85C0                <1> 	test	ax,ax		 	; check for bad code
  1811 00004B4E 7421                <1> 	je	.no_buffer
  1812                              <1> 
  1813                              <1> .put_in_buffer:
  1814 00004B50 56                  <1> 	push	si			; FIXME: Use Int 16h/05 instead?
  1815 00004B51 8B1E1C00            <1> 	mov	bx,word [kbd_buffer_tail]
  1816 00004B55 89DE                <1> 	mov	si,bx
  1817 00004B57 83C302              <1> 	add	bx,2
  1818 00004B5A 3B1E8200            <1> 	cmp	bx,word [kbd_buffer_end]
  1819 00004B5E 7504                <1> 	jne	.1
  1820 00004B60 8B1E8000            <1> 	mov	bx,word [kbd_buffer_start]
  1821                              <1> .1:
  1822 00004B64 3B1E1A00            <1> 	cmp	bx,word [kbd_buffer_head]
  1823 00004B68 7406                <1> 	je	.no_space		; no space in buffer
  1824 00004B6A 8904                <1> 	mov	word [si],ax
  1825 00004B6C 891E1C00            <1> 	mov	word [kbd_buffer_tail],bx
  1826                              <1> 
  1827                              <1> .no_space:
  1828 00004B70 5E                  <1> 	pop	si
  1829                              <1> 
  1830                              <1> .no_buffer:
  1831 00004B71 80269600FC          <1> 	and     byte [kbd_flags_3],0FCh	; E0, E1 not last code
  1832                              <1> 
  1833                              <1> keyboard_int_exit:
  1834                              <1> %ifdef AT_KEYBOARD
  1835                              <1> %ifndef DISABLE_KBD_DURING_INTERRUPTS
  1836                              <1> 	mov	al,kbc_cmd_kbd_ena	; enable keyboard interface
  1837                              <1> 	call	kbc_write_command
  1838                              <1> %endif
  1839                              <1> %endif ; AT_KEYBOARD
  1840 00004B76 B020                <1> 	mov	al,20h			; send EOI (end of interrupt)
  1841 00004B78 E620                <1> 	out	pic1_reg0,al		; to the 8259A PIC.
  1842                              <1> 
  1843                              <1> keyboard_int_exit1:
  1844 00004B7A 1F                  <1> 	pop	ds
  1845 00004B7B 5B                  <1> 	pop	bx
  1846 00004B7C 58                  <1> 	pop	ax
  1847 00004B7D CF                  <1> 	iret
  1848                              <1> 
  1849                              <1> pause:
  1850 00004B7E 8036180008          <1> 	xor	byte [kbd_flags_2],08h	; toggle pause flag
  1851 00004B83 74F1                <1> 	jz	keyboard_int_exit	; jump if pause flag is unset now
  1852                              <1> 
  1853 00004B85 B020                <1> 	mov	al,20h			; send EOI (end of interrupt)
  1854 00004B87 E620                <1> 	out	pic1_reg0,al		; to the 8259A PIC
  1855                              <1> 
  1856                              <1> .pause_loop:
  1857 00004B89 F606180008          <1> 	test	byte [kbd_flags_2],08h
  1858 00004B8E 75F9                <1> 	jnz	.pause_loop		; wait if pause flag is set
  1859 00004B90 EBE8                <1> 	jmp	keyboard_int_exit1
  1860                              <1> 
  1861                              <1> print_screen:
  1862 00004B92 B020                <1> 	mov	al,20h			; send EOI (end of interrupt)
  1863 00004B94 E620                <1> 	out	pic1_reg0,al		; to the 8259A PIC
  1864 00004B96 CD05                <1> 	int	5h			; INT 5 - print screen
  1865 00004B98 80269600FD          <1> 	and     byte [kbd_flags_3],0FDh	; clear E0 flag
  1866 00004B9D EBDB                <1> 	jmp	keyboard_int_exit1
  1867                              <1> 
  1868                              <1> ;=========================================================================
  1869                              <1> ; set_LEDs - Update the kbd_flags_4 LED bits from the kbd_flags_1
  1870                              <1> ; 	     variable and update LEDs on the keyboard
  1871                              <1> ;-------------------------------------------------------------------------
  1872                              <1> set_LEDs:
  1873 00004B9F B020                <1> 	mov	al,20h			; send EOI (end of interrupt)
  1874 00004BA1 E620                <1> 	out	pic1_reg0,al		; to the 8259A PIC
  1875                              <1> 
  1876 00004BA3 A01700              <1> 	mov	al,byte [kbd_flags_1]
  1877 00004BA6 D0E8                <1> 	shr	al,1
  1878 00004BA8 D0E8                <1> 	shr	al,1
  1879 00004BAA D0E8                <1> 	shr	al,1
  1880 00004BAC D0E8                <1> 	shr	al,1
  1881 00004BAE 2407                <1> 	and	al,111b
  1882 00004BB0 80269700F8          <1> 	and	byte [kbd_flags_4],0F8h	; clear LED bits.
  1883 00004BB5 08069700            <1> 	or	byte [kbd_flags_4],al	; mask in new bits.
  1884                              <1> %ifdef AT_KEYBOARD
  1885                              <1> %ifndef DISABLE_KBD_DURING_INTERRUPTS
  1886                              <1> 	mov	al,kbc_cmd_kbd_ena	; enable keyboard interface
  1887                              <1> 	call	kbc_write_command
  1888                              <1> %endif
  1889                              <1> 	mov	ah,al			; save LED bits
  1890                              <1> 
  1891                              <1> 	mov	al,kbc_cmd_kbd_dis	; disable keyboard interface
  1892                              <1> 	call	kbc_write_command
  1893                              <1> 
  1894                              <1> 	mov	al,kbd_cmd_leds		; set LEDs command
  1895                              <1> 	call	kbc_kb_send		; send the command to the keyboard
  1896                              <1> 	mov	al,ah			; get parameter byte
  1897                              <1> 	call	kbc_kb_send		; send parameter to the keyboard
  1898                              <1> 
  1899                              <1> 	mov	al,kbc_cmd_kbd_ena	; enable keyboard interface
  1900                              <1> 	call	kbc_write_command
  1901                              <1> 	mov	al,dev_cmd_enable	; restart keyboard scanning
  1902                              <1> 	call	kbc_kb_send
  1903                              <1> %endif ; AT_KEYBOARD
  1904 00004BB9 EBBF                <1> 	jmp	keyboard_int_exit1
  1905                              <1> 
  1906                              <1> ;=========================================================================
  1907                              <1> ; kbd_buffer_init - Setup keyboard buffer
  1908                              <1> ;-------------------------------------------------------------------------
  1909                              <1> kbd_buffer_init:
  1910 00004BBB B81E00              <1> 	mov	ax,kbd_buffer		; setup keyboard buffer
  1911 00004BBE A38000              <1> 	mov	word [kbd_buffer_start],ax
  1912 00004BC1 A31A00              <1> 	mov	word [kbd_buffer_head],ax
  1913 00004BC4 A31C00              <1> 	mov	word [kbd_buffer_tail],ax
  1914 00004BC7 83C020              <1> 	add	ax,20h			; size of the keyboard buffer
  1915 00004BCA A38200              <1> 	mov	word [kbd_buffer_end],ax
  1916 00004BCD 31C0                <1> 	xor	ax,ax			; clear keyboard flags
  1917 00004BCF A31700              <1> 	mov	word [kbd_flags_1],ax
  1918 00004BD2 A31800              <1> 	mov	word [kbd_flags_2],ax
  1919 00004BD5 A39600              <1> 	mov	word [kbd_flags_3],ax
  1920 00004BD8 A39700              <1> 	mov	word [kbd_flags_4],ax
  1921 00004BDB C3                  <1> 	ret
  1296                                  %include	"floppy2.inc"		; INT 13
  1297                              <1> ;=========================================================================
  1298                              <1> ; floppy2.inc - BIOS floppy disk services (part 2 of 2)
  1299                              <1> ;	INT 13h, function AH=02h
  1300                              <1> ;	INT 13h, function AH=03h
  1301                              <1> ;	INT 13h, function AH=04h
  1302                              <1> ;	INT 13h, function AH=05h
  1303                              <1> ;	- see floppy1.inc for other INT 13h functions
  1304                              <1> ;-------------------------------------------------------------------------
  1305                              <1> ;
  1306                              <1> ; Compiles with NASM 2.13.02, might work with other versions
  1307                              <1> ;
  1308                              <1> ; Copyright (C) 2010 - 2023 Sergey Kiselev.
  1309                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
  1310                              <1> ;
  1311                              <1> ; This program is free software: you can redistribute it and/or modify
  1312                              <1> ; it under the terms of the GNU General Public License as published by
  1313                              <1> ; the Free Software Foundation, either version 3 of the License, or
  1314                              <1> ; (at your option) any later version.
  1315                              <1> ;
  1316                              <1> ; This program is distributed in the hope that it will be useful,
  1317                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  1318                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  1319                              <1> ; GNU General Public License for more details.
  1320                              <1> ;
  1321                              <1> ; You should have received a copy of the GNU General Public License
  1322                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  1323                              <1> ;
  1324                              <1> ;=========================================================================
  1325                              <1> 
  1326                              <1> ;-------------------------------------------------------------------------
  1327                              <1> ; offsets for registers on stack
  1328                              <1> int_13_bp	equ	0
  1329                              <1> int_13_ds	equ	int_13_bp+2
  1330                              <1> int_13_di	equ	int_13_ds+2
  1331                              <1> int_13_si	equ	int_13_di+2
  1332                              <1> int_13_dx	equ	int_13_si+2
  1333                              <1> int_13_dl	equ	int_13_dx
  1334                              <1> int_13_dh	equ	int_13_dx+1
  1335                              <1> int_13_cx	equ	int_13_dx+2
  1336                              <1> int_13_cl	equ	int_13_cx
  1337                              <1> int_13_ch	equ	int_13_cx+1
  1338                              <1> int_13_bx	equ	int_13_cx+2
  1339                              <1> int_13_bl	equ	int_13_bx
  1340                              <1> int_13_bh	equ	int_13_bx+1
  1341                              <1> int_13_ax	equ	int_13_bx+2
  1342                              <1> int_13_al	equ	int_13_ax
  1343                              <1> int_13_ah	equ	int_13_ax+1
  1344                              <1> int_13_ip	equ	int_13_ax+2
  1345                              <1> int_13_cs	equ	int_13_ip+2
  1346                              <1> int_13_flags	equ	int_13_cs+2
  1347                              <1> int_13_flags_l	equ	int_13_flags
  1348                              <1> 
  1349                              <1> ;=========================================================================
  1350                              <1> ; int_13 - BIOS floppy disk services
  1351                              <1> ; Input:
  1352                              <1> ;	AH = function
  1353                              <1> ;		00h - Reset disk system
  1354                              <1> ;		01h - Get status of last operation
  1355                              <1> ;		02h - Read disk sectors
  1356                              <1> ;		03h - Write disk sectors
  1357                              <1> ;		04h - Verify disk sectors
  1358                              <1> ;		05h - Format track
  1359                              <1> ;		08h - Get drive parameters
  1360                              <1> ;		15h - Get disk type
  1361                              <1> ;		16h - Detect disk change
  1362                              <1> ;		17h - Set disk type for format
  1363                              <1> ;		18h - Set media type for format
  1364                              <1> ; Output:
  1365                              <1> ;	- depends on function
  1366                              <1> ;	- for most functions:
  1367                              <1> ;		CF clear if successful
  1368                              <1> ;			AH = 00h - successful completion
  1369                              <1> ;		CF set on error
  1370                              <1> ;			AH = error code
  1371                              <1> ;-------------------------------------------------------------------------
  1372 00004BDC FF<rep 7Dh>         <1> 	setloc	0EC59h			; INT 13 (Floppy) Entry Point
  1372          ******************  <1>  warning: Inserting 125 bytes [-w+user]
  1373                              <1> int_13:
  1374 00004C59 FB                  <1> 	sti
  1375 00004C5A 50                  <1> 	push	ax
  1376 00004C5B 53                  <1> 	push	bx
  1377 00004C5C 51                  <1> 	push	cx
  1378 00004C5D 52                  <1> 	push	dx
  1379 00004C5E 56                  <1> 	push	si
  1380 00004C5F 57                  <1> 	push	di
  1381 00004C60 1E                  <1> 	push	ds
  1382 00004C61 55                  <1> 	push	bp
  1383 00004C62 89E5                <1> 	mov	bp,sp
  1384                              <1> 
  1385 00004C64 BB4000              <1> 	mov	bx,biosdseg
  1386 00004C67 8EDB                <1> 	mov	ds,bx
  1387                              <1> 
  1388                              <1> ; fn01 doesn't need drive type
  1389                              <1> 
  1390 00004C69 80FC01              <1> 	cmp	ah,01h
  1391 00004C6C 7503E918CC          <1> 	je	int_13_fn01		; Get status of last operation
  1392                              <1> 
  1393                              <1> 
  1394 00004C71 80FA01              <1> 	cmp	dl,1
  1395 00004C74 7703                <1> 	ja	.try_fn08		; invalid drive number, but try fn08
  1396                              <1> 
  1397                              <1> ; get drive type
  1398                              <1> 
  1399 00004C76 E810D3              <1> 	call	get_drive_type		; AL = drive type
  1400                              <1> 
  1401                              <1> ; fn08 needs physical drive information, but can accept drive numbers 0 - 7Fh
  1402                              <1> 
  1403                              <1> .try_fn08:
  1404 00004C79 80FC08              <1> 	cmp	ah,08h
  1405 00004C7C 7503E914CC          <1> 	je	int_13_fn08		; Get drive parameters
  1406                              <1> 
  1407 00004C81 80FA01              <1> 	cmp	dl,1
  1408 00004C84 7743                <1> 	ja	.invalid_parameters	; invalid drive number (> 1)
  1409                              <1> 
  1410                              <1> ; fn15 accepts not existing drive numbers (and returns status 00h for them)
  1411                              <1> 
  1412 00004C86 80FC15              <1> 	cmp	ah,15h
  1413 00004C89 7503E9B3CC          <1> 	je	int_13_fn15		; Get disk type
  1414                              <1> 
  1415                              <1> ; all other functions require an existing drive number
  1416                              <1> 
  1417 00004C8E 3C00                <1> 	cmp	al,type_none
  1418 00004C90 7437                <1> 	je	.invalid_parameters	; drive not present or not configured
  1419                              <1> 
  1420                              <1> ; dispatch
  1421                              <1> 
  1422 00004C92 80FC00              <1> 	cmp	ah,00h
  1423 00004C95 7503E980CB          <1> 	je	int_13_fn00		; Reset disk system
  1424 00004C9A 80FC02              <1> 	cmp	ah,02h
  1425 00004C9D 746B                <1> 	je	int_13_fn02		; Read disk sectors
  1426 00004C9F 80FC03              <1> 	cmp	ah,03h
  1427 00004CA2 7466                <1> 	je	int_13_fn03		; Write disk sectors
  1428 00004CA4 80FC04              <1> 	cmp	ah,04h
  1429 00004CA7 7461                <1> 	je	int_13_fn04		; Verify disk sectors
  1430 00004CA9 80FC05              <1> 	cmp	ah,05h
  1431 00004CAC 7503E9C401          <1> 	je	int_13_fn05		; Format track
  1432 00004CB1 80FC16              <1> 	cmp	ah,16h
  1433 00004CB4 7503E9A3CC          <1> 	je	int_13_fn16		; Detect disk change
  1434 00004CB9 80FC17              <1> 	cmp	ah,17h
  1435 00004CBC 7503E9DDCC          <1> 	je	int_13_fn17		; Set disk type for format
  1436 00004CC1 80FC18              <1> 	cmp	ah,18h
  1437 00004CC4 7503E930CD          <1> 	je	int_13_fn18		; Set media type for format
  1438                              <1> 
  1439                              <1> .invalid_parameters:
  1440 00004CC9 B401                <1> 	mov	ah,fdc_e_invalid
  1441 00004CCB 88264100            <1> 	mov	byte [fdc_last_error],ah
  1442 00004CCF F9                  <1> 	stc				; error condition
  1443 00004CD0 EB1F                <1> 	jmp	int_13_exit
  1444                              <1> 
  1445                              <1> ;-------------------------------------------------------------------------
  1446                              <1> ; int_13_upd_exit - Update diskette change flag and exit
  1447                              <1> ; FIXME: what uses this (fdc_info) flag?
  1448                              <1> 
  1449                              <1> int_13_upd_exit:
  1450 00004CD2 9C                  <1> 	pushf
  1451 00004CD3 50                  <1> 	push	ax
  1452 00004CD4 8A4608              <1> 	mov	al,byte [bp+int_13_dl]	; AL = drive number
  1453 00004CD7 3C01                <1> 	cmp	al,1
  1454 00004CD9 7714                <1> 	ja	.no_update		; skip if drive number > 1
  1455 00004CDB E84BD2              <1> 	call	get_media_state		; BL = drive media state
  1456 00004CDE F6C310              <1> 	test	bl,fdc_m_established
  1457 00004CE1 740C                <1> 	jz	.no_update		; skip if media type not established
  1458 00004CE3 B404                <1> 	mov	ah,04h			; set bit 2 (drive 0 type determined)
  1459 00004CE5 08C0                <1> 	or	al,al
  1460 00004CE7 7402                <1> 	jz	.drive_0
  1461 00004CE9 B440                <1> 	mov	ah,40h			; set bit 6 (drive 1 type determined)
  1462                              <1> 
  1463                              <1> .drive_0:
  1464 00004CEB 08268F00            <1> 	or	byte [fdc_info],ah	; set media detected bit
  1465                              <1> 
  1466                              <1> .no_update:
  1467 00004CEF 58                  <1> 	pop	ax
  1468 00004CF0 9D                  <1> 	popf
  1469                              <1> 
  1470                              <1> int_13_exit:
  1471 00004CF1 88660F              <1> 	mov	byte [bp+int_13_ah],ah	; pass AH to the caller
  1472 00004CF4 B80102              <1> 	mov	ax,201h			; set IF and CF
  1473 00004CF7 7205                <1> 	jc	.set_error		; there is an error
  1474 00004CF9 806614FE            <1> 	and	byte [bp+int_13_flags_l],0FEh ; no errors - clear CF
  1475 00004CFD 48                  <1> 	dec	ax			; clear CF in AX too
  1476                              <1> 
  1477                              <1> .set_error:
  1478 00004CFE 094614              <1> 	or	word [bp+int_13_flags],ax
  1479 00004D01 5D                  <1> 	pop	bp
  1480 00004D02 1F                  <1> 	pop	ds
  1481 00004D03 5F                  <1> 	pop	di
  1482 00004D04 5E                  <1> 	pop	si
  1483 00004D05 5A                  <1> 	pop	dx
  1484 00004D06 59                  <1> 	pop	cx
  1485 00004D07 5B                  <1> 	pop	bx
  1486 00004D08 58                  <1> 	pop	ax
  1487 00004D09 CF                  <1> 	iret
  1488                              <1> 
  1489                              <1> ;=========================================================================
  1490                              <1> ; int_13_fn02 - Read disk sectors
  1491                              <1> ; int_13_fn03 - Write disk sectors
  1492                              <1> ; int_13_fn04 - Verify disk sectors
  1493                              <1> ; Input:
  1494                              <1> ;	AH = function
  1495                              <1> ;		02h - read
  1496                              <1> ;		03h - write
  1497                              <1> ;		04h - verify
  1498                              <1> ;	AL = number of sectors to read / write / verify (must be nonzero)
  1499                              <1> ;	CH = cylinder number
  1500                              <1> ;	CL = sector number
  1501                              <1> ;	DH = head number (0 or 1)
  1502                              <1> ;	DL = drive number (0 or 1)
  1503                              <1> ;	ES:BX -> data buffer
  1504                              <1> ; Output:
  1505                              <1> ;	CF clear if successful
  1506                              <1> ;		AH = 00h - successful completion
  1507                              <1> ;		AL = number of sectors transferred or verified
  1508                              <1> ;	CF set on error
  1509                              <1> ;		AH = error code
  1510                              <1> ;-------------------------------------------------------------------------
  1511                              <1> int_13_fn02:
  1512                              <1> int_13_fn03:
  1513                              <1> int_13_fn04:
  1514 00004D0A 807E0E00            <1> 	cmp	byte [bp+int_13_al],0	; number of sectors must be non zero
  1515 00004D0E 7503E95D01          <1> 	je	.invalid_request
  1516                              <1> 
  1517 00004D13 E813D2              <1> 	call	get_media_state		; BL = media state
  1518                              <1> 
  1519 00004D16 80FC03              <1> 	cmp	ah,03h			; write function
  1520 00004D19 7407                <1> 	je	.set_write
  1521 00004D1B 80263F007F          <1> 	and	byte [fdc_motor_state],~fdc_write_flag ; clear the write bit
  1522 00004D20 EB05                <1> 	jmp	.motor_on
  1523                              <1> 
  1524                              <1> .set_write:
  1525 00004D22 800E3F0080          <1> 	or	byte [fdc_motor_state],fdc_write_flag ; set the write bit
  1526                              <1> 
  1527                              <1> .motor_on:
  1528 00004D27 E853CE              <1> 	call	fdc_motor_on
  1529                              <1> 
  1530 00004D2A 3C01                <1> 	cmp	al,type_360
  1531 00004D2C 7420                <1> 	je	.set_media_360		; set media type for 360K drive
  1532 00004D2E 3C03                <1> 	cmp	al,type_720
  1533 00004D30 7420                <1> 	je	.set_media_720		; set media type for 720K drive
  1534                              <1> 
  1535 00004D32 E8EDCE              <1> 	call	fdc_disk_change
  1536 00004D35 80FC06              <1> 	cmp	ah,fdc_e_changed
  1537 00004D38 7425                <1> 	je	.establish_media	; disk changed - establish media
  1538 00004D3A 80FC00              <1> 	cmp	ah,fdc_e_success
  1539 00004D3D 7403E92101          <1> 	jne	.error_end_io		; fdc_disk_change failed
  1540                              <1> 
  1541 00004D42 F6C310              <1> 	test	bl,fdc_m_established
  1542 00004D45 7418                <1> 	jz	.establish_media	; jump if media type is not established
  1543                              <1> 
  1544 00004D47 88D8                <1> 	mov	al,bl			; media type to AL (transfer rate)
  1545 00004D49 E88DD1              <1> 	call	fdc_set_rate		; select transfer rate
  1546 00004D4C EB19                <1> 	jmp	.fdc_send_specify
  1547                              <1> 
  1548                              <1> ; 360K and 720K drives don't support change line, and only support
  1549                              <1> ; one media type - set it here
  1550                              <1> 
  1551                              <1> .set_media_360:
  1552 00004D4E B093                <1> 	mov	al,fdc_m_360in360	; 250Kbps, media established, 360K/360K
  1553 00004D50 EB02                <1> 	jmp	.set_media
  1554                              <1> 
  1555                              <1> .set_media_720:
  1556 00004D52 B097                <1> 	mov	al,fdc_m_720		; 250Kbps, media established, 720K/720K
  1557                              <1> 
  1558                              <1> .set_media:
  1559 00004D54 E8DCD1              <1> 	call	set_media_state		; save media state (AL) to the data area
  1560 00004D57 E87FD1              <1> 	call	fdc_set_rate		; send transfer rate (in AL) to FDC
  1561 00004D5A 8B5608              <1> 	mov	dx,word [bp+int_13_dx]	; restore DX (trashed by fdc_set_rate)
  1562 00004D5D EB08                <1> 	jmp	.fdc_send_specify
  1563                              <1> 
  1564                              <1> .establish_media:
  1565 00004D5F E8B2D0              <1> 	call	fdc_detect_media	; detect media type
  1566 00004D62 7303E9FC00          <1> 	jc	.error_end_io
  1567                              <1> 	
  1568                              <1> .fdc_send_specify:
  1569 00004D67 B803BF              <1> 	mov	ax,0BF03h		; FDC Specify command +
  1570                              <1> 					; 0BFh - specify byte 0 for 1.44M
  1571 00004D6A 80FB17              <1> 	cmp	bl,fdc_m_1440		; 1.44M?
  1572 00004D6D 7409                <1> 	je	.fdc_send_specify_cmd	; jump if 1.44M
  1573 00004D6F B4DF                <1> 	mov	ah,0DFh			; 0DFh - specify byte 0 for 360/1.2/720
  1574 00004D71 80FBD7              <1> 	cmp	bl,fdc_m_2880		; 2.88M?
  1575 00004D74 7502                <1> 	jne	.fdc_send_specify_cmd	; jump if not 2.88M
  1576 00004D76 B4AF                <1> 	mov	ah,0AFh			; 0AFh - specify byte 0 for 2.88M
  1577                              <1> 
  1578                              <1> .fdc_send_specify_cmd:
  1579 00004D78 BE0200              <1> 	mov	si,2			; specify byte 1
  1580 00004D7B B103                <1> 	mov	cl,3			; 3 bytes command
  1581 00004D7D E85BCF              <1> 	call	fdc_send_cmd
  1582 00004D80 7303E9DE00          <1> 	jc	.error_end_io		; jump if failed to send command
  1583 00004D85 1E                  <1> 	push	ds
  1584 00004D86 31F6                <1> 	xor	si,si
  1585 00004D88 8EDE                <1> 	mov	ds,si
  1586 00004D8A C5367800            <1> 	lds	si,[1Eh*4]		; DS:SI -> INT 1Eh
  1587 00004D8E 8A4E0E              <1> 	mov	cl,byte [bp+int_13_al]	; number of sectors to transfer
  1588 00004D91 B400                <1> 	mov	ah,00h
  1589 00004D93 88C8                <1> 	mov	al,cl			; AX =  number of sectors to transfer
  1590 00004D95 024E0A              <1> 	add	cl,byte [bp+int_13_cl]	; number of the first sector to access
  1591 00004D98 FEC9                <1> 	dec	cl			; minus 1 - last sector to access
  1592 00004D9A 3A4C04              <1> 	cmp	cl,byte [si+4]		; compare with sectors per track
  1593 00004D9D 7603                <1> 	jbe	.calc_dma_count		; jump if last sector <= sectors/track
  1594 00004D9F 884C04              <1> 	mov	byte [si+4],cl		; update it in disk parameter table
  1595                              <1> 
  1596                              <1> .calc_dma_count:
  1597 00004DA2 8A4C03              <1> 	mov	cl,byte [si+3]		; bytes per sector (02h = 512 bytes...)
  1598 00004DA5 80C107              <1> 	add	cl,7			; CL = log2 (bytes per sector)
  1599 00004DA8 D3E0                <1> 	shl	ax,cl			; AX = AL * 2 ^ CL = AX * bytes/sector
  1600 00004DAA 1F                  <1> 	pop	ds
  1601 00004DAB 48                  <1> 	dec	ax			; minus one byte
  1602 00004DAC 89C1                <1> 	mov	cx,ax			; ...count for DMA
  1603                              <1> 
  1604 00004DAE 8A660F              <1> 	mov	ah,byte [bp+int_13_ah]	; AH = function
  1605 00004DB1 B046                <1> 	mov	al,46h			; DMA mode byte for read, channel 2
  1606 00004DB3 80FC02              <1> 	cmp	ah,02h			; read function?
  1607 00004DB6 7409                <1> 	je	.configure_dma		; jump if read function
  1608 00004DB8 B04A                <1> 	mov	al,4Ah			; DMA mode byte for write, channel 2
  1609 00004DBA 80FC03              <1> 	cmp	ah,03h			; write function?
  1610 00004DBD 7402                <1> 	je	.configure_dma		; jump if write function
  1611 00004DBF B042                <1> 	mov	al,42h			; DMA mode byte for verify, channel 2
  1612                              <1> 
  1613                              <1> .configure_dma:
  1614 00004DC1 E8AFCE              <1> 	call	fdc_configure_dma
  1615 00004DC4 8B4E0A              <1> 	mov	cx,word [bp+int_13_cx]	; restore parameters
  1616 00004DC7 7303E99700          <1> 	jc	.error_end_io		; jump if DMA boundry crossed
  1617                              <1> 
  1618 00004DCC E8FFCC              <1> 	call 	fdc_seek		; seek drive DL to cylinder CH, head DH
  1619 00004DCF 7303E98800          <1> 	jc	.error_fdc_get_result	; jump if seek failed
  1620                              <1> 
  1621 00004DD4 1E                  <1> 	push	ds
  1622 00004DD5 31F6                <1> 	xor	si,si
  1623 00004DD7 8EDE                <1> 	mov	ds,si
  1624 00004DD9 C5367800            <1> 	lds	si,[1Eh*4]		; DS:SI -> INT 1Eh
  1625 00004DDD 8A6403              <1> 	mov	ah,byte [si+3]		; AH = sector size (02h = 512)
  1626 00004DE0 88C8                <1> 	mov	al,cl			; AL = first sector number
  1627 00004DE2 89C7                <1> 	mov	di,ax			; DI = first sector, sector size
  1628 00004DE4 8A5C04              <1> 	mov	bl,byte [si+4]		; BL = sectors per track
  1629 00004DE7 8A6C06              <1> 	mov	ch,byte [si+6]		; CH = special sector size
  1630 00004DEA 1F                  <1> 	pop	ds
  1631                              <1> 
  1632 00004DEB 53                  <1> 	push	bx
  1633 00004DEC E83AD1              <1> 	call	get_media_state
  1634 00004DEF 88DA                <1> 	mov	dl,bl			; DL = drive media state
  1635 00004DF1 5B                  <1> 	pop	bx
  1636 00004DF2 B71B                <1> 	mov	bh,1Bh			; read / write gap for 1.2M/1.44M/2.88M
  1637 00004DF4 80FA17              <1> 	cmp	dl,fdc_m_1440		; 1.44M media?
  1638 00004DF7 7413                <1> 	je	.gap_set		; jump if 1.44M media
  1639 00004DF9 80FA15              <1> 	cmp	dl,fdc_m_1200in1200	; 1.2M in 1.2M drive?
  1640 00004DFC 740E                <1> 	je	.gap_set		; jump if 1.2M media in 1.2M drive
  1641 00004DFE 80FAD7              <1> 	cmp	dl,fdc_m_2880		; 2.88 media?
  1642 00004E01 7409                <1> 	je	.gap_set		; jump if 2.88M media
  1643 00004E03 B723                <1> 	mov	bh,23h			; read / write gap for 360K in 1.2M drv
  1644 00004E05 80FA74              <1> 	cmp	dl,fdc_m_360in1200	; 360K in 1.2M drive
  1645 00004E08 7402                <1> 	je	.gap_set		; jump if 360K media in 1.2M drive
  1646 00004E0A B72A                <1> 	mov	bh,2Ah			; read / write gap for 360K and 720K drv
  1647                              <1> 	
  1648                              <1> .gap_set:
  1649 00004E0C 8A7609              <1> 	mov	dh,byte [bp+int_13_dh]	; restore DH
  1650 00004E0F 8A460B              <1> 	mov	al,byte [bp+int_13_ch]	; cylinder
  1651 00004E12 88F4                <1> 	mov	ah,dh			; head
  1652                              <1> 					; replace with mov ah,byte[bp+int_13_dh]
  1653 00004E14 89C6                <1> 	mov	si,ax			; head / cylinder (bytes 2-3)
  1654 00004E16 D0E4                <1> 	shl	ah,1
  1655 00004E18 D0E4                <1> 	shl	ah,1
  1656 00004E1A 0A6608              <1> 	or	ah,byte [bp+int_13_dl]	; FDC command byte 1 (head & drive)
  1657 00004E1D B0E6                <1> 	mov	al,0E6h			; FDC Read command
  1658 00004E1F 807E0F03            <1> 	cmp	byte [bp+int_13_ah],3	; write function?
  1659 00004E23 7502                <1> 	jne	.send_command		; jump if not write 
  1660 00004E25 B0C5                <1> 	mov	al,0C5h			; FDC Write command
  1661                              <1> 
  1662                              <1> .send_command:
  1663 00004E27 B109                <1> 	mov	cl,9			; 9 bytes command
  1664 00004E29 80263E007F          <1> 	and	byte [fdc_calib_state],~fdc_irq_flag ; wait for IRQ
  1665 00004E2E E8AACE              <1> 	call	fdc_send_cmd
  1666 00004E31 7229                <1> 	jc	.error_fdc_get_result	; jump if failed to send command
  1667 00004E33 E8BCD0              <1> 	call	fdc_wait_irq
  1668 00004E36 7224                <1> 	jc	.error_fdc_get_result
  1669 00004E38 B107                <1> 	mov	cl,7
  1670 00004E3A E810CF              <1> 	call	fdc_get_result		; read result bytes
  1671 00004E3D 7224                <1> 	jc	.error_end_io
  1672                              <1> 
  1673 00004E3F E865CF              <1> 	call	fdc_get_error
  1674                              <1> 
  1675 00004E42 8A6E0B              <1> 	mov	ch,byte [bp+int_13_ch]	; CH = cylinder
  1676                              <1> ;	mov	dh,byte [bp+int_13_dh]	; DH = head
  1677                              <1> 					; Optimization: DH is preserved
  1678 00004E45 E8AFCD              <1> 	call	fdc_end_io		; return number of last sector in BL
  1679 00004E48 88D8                <1> 	mov	al,bl			; AL = last transferred sector
  1680 00004E4A 2A460A              <1> 	sub	al,byte [bp+int_13_cl]	; minus the first sector
  1681                              <1> 
  1682                              <1> .zero_sectors:
  1683 00004E4D 08E4                <1> 	or	ah,ah
  1684 00004E4F 7401                <1> 	jz	.exit			; jump if no errors
  1685                              <1> 
  1686                              <1> .error:
  1687 00004E51 F9                  <1> 	stc				; indicate error
  1688                              <1> 
  1689                              <1> .exit:
  1690 00004E52 88264100            <1> 	mov	byte [fdc_last_error],ah
  1691 00004E56 88460E              <1> 	mov	byte [bp+int_13_al],al	; number of transferred sectors
  1692 00004E59 E976FE              <1> 	jmp	int_13_upd_exit
  1693                              <1> 
  1694                              <1> .error_fdc_get_result:
  1695 00004E5C B107                <1> 	mov	cl,7
  1696 00004E5E 50                  <1> 	push	ax
  1697 00004E5F E8EBCE              <1> 	call	fdc_get_result		; read result bytes
  1698 00004E62 58                  <1> 	pop	ax
  1699                              <1> 
  1700                              <1> .error_end_io:
  1701 00004E63 8A6E0B              <1> 	mov	ch,byte [bp+int_13_ch]	; CH = cylinder
  1702 00004E66 8A7609              <1> 	mov	dh,byte [bp+int_13_dh]	; DH = head
  1703 00004E69 E88BCD              <1> 	call	fdc_end_io		; return number of last sector in BL
  1704 00004E6C B000                <1> 	mov	al,00h			; failure, no sectors transferred
  1705 00004E6E EBDD                <1> 	jmp	.zero_sectors
  1706                              <1> 
  1707                              <1> .invalid_request:
  1708 00004E70 B80001              <1> 	mov	ax,fdc_e_invalid << 8	; AH = 01h, AL = 00h (0 sectors trans)
  1709 00004E73 EBDC                <1> 	jmp	.error
  1710                              <1> 
  1711                              <1> ;=========================================================================
  1712                              <1> ; int_13_fn05 - Format track
  1713                              <1> ; Input:
  1714                              <1> ;	AH = 05h
  1715                              <1> ;	CH = track number
  1716                              <1> ;	DH = head number (0 or 1)
  1717                              <1> ;	DL = drive number (0 or 1)
  1718                              <1> ;	ES:BX -> address field buffer
  1719                              <1> ; Output:
  1720                              <1> ;	CF clear if successful
  1721                              <1> ;		AH = 00h - successful completion
  1722                              <1> ;	CF set on error
  1723                              <1> ;		AH = error code 
  1724                              <1> ;-------------------------------------------------------------------------
  1725                              <1> int_13_fn05:
  1726 00004E75 E8B1D0              <1> 	call	get_media_state		; BL = drive media state
  1727 00004E78 F6C310              <1> 	test	bl,fdc_m_established
  1728 00004E7B 7503E98100          <1> 	jz	.timeout		; jump if media type is not established
  1729 00004E80 800E3F0080          <1> 	or	byte [fdc_motor_state],fdc_write_flag ; set the write bit
  1730 00004E85 E8F5CC              <1> 	call	fdc_motor_on
  1731 00004E88 E897CD              <1> 	call	fdc_disk_change		; read disk change line
  1732 00004E8B 726F                <1> 	jc	.error_end_io		; jump if disk change check failed
  1733 00004E8D 88D8                <1> 	mov	al,bl			; media type to AL (transfer rate)
  1734 00004E8F E847D0              <1> 	call	fdc_set_rate		; select transfer rate
  1735 00004E92 E8D5C9              <1> 	call	fdc_send_specify	; send FDC Specify command
  1736                              <1> 
  1737 00004E95 8A6E0B              <1> 	mov	ch,byte [bp+int_13_ch]	; cylinder
  1738 00004E98 E833CC              <1> 	call 	fdc_seek		; seek drive DL to cylinder CH, head DH
  1739 00004E9B 7256                <1> 	jc	.error_fdc_get_result	; jump if seek failed
  1740                              <1> 
  1741 00004E9D 1E                  <1> 	push	ds
  1742 00004E9E 31F6                <1> 	xor	si,si
  1743 00004EA0 8EDE                <1> 	mov	ds,si
  1744 00004EA2 C5367800            <1> 	lds	si,[1Eh*4]		; DS:SI -> INT 1Eh
  1745 00004EA6 8A4C04              <1> 	mov	cl,byte [si+4]		; sectors per track
  1746 00004EA9 8B7C07              <1> 	mov	di,word [si+7]		; format gap, sectors per track
  1747 00004EAC 8B7403              <1> 	mov	si,word [si+3]		; bytes per sector, sectors per track
  1748 00004EAF 1F                  <1> 	pop	ds
  1749                              <1> 
  1750 00004EB0 B500                <1> 	mov	ch,00h			; CX = sectors per track
  1751 00004EB2 D1E1                <1> 	shl	cx,1			; CX = CX * 4 (address field is 4 bytes)
  1752 00004EB4 D1E1                <1> 	shl	cx,1
  1753 00004EB6 49                  <1> 	dec	cx	 		; minus one byte...
  1754 00004EB7 B04A                <1> 	mov	al,4Ah			; DMA mode byte for write, channel 2
  1755 00004EB9 E8B7CD              <1> 	call	fdc_configure_dma
  1756 00004EBC 723E                <1> 	jc	.error_end_io		; DMA boundry crossed
  1757                              <1> 
  1758 00004EBE 88F4                <1> 	mov	ah,dh
  1759 00004EC0 D0E4                <1> 	shl	ah,1
  1760 00004EC2 D0E4                <1> 	shl	ah,1
  1761 00004EC4 0A6608              <1> 	or	ah,byte [bp+int_13_dl]	; FDC command byte 1 (head & drive)
  1762 00004EC7 B04D                <1> 	mov	al,4Dh			; FDC Format command
  1763 00004EC9 B106                <1> 	mov	cl,6			; 6 byte command
  1764 00004ECB 80263E007F          <1> 	and	byte [fdc_calib_state],~fdc_irq_flag ; wait for IRQ
  1765 00004ED0 E808CE              <1> 	call	fdc_send_cmd
  1766 00004ED3 720F                <1> 	jc	.exit_end_io		; jump if failed to send command
  1767 00004ED5 E81AD0              <1> 	call	fdc_wait_irq
  1768 00004ED8 720A                <1> 	jc	.exit_end_io
  1769 00004EDA B107                <1> 	mov	cl,7
  1770 00004EDC E86ECE              <1> 	call	fdc_get_result		; read result bytes
  1771 00004EDF 7203                <1> 	jc	.exit_end_io
  1772 00004EE1 E8C3CE              <1> 	call	fdc_get_error		; get error code
  1773                              <1> 
  1774                              <1> .exit_end_io:
  1775 00004EE4 E810CD              <1> 	call	fdc_end_io
  1776 00004EE7 08E4                <1> 	or	ah,ah
  1777 00004EE9 7401                <1> 	jz	.exit			; jump if no errors
  1778                              <1> 
  1779                              <1> .error:
  1780 00004EEB F9                  <1> 	stc				; indicate error
  1781                              <1> 
  1782                              <1> .exit:
  1783 00004EEC 88264100            <1> 	mov	byte [fdc_last_error],ah
  1784 00004EF0 E9DFFD              <1> 	jmp	int_13_upd_exit
  1785                              <1> 
  1786                              <1> .error_fdc_get_result:
  1787 00004EF3 B107                <1> 	mov	cl,7
  1788 00004EF5 50                  <1> 	push	ax
  1789 00004EF6 E854CE              <1> 	call	fdc_get_result		; read result bytes
  1790 00004EF9 58                  <1> 	pop	ax
  1791 00004EFA EBE8                <1> 	jmp	.exit_end_io
  1792                              <1> 
  1793                              <1> .error_end_io:
  1794 00004EFC E8F8CC              <1> 	call	fdc_end_io
  1795 00004EFF EBEA                <1> 	jmp	.error
  1796                              <1> 
  1797                              <1> .timeout:
  1798 00004F01 B480                <1> 	mov	ah,fdc_e_timeout
  1799 00004F03 EBE6                <1> 	jmp	.error
  1800                              <1> 
  1801                              <1> .invalid_request:
  1802 00004F05 B401                <1> 	mov	ah,fdc_e_invalid
  1803 00004F07 EBE2                <1> 	jmp	.error
  1804                              <1> 
  1805                              <1> ;=========================================================================
  1806                              <1> ; int_0E - IRQ6 (FDC) service routine
  1807                              <1> ; Sets bit 7 in drive recalibration status byte (fdc_calib_state)
  1808                              <1> ;-------------------------------------------------------------------------
  1809 00004F09 FF<rep 4Eh>         <1> 	setloc	0EF57h
  1809          ******************  <1>  warning: Inserting 78 bytes [-w+user]
  1810                              <1> 
  1811                              <1> int_0E:
  1812 00004F57 50                  <1> 	push	ax
  1813 00004F58 1E                  <1> 	push	ds
  1814 00004F59 B84000              <1> 	mov	ax,biosdseg
  1815 00004F5C 8ED8                <1> 	mov	ds,ax
  1816 00004F5E 800E3E0080          <1> 	or	byte [fdc_calib_state],fdc_irq_flag ; set IRQ flag
  1817 00004F63 1F                  <1> 	pop	ds
  1818 00004F64 B020                <1> 	mov	al,20h			; send EOI to PIC
  1819 00004F66 E620                <1> 	out	pic1_reg0,al
  1820 00004F68 B80191              <1> 	mov	ax,9101h		; call "interrupt completed" OS hook
  1821 00004F6B CD15                <1> 	int	15h
  1822 00004F6D 58                  <1> 	pop	ax
  1823 00004F6E CF                  <1> 	iret
  1824                              <1> 
  1825                              <1> ;=========================================================================
  1826                              <1> ; Disk parameter tables in INT 1Eh format
  1827                              <1> ; Byte 0: First byte for specify command:
  1828                              <1> ;	bits 7-4: step rate ([32 ms - value * 2], e.g. 0D0h is 32-13*2 = 6 ms)
  1829                              <1> ;	bits 3-0: head unload time (0Fh = 240 ms)
  1830                              <1> ; Byte 1: Second byte for specify command:
  1831                              <1> ;	bits 7-1: head load time (1 = 4 ms)
  1832                              <1> ;	bit 0: non-DMA mode (always 0)
  1833                              <1> ; Byte 2: motor off timeout in clock ticks (25h - approximately 2 seconds)
  1834                              <1> ; Byte 3: sector size (00h - 128, 01h - 256, 02h - 512, 03h - 1024)
  1835                              <1> ; Byte 4: sectors per track
  1836                              <1> ; Byte 5: gap length for read/write (2Ah for 5.25", 1Bh for 3.5")
  1837                              <1> ; Byte 6: special sector size (0FFh - not used)
  1838                              <1> ; Byte 7: gap length for formating (50h for 5.25", 6Ch for 3.5")
  1839                              <1> ; Byte 8: format filler byte (default 0F6h)
  1840                              <1> ; Byte 9: head settle time in milliseconds
  1841                              <1> ; Byte A: motor start time, in 1/8 seconds
  1842                              <1> ; Byte B: number of cylinders minus one
  1843                              <1> ; Byte C: transfer rate (in bits 7 - 6)
  1844                              <1> ;-------------------------------------------------------------------------
  1845                              <1> media_360_in_360:
  1846 00004F6F DF022502092AFF50F6- <1> 	db	0DFh, 02h, 25h, 02h, 09h, 2Ah, 0FFh, 50h, 0F6h, 0Fh, 08h
  1846 00004F78 0F08                <1>
  1847 00004F7A 2780                <1> 	db	27h, 80h
  1848                              <1> media_1200:
  1849 00004F7C DF0225020F1BFF54F6- <1> 	db	0DFh, 02h, 25h, 02h, 0Fh, 1Bh, 0FFh, 54h, 0F6h, 0Fh, 08h
  1849 00004F85 0F08                <1>
  1850 00004F87 4F00                <1> 	db	4Fh, 00h
  1851                              <1> media_720:
  1852 00004F89 DF022502092AFF50F6- <1> 	db	0DFh, 02h, 25h, 02h, 09h, 2Ah, 0FFh, 50h, 0F6h, 0Fh, 08h
  1852 00004F92 0F08                <1>
  1853 00004F94 4F80                <1> 	db	4Fh, 80h
  1854                              <1> media_1440:
  1855 00004F96 BF022502121BFF6CF6- <1> 	db	0BFh, 02h, 25h, 02h, 12h, 1Bh, 0FFh, 6Ch, 0F6h, 0Fh, 08h
  1855 00004F9F 0F08                <1>
  1856 00004FA1 4F00                <1> 	db	4Fh, 00h
  1857                              <1> media_360_in_1200:
  1858 00004FA3 DF0225020923FF50F6- <1> 	db	0DFh, 02h, 25h, 02h, 09h, 23h, 0FFh, 50h, 0F6h, 0Fh, 08h
  1858 00004FAC 0F08                <1>
  1859 00004FAE 2740                <1> 	db	27h, 40h
  1860                              <1> media_2880:
  1861 00004FB0 AF022502241BFF50F6- <1> 	db	0AFh, 02h, 25h, 02h, 24h, 1Bh, 0FFh, 50h, 0F6h, 0Fh, 08h
  1861 00004FB9 0F08                <1>
  1862 00004FBB 4FC0                <1> 	db	4Fh, 0C0h
  1863                              <1> 
  1864                              <1> ;=========================================================================
  1865                              <1> ; Disk parameter table for IBM compatibility
  1866                              <1> ; Using 2.88M disk as it has maximal number of cylinders and sectors
  1867                              <1> ;-------------------------------------------------------------------------
  1868 00004FBD FF<rep Ah>          <1> 	setloc	0EFC7h
  1868          ******************  <1>  warning: Inserting 10 bytes [-w+user]
  1869                              <1> int_1E:
  1870 00004FC7 AF022502241BFF50F6- <1> 	db	0AFh, 02h, 25h, 02h, 24h, 1Bh, 0FFh, 50h, 0F6h, 0Fh, 08h
  1870 00004FD0 0F08                <1>
  1871                              <1> ;	db	4Fh, 0C0h
  1297                                  %include	"printer2.inc"		; INT 17
  1298                              <1> ;=========================================================================
  1299                              <1> ; printer2.inc - Parallel printer support (part 2 of 2)
  1300                              <1> ;       INT 17h, function AH=00h
  1301                              <1> ;	INT 17h, function AH=02h
  1302                              <1> ;	- see printer1.inc for other INT 17h functions
  1303                              <1> ;-------------------------------------------------------------------------
  1304                              <1> ;
  1305                              <1> ; Compiles with NASM 2.13.02, might work with other versions
  1306                              <1> ;
  1307                              <1> ; Copyright (C) 2010 - 2023 Sergey Kiselev.
  1308                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
  1309                              <1> ;
  1310                              <1> ; This program is free software: you can redistribute it and/or modify
  1311                              <1> ; it under the terms of the GNU General Public License as published by
  1312                              <1> ; the Free Software Foundation, either version 3 of the License, or
  1313                              <1> ; (at your option) any later version.
  1314                              <1> ;
  1315                              <1> ; This program is distributed in the hope that it will be useful,
  1316                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  1317                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  1318                              <1> ; GNU General Public License for more details.
  1319                              <1> ;
  1320                              <1> ; You should have received a copy of the GNU General Public License
  1321                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  1322                              <1> ;
  1323                              <1> ;=========================================================================
  1324                              <1> 
  1325                              <1> ;=========================================================================
  1326                              <1> ; int_17  - BIOS Printer Services
  1327                              <1> ;-------------------------------------------------------------------------
  1328                              <1> 	setloc	0EFD2h			; INT 17 Entry Point
  1329                              <1> int_17:
  1330 00004FD2 FB                  <1> 	sti
  1331 00004FD3 53                  <1> 	push	bx
  1332 00004FD4 52                  <1> 	push	dx
  1333 00004FD5 56                  <1> 	push	si
  1334 00004FD6 1E                  <1> 	push	ds
  1335 00004FD7 BB4000              <1> 	mov	bx,biosdseg
  1336 00004FDA 8EDB                <1> 	mov	ds,bx
  1337 00004FDC 83FA03              <1> 	cmp	dx,num_parallel
  1338 00004FDF 7326                <1> 	jae	int_17_error		; invalid port number specified
  1339 00004FE1 BE7800              <1> 	mov	si,printer_timeout	; printer port timeout setting in BDA
  1340 00004FE4 01D6                <1> 	add	si,dx			; [SI] = timeout for the selected port
  1341 00004FE6 89D3                <1> 	mov	bx,dx
  1342 00004FE8 D1E3                <1> 	shl	bx,1
  1343 00004FEA 8B5708              <1> 	mov	dx,word [equip_parallel+bx] ; DX = serial port address
  1344 00004FED 09D2                <1> 	or	dx,dx
  1345 00004FEF 7416                <1> 	jz	int_17_error		; specified port is not installed
  1346                              <1> 
  1347 00004FF1 88C3                <1> 	mov	bl,al			; save AL to BL
  1348                              <1> 
  1349 00004FF3 08E4                <1> 	or	ah,ah
  1350 00004FF5 7415                <1> 	jz	int_17_fn00		; AH = 00h
  1351 00004FF7 FECC                <1> 	dec	ah
  1352 00004FF9 7503E95BD5          <1> 	jz	int_17_fn01		; AH = 01h
  1353 00004FFE FECC                <1> 	dec	ah
  1354 00005000 7436                <1> 	jz	int_17_fn02		; AH = 02h
  1355                              <1> 
  1356                              <1> int_17_exit:
  1357 00005002 80F448              <1> 	xor	ah,prn_stat_invert	; invert bits 3 and 6 of the status
  1358 00005005 88D8                <1> 	mov	al,bl			; restore AL
  1359                              <1> 
  1360                              <1> int_17_error:
  1361 00005007 1F                  <1> 	pop	ds
  1362 00005008 5E                  <1> 	pop	si
  1363 00005009 5A                  <1> 	pop	dx
  1364 0000500A 5B                  <1> 	pop	bx
  1365 0000500B CF                  <1> 	iret
  1366                              <1> 
  1367                              <1> ;=========================================================================
  1368                              <1> ; int_17_fn00 - Print character
  1369                              <1> ; Input:
  1370                              <1> ;	AH = 0 - function 00h - print character
  1371                              <1> ;	AL = character to print
  1372                              <1> ;	DX = printer port number (0-2)
  1373                              <1> ; Output:
  1374                              <1> ;	AH = printer status:
  1375                              <1> ;		bit 0	= 1	- timeout error
  1376                              <1> ;		bit 1,2		- reserved
  1377                              <1> ;		bit 3	= 1	- I/O error
  1378                              <1> ;		bit 4	= 1	- printed selected
  1379                              <1> ;		bit 5	= 1	- out of paper
  1380                              <1> ;		bit 6	= 1	- acknowledge from printer
  1381                              <1> ;		bit 7	= 1	- printer not busy
  1382                              <1> ;-------------------------------------------------------------------------
  1383                              <1> int_17_fn00:
  1384 0000500C EE                  <1> 	out	dx,al			; output the character to the data port
  1385 0000500D 42                  <1> 	inc	dx			; DX = prn_stat_reg
  1386                              <1> 					; OPTIMIZATION:
  1387                              <1> 					; prn_stat_reg = prn_data_reg + 1
  1388 0000500E EC                  <1> 	in	al,dx			; read status
  1389 0000500F 88C4                <1> 	mov	ah,al			; AH = printer status
  1390 00005011 F6C480              <1> 	test	ah,prn_stat_busy	; check if printer is busy
  1391 00005014 750C                <1>         jnz     .not_busy
  1392                              <1> 
  1393 00005016 B8FE90              <1> 	mov	ax,90FEh		; printer busy
  1394 00005019 CD15                <1> 	int	15h			; call OS hook
  1395                              <1> 
  1396 0000501B B780                <1> 	mov	bh,prn_stat_busy
  1397 0000501D E878D4              <1> 	call	wait_for_port		; wait for printer to be ready
  1398 00005020 750E                <1> 	jnz	.timeout		; timeout had occured
  1399                              <1> 
  1400                              <1> .not_busy:
  1401 00005022 42                  <1> 	inc	dx			; DX = prn_ctrl_reg
  1402                              <1> 					; OPTIMIZATION:
  1403                              <1> 					; prn_ctrl_reg = prn_stat_reg + 1
  1404 00005023 B00D                <1> 	mov	al,(prn_ctrl_sel | prn_ctrl_init | prn_ctrl_strobe)
  1405 00005025 EE                  <1> 	out	dx,al			; activate strobe
  1406 00005026 E6C0                <1> 	out	unused_reg,al		; I/O delay
  1407 00005028 B00C                <1> 	mov	al,(prn_ctrl_sel | prn_ctrl_init)
  1408 0000502A EE                  <1> 	out	dx,al			; de-activate strobe
  1409 0000502B 80E4F8              <1> 	and	ah,prn_stat_bits	; leave only valid status bits
  1410 0000502E EBD2                <1> 	jmp	int_17_exit
  1411                              <1> 
  1412                              <1> .timeout:
  1413 00005030 80E4F8              <1> 	and	ah,prn_stat_bits
  1414 00005033 80CC01              <1> 	or	ah,prn_stat_tmout	; set timeout bit
  1415 00005036 EBCA                <1> 	jmp	int_17_exit
  1416                              <1> 
  1417                              <1> ;=========================================================================
  1418                              <1> ; int_17_fn02 - Return printer status
  1419                              <1> ; Input:
  1420                              <1> ;	AH = 2 - function 02h - return printer status
  1421                              <1> ;	DX = printer port number (0-2)
  1422                              <1> ; Output:
  1423                              <1> ;	AH = printer status (see int_17_fn00 for complete description)
  1424                              <1> ;-------------------------------------------------------------------------
  1425                              <1> int_17_fn02:
  1426 00005038 42                  <1> 	inc	dx			; DX = prn_stat_reg
  1427                              <1> 					; OPTIMIZATION:
  1428                              <1> 					; prn_stat_reg = prn_data_reg + 1
  1429                              <1> int_17_status:
  1430 00005039 EC                  <1> 	in	al,dx			; read the status
  1431 0000503A 88C4                <1> 	mov	ah,al			; move status to AH
  1432 0000503C 80E4F8              <1> 	and	ah,prn_stat_bits	; discard reserved bits
  1433 0000503F EBC1                <1> 	jmp	int_17_exit
  1298                                  %include	"video.inc"		; INT 10
  1299                              <1> ;=========================================================================
  1300                              <1> ; video.inc - BIOS video services
  1301                              <1> ;       INT 10h, functions AH=00h to AH=0Fh
  1302                              <1> ;-------------------------------------------------------------------------
  1303                              <1> ;
  1304                              <1> ; Compiles with NASM 2.13.02, might work with other versions
  1305                              <1> ;
  1306                              <1> ; This code is adopted from XT-clone BIOS by Anonymous
  1307                              <1> ;
  1308                              <1> ; This program is free software: you can redistribute it and/or modify
  1309                              <1> ; it under the terms of the GNU General Public License as published by
  1310                              <1> ; the Free Software Foundation, either version 3 of the License, or
  1311                              <1> ; (at your option) any later version.
  1312                              <1> ;
  1313                              <1> ; This program is distributed in the hope that it will be useful,
  1314                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  1315                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  1316                              <1> ; GNU General Public License for more details.
  1317                              <1> ;
  1318                              <1> ; You should have received a copy of the GNU General Public License
  1319                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  1320                              <1> ;
  1321                              <1> ;=========================================================================
  1322                              <1> 
  1323                              <1> ;-------------------------------------------------------------------------
  1324                              <1> ; CRTC registers
  1325                              <1> crtc_cur_start	equ	0Ah		; CRTC cursor start line register
  1326                              <1> crtc_cur_end	equ	0Bh		; CRTC cursor end line register
  1327                              <1> crtc_offset_hi	equ	0Ch		; CRTC start address high register
  1328                              <1> crtc_offset_lo	equ	0Dh		; CRTC start address low register
  1329                              <1> crtc_cur_pos_hi	equ	0Eh		; CRCT cursor location high register
  1330                              <1> crtc_cur_pos_lo	equ	0Fh		; CRTC cursor location low register
  1331                              <1> crtc_pen_hi	equ	10h		; CRTC light pen position high byte
  1332                              <1> crtc_pen_lo	equ	11h		; CRTC light pen position low byte
  1333                              <1> 
  1334                              <1> ;-------------------------------------------------------------------------
  1335                              <1> ; control characters
  1336                              <1> bel	equ	07h
  1337                              <1> bs	equ	08h
  1338                              <1> lf	equ	0Ah
  1339                              <1> cr	equ	0Dh
  1340                              <1> 
  1341 00005041 FF<rep 4h>          <1> 	setloc	0F045h			; int 10 functions table
  1341          ******************  <1>  warning: Inserting 4 bytes [-w+user]
  1342                              <1> 
  1343                              <1> int_10_dispatch:
  1344 00005045 [0451]              <1> 	dw	int_10_fn00		; Set video mode
  1345 00005047 [B451]              <1> 	dw	int_10_fn01		; Set text mode cursor shape
  1346 00005049 [BE51]              <1> 	dw	int_10_fn02		; Set cursor position
  1347 0000504B [E151]              <1> 	dw	int_10_fn03		; Get cursor position and shape
  1348 0000504D [F551]              <1> 	dw	int_10_fn04		; Read light pen position
  1349 0000504F [8852]              <1> 	dw	int_10_fn05		; Set active display page
  1350 00005051 [B352]              <1> 	dw	int_10_fn06		; Scroll up window
  1351 00005053 [B352]              <1> 	dw	int_10_fn07		; Scroll down window
  1352 00005055 [3954]              <1> 	dw	int_10_fn08		; Read character and attribute
  1353 00005057 [3954]              <1> 	dw	int_10_fn09		; Write character and attribute
  1354 00005059 [3954]              <1> 	dw	int_10_fn0A		; Write character only
  1355 0000505B [1456]              <1> 	dw	int_10_fn0B		; Set background color or palette
  1356 0000505D [3E56]              <1> 	dw	int_10_fn0C		; Write graphics pixel
  1357 0000505F [7656]              <1> 	dw	int_10_fn0D		; Read graphics pixel
  1358 00005061 [9456]              <1> 	dw	int_10_fn0E		; Teletype output
  1359 00005063 [0957]              <1> 	dw	int_10_fn0F		; Get current video mode
  1360                              <1> int_10_num_func	equ ($-int_10_dispatch)/2
  1361                              <1> 
  1362                              <1> 
  1363                              <1> ;-------------------------------------------------------------------------
  1364                              <1> ; offsets for registers on stack
  1365                              <1> 
  1366                              <1> int_10_ax	equ	0
  1367                              <1> int_10_al	equ	int_10_ax
  1368                              <1> int_10_ah	equ	int_10_ax+1
  1369                              <1> int_10_bx	equ	int_10_ax+2
  1370                              <1> int_10_bl	equ	int_10_bx
  1371                              <1> int_10_bh	equ	int_10_bx+1
  1372                              <1> int_10_cx	equ	int_10_bx+2
  1373                              <1> int_10_ch	equ	int_10_cx+1
  1374                              <1> int_10_dx	equ	int_10_cx+2
  1375                              <1> 
  1376                              <1> ;=========================================================================
  1377                              <1> ; int_10 - BIOS video services
  1378                              <1> ; Input:
  1379                              <1> ;	AH - Function
  1380                              <1> ;		00h - Set video mode
  1381                              <1> ;		01h - Set text mode cursor shape
  1382                              <1> ;		02h - Set cursor position
  1383                              <1> ;		03h - Get cursor position and shape
  1384                              <1> ;		04h - Read light pen position
  1385                              <1> ;		05h - Select active display page
  1386                              <1> ;		06h - Scroll up window
  1387                              <1> ;		07h - Scroll down window
  1388                              <1> ;		08h - Read character and attribute at cursor position
  1389                              <1> ;		09h - Write character and attribute at cursor position
  1390                              <1> ;		0Ah - Write character only at cursor position
  1391                              <1> ;		0Bh -
  1392                              <1> ;			BH = 00h - Set background/border color
  1393                              <1> ;			BH = 01h - Set palette
  1394                              <1> ;		0Ch - Write graphics pixel
  1395                              <1> ;		0Dh - Read graphics pixel
  1396                              <1> ;		0Eh - Teletype output
  1397                              <1> ;		0Fh - Get current video mode
  1398                              <1> ;-------------------------------------------------------------------------
  1399                              <1> 	setloc	0F065h			; int 10 Entry Point
  1400                              <1> int_10:
  1401 00005065 FB                  <1> 	sti
  1402 00005066 FC                  <1> 	cld				;  ...strings auto-increment
  1403 00005067 55                  <1> 	push	bp
  1404 00005068 06                  <1> 	push	es
  1405 00005069 1E                  <1> 	push	ds
  1406 0000506A 56                  <1> 	push	si
  1407 0000506B 57                  <1> 	push	di
  1408 0000506C 52                  <1> 	push	dx
  1409 0000506D 51                  <1> 	push	cx
  1410 0000506E 53                  <1> 	push	bx
  1411 0000506F 50                  <1> 	push	ax
  1412 00005070 BB4000              <1> 	mov	bx,biosdseg
  1413 00005073 8EDB                <1> 	mov	ds,bx
  1414 00005075 8A1E4900            <1> 	mov	bl,byte [video_mode]
  1415 00005079 80FB07              <1> 	cmp	bl,07h			; check for monochrome mode
  1416 0000507C BB00B8              <1> 	mov	bx,0B800h		; assume CGA, BX = CGA video segment
  1417 0000507F 7202                <1> 	jb	.color			; it is CGA
  1418 00005081 B7B0                <1> 	mov	bh,0B0h			; else MDA, BX = MDA video segment
  1419                              <1> 
  1420                              <1> .color:
  1421 00005083 8EC3                <1> 	mov	es,bx			; load video segment to ES
  1422 00005085 89E5                <1> 	mov	bp,sp			;  ...start of stack frame
  1423 00005087 80FC10              <1> 	cmp	ah,int_10_num_func	; dispatch table size
  1424 0000508A 730B                <1> 	jae	.exit			; invalid function
  1425 0000508C B700                <1> 	mov	bh,0
  1426 0000508E 88E3                <1> 	mov	bl,ah
  1427 00005090 D1E3                <1> 	shl	bx,1
  1428 00005092 2EFF97[4550]        <1>     cs	call	near [int_10_dispatch+bx]
  1429                              <1> 
  1430                              <1> .exit:
  1431 00005097 58                  <1> 	pop	ax
  1432 00005098 5B                  <1> 	pop	bx
  1433 00005099 59                  <1> 	pop	cx
  1434 0000509A 5A                  <1> 	pop	dx
  1435 0000509B 5F                  <1> 	pop	di
  1436 0000509C 5E                  <1> 	pop	si
  1437 0000509D 1F                  <1> 	pop	ds
  1438 0000509E 07                  <1> 	pop	es
  1439 0000509F 5D                  <1> 	pop	bp
  1440 000050A0 CF                  <1> 	iret
  1441                              <1> 
  1442                              <1> 
  1443                              <1> ;=========================================================================
  1444                              <1> ; int_1D - Video parameters tables
  1445                              <1> ; Contains values loaded to MC6845 CRTC registers 00h to 0Fh during
  1446                              <1> ; video mode initialization
  1447                              <1> ;-------------------------------------------------------------------------
  1448 000050A1 FF<rep 3h>          <1> 	setloc	0F0A4h			; int 1D (MDA and CGA Video Parm Table)
  1448          ******************  <1>  warning: Inserting 3 bytes [-w+user]
  1449                              <1> int_1D:
  1450                              <1> 	; CGA test 40x25 modes
  1451 000050A4 38282D0A1F06191C    <1> 	db	38h, 28h, 2Dh, 0Ah, 1Fh, 06h, 19h, 1Ch
  1452 000050AC 0207060700000000    <1> 	db	02h, 07h, 06h, 07h, 00h, 00h, 00h, 00h
  1453                              <1> 
  1454                              <1> 	; CGA text 80x25 modes
  1455 000050B4 71505A0A1F06191C    <1> 	db	71h, 50h, 5Ah, 0Ah, 1Fh, 06h, 19h, 1Ch
  1456 000050BC 0207060700000000    <1> 	db	02h, 07h, 06h, 07h, 00h, 00h, 00h, 00h
  1457                              <1> 
  1458                              <1> 	; CGA graphics modes
  1459 000050C4 38282D0A7F066470    <1> 	db	38h, 28h, 2Dh, 0Ah, 7Fh, 06h, 64h, 70h
  1460 000050CC 0201060700000000    <1> 	db	02h, 01h, 06h, 07h, 00h, 00h, 00h, 00h
  1461                              <1> 
  1462                              <1> 	; MDA text 80x25 mode
  1463 000050D4 6150520F19061919    <1> 	db	61h, 50h, 52h, 0Fh, 19h, 06h, 19h, 19h
  1464 000050DC 020D0B0C00000000    <1> 	db	02h, 0Dh, 0Bh, 0Ch, 00h, 00h, 00h, 00h
  1465                              <1> 
  1466                              <1> page_size:
  1467 000050E4 0008                <1> 	dw	0800h			; text 40x25 mode
  1468 000050E6 0010                <1> 	dw	1000h			; text 80x25 mode
  1469 000050E8 0040                <1> 	dw	4000h			; graphics modes
  1470 000050EA 0040                <1> 	dw	4000h
  1471                              <1> 
  1472                              <1> columns:
  1473 000050EC 2828                <1> 	db	40, 40			; modes 0, 1 - 40x25
  1474 000050EE 5050                <1> 	db	80, 80			; modes 2, 3 - 80x25
  1475 000050F0 2828                <1> 	db	40, 40			; modes 4, 5 - 40x25
  1476 000050F2 5050                <1> 	db	80, 80			; modes 6, 7 - 80x25
  1477                              <1> 
  1478 000050F4 2C282D292A2E1E29    <1> MODES	db	2Ch,28h,2Dh,29h,2Ah,2Eh,1Eh,29h ; Table of mode sets
  1479                              <1> 
  1480 000050FC 0000101020202030    <1> TABMUL	db	00h,00h,10h,10h,20h,20h,20h,30h ; Table lookup for multiply
  1481                              <1> 
  1482                              <1> ;=========================================================================
  1483                              <1> ; int_10_fn00 - Set video mode
  1484                              <1> ; Input:
  1485                              <1> ;	AH = 00h
  1486                              <1> ;	AL = video mode
  1487                              <1> ;		00h - CGA - text 40x25, 16 shades of gray
  1488                              <1> ;		01h - CGA - text 40x25, 16 colors
  1489                              <1> ;		02h - CGA - text 80x25, 16 shades of gray
  1490                              <1> ;		03h - CGA - text 80x25, 16 colors
  1491                              <1> ;		04h - CGA - graphics 320x200, 4 colors
  1492                              <1> ;		05h - CGA - graphics 320x200, 4 shades of gray
  1493                              <1> ;		06h - CGA - graphics 640x200, monochrome
  1494                              <1> ;		07h - MDA - text 80x25, monochrome
  1495                              <1> ;-------------------------------------------------------------------------
  1496                              <1> int_10_fn00:
  1497 00005104 8A5E00              <1> 	mov	bl,byte [bp+int_10_al]	; BL = video mode
  1498                              <1> 					; assume CGA mode
  1499 00005107 B900B8              <1> 	mov	cx,0B800h		; CGA video memory segment
  1500 0000510A BAD403              <1> 	mov	dx,3D4h			; port for MC6845 CRTC address register
  1501 0000510D A01000              <1> 	mov	al,byte [equipment_list] ; get equipment - low byte
  1502 00005110 2430                <1> 	and	al,equip_video		; get video adapter type
  1503 00005112 3C30                <1> 	cmp	al,equip_mono		; monochrome?
  1504 00005114 B000                <1> 	mov	al,0
  1505 00005116 7507                <1> 	jne	.color			; jump if CGA/color mode
  1506                              <1> 					; set MDA mode
  1507 00005118 B307                <1> 	mov	bl,07h			; MDA can only be 7
  1508 0000511A B5B0                <1> 	mov	ch,0B0h			; MDA video memory segment
  1509 0000511C B2B4                <1> 	mov	dl,0B4h 		; port for MC6845 CRTC address register
  1510 0000511E 40                  <1> 	inc	ax
  1511                              <1> 
  1512                              <1> .color:
  1513 0000511F 8EC1                <1> 	mov	es,cx			; ES = video memory segment
  1514 00005121 89166300            <1> 	mov	word [video_port],dx	; Save current CRTC display port
  1515 00005125 80C204              <1> 	add	dl,4
  1516 00005128 EE                  <1> 	out	dx,al			; Reset the video
  1517 00005129 881E4900            <1> 	mov	byte [video_mode],bl	; Save current CRTC mode
  1518 0000512D B700                <1> 	mov	bh,0
  1519 0000512F 53                  <1> 	push	bx
  1520 00005130 06                  <1> 	push	es
  1521 00005131 31C0                <1> 	xor	ax,ax
  1522 00005133 8EC0                <1> 	mov	es,ax			; Load interrupt table segment to ES
  1523 00005135 26C4367400          <1>     es	les	si,[1Dh*4]		; Load video parameters table
  1524                              <1> 					; (INT 1Dh vector) to ES:SI
  1525 0000513A 2E8A9F[FC50]        <1>     cs	mov	bl,byte [bx+TABMUL]	; Get BL for indexing into int_1D
  1526 0000513F 01DE                <1> 	add	si,bx
  1527                              <1> 
  1528 00005141 268B4C0A            <1>     es	mov	cx,word [si+crtc_cur_start] ; cursor shape from INT 1Dh table
  1529 00005145 86CD                <1> 	xchg	cl,ch			; convert to LSB format
  1530 00005147 890E6000            <1> 	mov	word [video_cur_shape],cx ; store cursor shape
  1531                              <1> 
  1532 0000514B B91000              <1> 	mov	cx,10h			; Sixteen values to send
  1533                              <1> 
  1534                              <1> .setup_crt_loop:
  1535 0000514E 268A04              <1>     es	mov	al,byte [si]		; Value to send in SI
  1536 00005151 E8E305              <1> 	call	vid_crtc_writeb			;  ...send it
  1537 00005154 FEC4                <1> 	inc	ah			;  ...bump count
  1538 00005156 46                  <1> 	inc	si			;  ...point to next
  1539 00005157 E2F5                <1> 	loop	.setup_crt_loop		;  ...loop until done
  1540 00005159 07                  <1> 	pop	es
  1541 0000515A 31FF                <1> 	xor	di,di
  1542 0000515C B90020              <1> 	mov	cx,2000h		; video memory size for CGA
  1543 0000515F 31C0                <1> 	xor	ax,ax			; fill word for graphics mode
  1544 00005161 E8B805              <1> 	call	vid_check_mode		; Set flags according to mode
  1545 00005164 7208                <1> 	jc	.clear_screen		; jump if graphics mode
  1546 00005166 7503                <1> 	jnz	.text_fill		; jump if CGA mode
  1547 00005168 B90008              <1> 	mov	cx,0800h 		; video memory size for MDA
  1548                              <1> 
  1549                              <1> .text_fill:
  1550 0000516B B82007              <1> 	mov	ax,07h << 8 | ' '	; fill word for test mode
  1551                              <1> 
  1552                              <1> .clear_screen:
  1553 0000516E F3AB                <1> 	repz	stosw			; clear screen with fill word
  1554                              <1> 
  1555 00005170 8B166300            <1> 	mov	dx,word [video_port]	; Get the port
  1556 00005174 80C204              <1> 	add	dl,4
  1557 00005177 5B                  <1> 	pop	bx
  1558 00005178 2E8A87[F450]        <1>     cs	mov	al,byte [bx+MODES]	; Load data to set for mode
  1559 0000517D EE                  <1> 	out	dx,al			;  ...and send it
  1560 0000517E A26500              <1> 	mov	byte [video_mode_reg],al ;  ...then save active data
  1561 00005181 42                  <1> 	inc	dx
  1562 00005182 B030                <1> 	mov	al,30h			; Assume not 640 x 200 b/w
  1563 00005184 80FB06              <1> 	cmp	bl,6			;  ...correct?
  1564 00005187 7502                <1> 	jnz	.set_palette
  1565 00005189 B03F                <1> 	mov	al,3Fh			; Palette for 640 x 200 b/w
  1566                              <1> 
  1567                              <1> .set_palette:
  1568 0000518B A26600              <1> 	mov	byte [video_palet_reg],al ;  ...save palette
  1569 0000518E EE                  <1> 	out	dx,al			;  ...send palette
  1570                              <1> 
  1571 0000518F 8CD8                <1> 	mov	ax,ds
  1572 00005191 8EC0                <1> 	mov	es,ax
  1573 00005193 31C0                <1> 	xor	ax,ax
  1574 00005195 A26200              <1> 	mov	byte [video_page],al	;  ...active page=page 0
  1575 00005198 B90900              <1> 	mov	cx,9			; video_page_offt + video_cur_pos * 8
  1576 0000519B BF4E00              <1> 	mov	di,video_page_offt
  1577 0000519E F3AB                <1>  	rep	stosw			; zero page offset and cursor position
  1578                              <1> 
  1579 000051A0 2E8A87[EC50]        <1>     cs	mov	al,byte [bx+columns]	; Get display width
  1580 000051A5 A34A00              <1> 	mov	word [video_columns],ax	;  ...save it
  1581 000051A8 80E3FE              <1> 	and	bl,0FEh			; Clear the LSB to get an index
  1582                              <1> 					; to 16-bit word page_size table
  1583                              <1> 					; FIXME: It returns graphics mode page
  1584                              <1> 					; size for mode 7. Probably not
  1585                              <1> 					; critical, as MDA has only one page
  1586 000051AB 2E8B87[E450]        <1>     cs	mov	ax,word [bx+page_size]	; Get video page size
  1587 000051B0 A34C00              <1> 	mov	word [video_page_size],ax ;  ...save it
  1588 000051B3 C3                  <1> 	ret
  1589                              <1> 
  1590                              <1> ;=========================================================================
  1591                              <1> ; int_10_fn01 - Set text-mode cursor shape
  1592                              <1> ; Input:
  1593                              <1> ;	AH = 01h
  1594                              <1> ;	CH = cursor scan line start
  1595                              <1> ;	CL = cursor scan line end
  1596                              <1> ; Output:
  1597                              <1> ;	none
  1598                              <1> ;-------------------------------------------------------------------------
  1599                              <1> int_10_fn01:
  1600 000051B4 890E6000            <1> 	mov	word [video_cur_shape],cx ; save cursor shape to BIOS data area
  1601 000051B8 B40A                <1> 	mov	ah,crtc_cur_start	; select CRTC cursor shape registers
  1602 000051BA E87105              <1> 	call	vid_crtc_writew		; write it to CRTC
  1603 000051BD C3                  <1> 	ret
  1604                              <1> 
  1605                              <1> ;=========================================================================
  1606                              <1> ; int_10_fn02 - Set cursor position
  1607                              <1> ; Input:
  1608                              <1> ;	AH = 02h
  1609                              <1> ;	BH = page number
  1610                              <1> ;	DH = cursor row (00h is top)
  1611                              <1> ;	DL = cursor column (00h is left)
  1612                              <1> ; Output:
  1613                              <1> ;	none
  1614                              <1> ;-------------------------------------------------------------------------
  1615                              <1> int_10_fn02:
  1616 000051BE 8A5E03              <1> 	mov	bl,byte [bp+int_10_bh]	; BL = page number
  1617 000051C1 381E6200            <1> 	cmp	byte [video_page],bl	; is it on current page?
  1618 000051C5 7512                <1> 	jne	bios_set_cur_pos	; if not visible only update BIOS data
  1619                              <1> 
  1620                              <1> ;=========================================================================
  1621                              <1> ; set_cur_pos - set CRTC cursor position, update BIOS cursor location
  1622                              <1> ;	BL = page
  1623                              <1> ;	DH = cursor row (00h is top)
  1624                              <1> ;	DL = cursor column (00h is left)
  1625                              <1> ;-------------------------------------------------------------------------
  1626                              <1> set_cur_pos:
  1627 000051C7 89D0                <1> 	mov	ax,dx			; AX = cursor position
  1628 000051C9 E8AA05              <1> 	call	vid_position_to_offset			; AX - offset
  1629 000051CC 03064E00            <1> 	add	ax,word [video_page_offt]	;  + byte offset, regen reg.
  1630 000051D0 D1E8                <1> 	shr	ax,1
  1631 000051D2 89C1                <1> 	mov	cx,ax
  1632 000051D4 B40E                <1> 	mov	ah,crtc_cur_pos_hi	; CRCT cursor location high register
  1633 000051D6 E85505              <1> 	call	vid_crtc_writew		; send cursor position to CRTC
  1634                              <1> bios_set_cur_pos:
  1635 000051D9 B700                <1> 	mov	bh,0
  1636 000051DB D0E3                <1> 	shl	bl,1			; index to words table
  1637 000051DD 895750              <1> 	mov	word [bx+video_cur_pos],dx ; save position to BIOS data area
  1638 000051E0 C3                  <1> 	ret
  1639                              <1> 
  1640                              <1> ;=========================================================================
  1641                              <1> ; int_10_fn03 - Get cursor position and shape
  1642                              <1> ; Input:
  1643                              <1> ;	AH = 03h
  1644                              <1> ;	BH = page number
  1645                              <1> ; Output:
  1646                              <1> ;	CH = cursor start scan line
  1647                              <1> ;	CL = cursor end scan line
  1648                              <1> ;	DH = cursor row (00h is top)
  1649                              <1> ;	DL = cursor column (00h is left)
  1650                              <1> ;-------------------------------------------------------------------------
  1651                              <1> int_10_fn03:
  1652 000051E1 B700                <1> 	mov	bh,0
  1653 000051E3 8A5E03              <1> 	mov	bl,byte [bp+int_10_bh]	; BL = page number
  1654 000051E6 D0E3                <1> 	shl	bl,1
  1655 000051E8 8B4750              <1> 	mov	ax,word [bx+video_cur_pos] ; get current cursor position
  1656 000051EB 894606              <1> 	mov	word [bp+int_10_dx],ax	; return position in DX
  1657 000051EE A16000              <1> 	mov	ax,word [video_cur_shape]  ; get cursor shape
  1658 000051F1 894604              <1> 	mov	word [bp+int_10_cx],ax	; return cursor shape in CX
  1659 000051F4 C3                  <1> 	ret
  1660                              <1> 
  1661                              <1> ;=========================================================================
  1662                              <1> ; int_10_fn04 - Read light pen position
  1663                              <1> ; Input:
  1664                              <1> ;	AH = 04h
  1665                              <1> ; Output:
  1666                              <1> ;	AH - light pen trigger flag
  1667                              <1> ;		00h not down/triggered
  1668                              <1> ;		01h down/triggered
  1669                              <1> ;	If light pen is triggered:
  1670                              <1> ;		DH = character row
  1671                              <1> ;		DL = character column
  1672                              <1> ;		CH = pixel row
  1673                              <1> ;		BX = pixel column
  1674                              <1> ;-------------------------------------------------------------------------
  1675                              <1> int_10_fn04:
  1676 000051F5 C6460100            <1> 	mov	byte [bp+int_10_ah],0	; set AH = 0, light pen not triggered
  1677 000051F9 8B166300            <1> 	mov	dx,word [video_port]
  1678 000051FD 80C206              <1> 	add	dl,6			; CRTC status register
  1679 00005200 EC                  <1> 	in	al,dx			; read it
  1680 00005201 A804                <1> 	test	al,4			; test light pen switch bit
  1681 00005203 7472                <1> 	jz	.reset_pen		; reset pen and return if switch is off
  1682 00005205 A802                <1> 	test	al,2			; test light pen tigger bit
  1683 00005207 7501                <1> 	jnz	.read_pen		; continue if triggered
  1684 00005209 C3                  <1> 	ret				; not triggered - return
  1685                              <1> 
  1686                              <1> .read_pen:
  1687 0000520A 8B166300            <1> 	mov	dx,word [video_port]	; CRTC index register
  1688 0000520E B010                <1> 	mov	al,crtc_pen_hi		; CRTC pen position high byte register
  1689 00005210 EE                  <1> 	out	dx,al			; select it
  1690 00005211 42                  <1> 	inc	dx			; CRTC data register
  1691 00005212 EC                  <1> 	in	al,dx			; read high byte of pen position
  1692 00005213 88C4                <1> 	mov	ah,al
  1693 00005215 4A                  <1> 	dec	dx			; CRTC index register
  1694 00005216 B011                <1> 	mov	al,crtc_pen_lo		; CRTC pen position low byte register
  1695 00005218 EE                  <1> 	out	dx,al			; select it
  1696 00005219 42                  <1> 	inc	dx			; CRTC data register
  1697 0000521A EC                  <1> 	in	al,dx			; read low byte of pen position
  1698                              <1> 
  1699 0000521B B700                <1> 	mov	bh,0
  1700 0000521D 8A1E4900            <1> 	mov	bl,byte [video_mode]	; get current video mode
  1701 00005221 2E8A9F[8052]        <1>     cs	mov	bl,byte [bx+.correction] ; light pen correction factor
  1702 00005226 29D8                <1> 	sub	ax,bx
  1703 00005228 7902                <1> 	jns	.1
  1704 0000522A 31C0                <1> 	xor	ax,ax			; set to zero if negative result
  1705                              <1> 
  1706                              <1> .1:
  1707 0000522C E8ED04              <1> 	call	vid_check_mode			; check video mode
  1708 0000522F 7325                <1> 	jnc	.text			; calculate character position if text
  1709 00005231 B228                <1> 	mov	dl,40			; divide by 40
  1710 00005233 F6F2                <1> 	div	dl			; AL = row, AH = column (reminder)
  1711 00005235 B700                <1> 	mov	bh,0
  1712 00005237 88E3                <1> 	mov	bl,ah
  1713 00005239 B103                <1> 	mov	cl,3
  1714 0000523B D3E3                <1> 	shl	bx,cl			; BX = AH * 8 - pixel column
  1715 0000523D 88C5                <1> 	mov	ch,al
  1716 0000523F D0E5                <1> 	shl	ch,1			; CH = AL * 2 - pixel row
  1717 00005241 88E2                <1> 	mov	dl,ah			; DL = AH - character column
  1718 00005243 88C6                <1> 	mov	dh,al
  1719 00005245 D0EE                <1> 	shr	dh,1
  1720 00005247 D0EE                <1> 	shr	dh,1			; DH = AL / 4 - character row
  1721 00005249 803E490006          <1> 	cmp	byte [video_mode],6	; check for 640x200 mode
  1722 0000524E 751A                <1> 	jnz	.exit
  1723 00005250 D1E3                <1> 	shl	bx,1			; adjust pixel column (double it)
  1724 00005252 D0E2                <1> 	shl	dl,1			; same or character column
  1725 00005254 EB14                <1> 	jmp	.exit
  1726                              <1> 
  1727                              <1> .text:
  1728 00005256 F6364A00            <1> 	div	byte [video_columns] 	; divide by number of columns
  1729 0000525A 86C4                <1> 	xchg	al,ah			; AL = column, AH = row
  1730 0000525C 89C2                <1> 	mov	dx,ax			; save characer row,column to DH,AL
  1731 0000525E B103                <1> 	mov	cl,3
  1732 00005260 D2E4                <1> 	shl	ah,cl
  1733 00005262 88E5                <1> 	mov	ch,ah			; CH = AH * 8 - pixel row
  1734 00005264 B700                <1> 	mov	bh,0
  1735 00005266 88C3                <1> 	mov	bl,al
  1736 00005268 D3E3                <1> 	shl	bx,cl			; BX = AL * 8 - pixel column
  1737                              <1> 
  1738                              <1> .exit:
  1739 0000526A C6460101            <1> 	mov	byte [bp+int_10_ah],1	; set AH = 1, light pen triggered
  1740 0000526E 895606              <1> 	mov	word [bp+int_10_dx],dx	;  ...row, column in user dx
  1741 00005271 895E02              <1> 	mov	word [bp+int_10_bx],bx	;  ...pixel column in user bx
  1742 00005274 886E05              <1> 	mov	byte [bp+int_10_ch],ch	;  ...raster line in user ch
  1743                              <1> 
  1744                              <1> .reset_pen:
  1745 00005277 8B166300            <1> 	mov	dx,word [video_port]	; Get port of active CRTC card
  1746 0000527B 80C207              <1> 	add	dl,7			; clear light pen strobe reg
  1747 0000527E EE                  <1> 	out	dx,al			; reset it
  1748 0000527F C3                  <1> 	ret
  1749                              <1> 
  1750                              <1> .correction:
  1751 00005280 0303050503030304    <1> 	db	3, 3, 5, 5, 3, 3, 3, 4	; light pen correction
  1752                              <1> 
  1753                              <1> ;=========================================================================
  1754                              <1> ; int_10_fn05 - Select active display page
  1755                              <1> ; Input:
  1756                              <1> ;	AH = 05h
  1757                              <1> ;	AL - new page number (00h is the first page)
  1758                              <1> ; Output:
  1759                              <1> ;	none
  1760                              <1> ;-------------------------------------------------------------------------
  1761                              <1> int_10_fn05:
  1762 00005288 A26200              <1> 	mov	byte [video_page],al	; update page number in BIOS data area
  1763 0000528B 88C3                <1> 	mov	bl,al			; also copy it to BL
  1764 0000528D B400                <1> 	mov	ah,0
  1765 0000528F F7264C00            <1> 	mul	word [video_page_size]	; calculate page offset
  1766 00005293 A34E00              <1> 	mov	word [video_page_offt],ax ; save the offset
  1767 00005296 D1E8                <1> 	shr	ax,1			; calculate CRTC page start address
  1768 00005298 89C1                <1> 	mov	cx,ax			; save a copy to CX
  1769 0000529A B40C                <1> 	mov	ah,crtc_offset_hi	; CRTC start address high register
  1770 0000529C E88F04              <1> 	call	vid_crtc_writew		; write new offset to CRTC
  1771                              <1> 
  1772 0000529F B700                <1> 	mov	bh,0
  1773 000052A1 D1E3                <1> 	shl	bx,1
  1774 000052A3 8B4750              <1> 	mov	ax,word [bx+video_cur_pos] ; AX - cursor position for new page
  1775 000052A6 E8CD04              <1> 	call	vid_position_to_offset			; AX - offset relative to start of page
  1776 000052A9 D1E8                <1> 	shr	ax,1
  1777 000052AB 01C1                <1> 	add	cx,ax			; add to the page offset
  1778 000052AD B40E                <1> 	mov	ah,crtc_cur_pos_hi	; CRCT cursor location high register
  1779 000052AF E87C04              <1> 	call	vid_crtc_writew		; send cursor position to CRTC
  1780 000052B2 C3                  <1> 	ret
  1781                              <1> 
  1782                              <1> ;=========================================================================
  1783                              <1> ; int_10_fn06 - scroll up window
  1784                              <1> ; int_10_fn07 - scroll down window
  1785                              <1> ; Input:
  1786                              <1> ;	AH = 06h (scroll up) or AH = 07 (scroll down)
  1787                              <1> ;	AL = number of rows by which to scroll up (00h = clear entire window)
  1788                              <1> ;	BH = attribute used to write blank rows at bottom of window
  1789                              <1> ;	CH,CL = row,column of window's upper left corner
  1790                              <1> ;	DH,DL = row,column of window's lower right corner
  1791                              <1> ; Output:
  1792                              <1> ;	none
  1793                              <1> ; TODO:
  1794                              <1> ;	optimize graphics fill
  1795                              <1> ;-------------------------------------------------------------------------
  1796                              <1> int_10_fn06:
  1797                              <1> int_10_fn07:
  1798 000052B3 E86604              <1> 	call	vid_check_mode
  1799 000052B6 7303E9D900          <1> 	jc	.graphics_scroll
  1800                              <1> 
  1801 000052BB 31F6                <1> 	xor	si,si			; SI - "snow" workaround not required
  1802 000052BD 803E490002          <1> 	cmp	byte [video_mode],2
  1803 000052C2 720A                <1> 	jb	.no_snow
  1804 000052C4 803E490003          <1> 	cmp	byte [video_mode],3
  1805 000052C9 7703                <1> 	ja	.no_snow
  1806 000052CB BE5555              <1> 	mov	si,0101010101010101b	; CGA "snow" workaround required
  1807                              <1> ;	mov	si,0001000100010001b	; CGA "snow" workaround required
  1808                              <1> .no_snow:
  1809 000052CE 8B4606              <1> 	mov	ax,word [bp+int_10_dx]	; AX = window's lower right corner
  1810 000052D1 50                  <1> 	push	ax
  1811 000052D2 807E0107            <1> 	cmp	byte [bp+int_10_ah],07h	; check for scroll down function
  1812 000052D6 7403                <1> 	jz	.1			; jump if scroll down
  1813 000052D8 8B4604              <1> 	mov	ax,word [bp+int_10_cx]	; AX = window's upper left corner
  1814                              <1> 
  1815                              <1> .1:
  1816 000052DB E89804              <1> 	call	vid_position_to_offset
  1817 000052DE 03064E00            <1> 	add	ax,word [video_page_offt]
  1818 000052E2 89C7                <1> 	mov	di,ax			; DI = scroll copy destination address
  1819                              <1> 
  1820                              <1> ; calculate scroll window size (DX)
  1821                              <1> 
  1822 000052E4 5A                  <1> 	pop	dx			; DX = window's lower right corner
  1823 000052E5 2B5604              <1> 	sub	dx,word [bp+int_10_cx]	; substract windows's upper left corner
  1824 000052E8 81C20101            <1> 	add	dx,101h 		; add 1x1
  1825                              <1> 
  1826                              <1> ; calculate offset between the source and the destination (AX)
  1827                              <1> 
  1828 000052EC 8B1E4A00            <1> 	mov	bx,word [video_columns]	; BX = columns (note BX <= 80)
  1829 000052F0 D1E3                <1> 	shl	bx,1			; each character takes two bytes
  1830 000052F2 8A4600              <1> 	mov	al,byte [bp+int_10_al]	; AL = number of rows to scroll
  1831 000052F5 52                  <1> 	push    dx
  1832 000052F6 B400                <1>         mov     ah,0
  1833 000052F8 F7E3                <1>         mul     bx
  1834 000052FA 5A                  <1>         pop     dx
  1835                              <1> 
  1836 000052FB 28D3                <1> 	sub	bl,dl			; BX = distance between end of one
  1837 000052FD 28D3                <1> 	sub	bl,dl			;   row and beggining of another
  1838 000052FF 1E                  <1> 	push	ds
  1839 00005300 8CC1                <1> 	mov	cx,es
  1840 00005302 8ED9                <1> 	mov	ds,cx			; load video segment to DS
  1841 00005304 807E0106            <1> 	cmp	byte [bp+int_10_ah],06h	; check for scroll up function
  1842 00005308 7405                <1> 	jz	.2			; jump if scroll up
  1843 0000530A F7D8                <1> 	neg	ax			; negate offset
  1844 0000530C F7DB                <1> 	neg	bx			; negate distance
  1845 0000530E FD                  <1> 	std				; copy backwards
  1846                              <1> 
  1847                              <1> .2:
  1848 0000530F 8A4E00              <1> 	mov	cl,byte [bp+int_10_al]	; CL = number of rows to scroll
  1849 00005312 08C9                <1> 	or	cl,cl
  1850 00005314 7423                <1> 	jz	.text_fill_only		; jump if clear window only requested
  1851 00005316 96                  <1> 	xchg	ax,si			; AX = snow workaround flag, SI = offset
  1852 00005317 01FE                <1> 	add	si,di			; SI = scroll copy source address
  1853 00005319 28CE                <1> 	sub	dh,cl			; DH = number of rows to copy
  1854                              <1> 
  1855 0000531B 09DB                <1> 	or	bx,bx
  1856 0000531D 7434                <1> 	jz	.text_full_row_scroll
  1857                              <1> 
  1858                              <1> .text_scroll_loop:
  1859 0000531F B500                <1> 	mov	ch,0
  1860 00005321 88D1                <1> 	mov	cl,dl			; CX = characters in row to copy
  1861                              <1> 
  1862 00005323 D1C8                <1> 	ror	ax,1			; rotate snow workaround flag
  1863 00005325 7303                <1> 	jnc	.text_scroll_no_retrace
  1864 00005327 E85800              <1> 	call	.retrace_wait
  1865                              <1> 
  1866                              <1> .text_scroll_no_retrace:
  1867 0000532A F3A5                <1> 	repz	movsw			; copy one row
  1868                              <1> 
  1869                              <1> ;.text_scroll_next_row:
  1870 0000532C 01DE                <1> 	add	si,bx			; SI = next row to copy source address
  1871 0000532E 01DF                <1> 	add	di,bx			; DI = next row to copy destination
  1872 00005330 FECE                <1> 	dec	dh			; decrement row counter
  1873 00005332 75EB                <1> 	jnz	.text_scroll_loop	; jump if there is more rows to copy
  1874                              <1> 
  1875                              <1> .text_fill:
  1876 00005334 8A7600              <1> 	mov	dh,byte [bp+int_10_al]	; DH = number of rows to fill
  1877 00005337 89C6                <1> 	mov	si,ax			; SI = snow workaround flag
  1878                              <1> 
  1879                              <1> .text_fill_only:
  1880 00005339 B500                <1> 	mov	ch,0
  1881 0000533B 8A6603              <1> 	mov	ah,byte [bp+int_10_bh]	; AH = blank attribute
  1882 0000533E B020                <1> 	mov	al,' '			; AL = blank character
  1883                              <1> 
  1884                              <1> .text_fill_loop:
  1885 00005340 88D1                <1> 	mov	cl,dl			; CX = characters in row to fill
  1886 00005342 D1CE                <1> 	ror	si,1			; rotate snow workaround flag
  1887 00005344 7303                <1> 	jnc	.text_fill_no_retrace	; jump if LSB was zero - no wait
  1888 00005346 E83900              <1> 	call	.retrace_wait		; wait for vertical retrace
  1889                              <1> 
  1890                              <1> .text_fill_no_retrace:
  1891 00005349 F3AB                <1> 	repz	stosw			; fill one row
  1892 0000534B 01DF                <1> 	add	di,bx			; DI = next row to fill destination
  1893 0000534D FECE                <1> 	dec	dh			; decrement row counter
  1894 0000534F 75EF                <1> 	jnz	.text_fill_loop		; jump if there is more rows to fill
  1895                              <1> 
  1896 00005351 1F                  <1> 	pop	ds
  1897 00005352 C3                  <1> 	ret
  1898                              <1> 
  1899                              <1> .text_full_row_scroll:
  1900 00005353 09C0                <1> 	or	ax,ax
  1901 00005355 741F                <1> 	jz	.text_full_row_no_snow
  1902 00005357 50                  <1> 	push	ax
  1903 00005358 88D0                <1> 	mov	al,dl
  1904 0000535A F6E6                <1> 	mul	dh
  1905                              <1> 
  1906                              <1> .text_full_row_loop:
  1907 0000535C B9F000              <1> 	mov	cx,240
  1908 0000535F 39C8                <1> 	cmp	ax,cx
  1909 00005361 7705                <1> 	ja	.copy_chunk
  1910 00005363 91                  <1> 	xchg	ax,cx
  1911 00005364 31C0                <1> 	xor	ax,ax
  1912 00005366 EB02                <1> 	jmp	.do_copy
  1913                              <1> 
  1914                              <1> .copy_chunk:
  1915 00005368 29C8                <1> 	sub	ax,cx
  1916                              <1> 
  1917                              <1> .do_copy:
  1918 0000536A E81500              <1> 	call	.retrace_wait
  1919 0000536D F3A5                <1> 	rep	movsw
  1920 0000536F 09C0                <1> 	or	ax,ax
  1921 00005371 75E9                <1> 	jnz	.text_full_row_loop
  1922 00005373 58                  <1> 	pop	ax
  1923 00005374 EBBE                <1> 	jmp	.text_fill
  1924                              <1> 
  1925                              <1> .text_full_row_no_snow:
  1926 00005376 50                  <1> 	push	ax
  1927 00005377 88D0                <1> 	mov	al,dl
  1928 00005379 F6E6                <1> 	mul	dh
  1929 0000537B 89C1                <1> 	mov	cx,ax
  1930 0000537D F3A5                <1> 	rep	movsw
  1931 0000537F 58                  <1> 	pop	ax
  1932 00005380 EBB2                <1> 	jmp	.text_fill
  1933                              <1> 
  1934                              <1> ;-------------------------------------------------------------------------
  1935                              <1> ; .retrace_wait - next till the next vertical retrace
  1936                              <1> 
  1937                              <1> .retrace_wait:
  1938 00005382 50                  <1> 	push	ax
  1939 00005383 52                  <1> 	push	dx
  1940 00005384 BADA03              <1> 	mov	dx,03DAh		; DX = CGA status register
  1941                              <1> 
  1942                              <1> .retrace_wait_not_set:
  1943 00005387 EC                  <1> 	in	al,dx
  1944 00005388 A808                <1> 	test	al,08h			; bit 3 set if vertical retrace
  1945 0000538A 75FB                <1> 	jnz	.retrace_wait_not_set	; jump if retrace
  1946                              <1> 
  1947                              <1> .retrace_wait_set:
  1948 0000538C EC                  <1> 	in	al,dx
  1949 0000538D A808                <1> 	test	al,08h			; bit 3 set if vertical retrace
  1950 0000538F 74FB                <1> 	jz	.retrace_wait_set	; jump if no retrace
  1951 00005391 5A                  <1> 	pop	dx
  1952 00005392 58                  <1> 	pop	ax
  1953                              <1> 
  1954                              <1> .retrace_exit:
  1955 00005393 C3                  <1> 	ret
  1956                              <1> 
  1957                              <1> ;-------------------------------------------------------------------------
  1958                              <1> ; .graphics_scroll - scroll for graphics modes
  1959                              <1> 
  1960                              <1> .graphics_scroll:
  1961 00005394 8B4606              <1> 	mov	ax,word [bp+int_10_dx]	; AX = window's lower right corner
  1962 00005397 50                  <1> 	push	ax
  1963 00005398 807E0107            <1> 	cmp	byte [bp+int_10_ah],07h ; check for scroll down function
  1964 0000539C 7403                <1> 	jz	.3			; jump if scroll down
  1965 0000539E 8B4604              <1> 	mov	ax,word [bp+int_10_cx]	; AX = window's upper left corner
  1966                              <1> 
  1967                              <1> .3:
  1968 000053A1 E8E303              <1> 	call	vid_gfx_pos_to_offset	
  1969 000053A4 89C7                <1> 	mov	di,ax			; DI = scroll copy destination address
  1970                              <1> 
  1971                              <1> ; calculate scroll windows size (DX)
  1972                              <1> 
  1973 000053A6 5A                  <1> 	pop	dx			; DX = window's lower right corner
  1974 000053A7 2B5604              <1> 	sub	dx,word [bp+int_10_cx]	; substract window's upper left corner
  1975 000053AA 81C20101            <1> 	add	dx,101h 		; add 1x1
  1976 000053AE D0E6                <1> 	shl	dh,1			; multiply by four: one character takes
  1977 000053B0 D0E6                <1> 	shl	dh,1			;   four bytes in each plane
  1978 000053B2 8A4601              <1> 	mov	al,byte [bp+int_10_ah]	; AL = function
  1979 000053B5 803E490006          <1> 	cmp	byte [video_mode],06h	; check for 640x200 mode
  1980 000053BA 7409                <1> 	jz	.4			; jump if 640x200 mode
  1981 000053BC D0E2                <1> 	shl	dl,1			; double character width for 320x200 
  1982 000053BE D1E7                <1> 	shl	di,1			; double character width for 320x200
  1983 000053C0 3C07                <1> 	cmp	al,07h			; check for scroll down function
  1984 000053C2 7509                <1> 	jnz	.5			; jump if scroll down
  1985 000053C4 47                  <1> 	inc	di			; scroll up - adjust source address
  1986                              <1> 
  1987                              <1> .4:
  1988 000053C5 3C07                <1> 	cmp	al,07h			; check for scroll down function
  1989 000053C7 7504                <1> 	jnz	.5			; jump if not scroll down
  1990 000053C9 81C7F000            <1> 	add	di,0F0h			; adjust destination address
  1991                              <1> 					;   for copying backwards
  1992                              <1> 
  1993                              <1> .5:
  1994 000053CD 8A5E00              <1> 	mov	bl,byte [bp+int_10_al]	; BL = number of rows to scroll
  1995 000053D0 D0E3                <1> 	shl	bl,1			; multiply by four: one character takes
  1996 000053D2 D0E3                <1> 	shl	bl,1			;   four bytes in each plane
  1997 000053D4 53                  <1> 	push	bx
  1998 000053D5 28DE                <1> 	sub	dh,bl			; DH = number of rows to copy
  1999 000053D7 B050                <1> 	mov	al,50h
  2000 000053D9 F6E3                <1> 	mul	bl
  2001 000053DB BBB01F              <1> 	mov	bx,1FB0h
  2002 000053DE 807E0106            <1> 	cmp	byte [bp+int_10_ah],06h	; check for scroll up function
  2003 000053E2 7406                <1> 	jz	.6			; jump if scroll up
  2004 000053E4 F7D8                <1> 	neg	ax			; negate offset for scroll down
  2005 000053E6 BB5020              <1> 	mov	bx,2050h
  2006 000053E9 FD                  <1> 	std				; copy backwards
  2007                              <1> 
  2008                              <1> .6:
  2009 000053EA 89FE                <1> 	mov	si,di
  2010 000053EC 01C6                <1> 	add	si,ax			; SI = scroll copy source address
  2011 000053EE 58                  <1> 	pop	ax
  2012 000053EF 8CC1                <1> 	mov	cx,es
  2013 000053F1 8ED9                <1> 	mov	ds,cx			; load video segment to DS
  2014 000053F3 08C0                <1> 	or	al,al
  2015 000053F5 7426                <1> 	jz	.graphics_fill		; jump if clear window only requested
  2016 000053F7 50                  <1> 	push	ax
  2017                              <1> 
  2018                              <1> .graphics_scroll_loop:
  2019 000053F8 B500                <1> 	mov	ch,0
  2020 000053FA 88D1                <1> 	mov	cl,dl			; CX = bytes in row to copy
  2021 000053FC 56                  <1> 	push	si
  2022 000053FD 57                  <1> 	push	di
  2023 000053FE F3A4                <1> 	repz	movsb			; copy one row in the first plane
  2024 00005400 5F                  <1> 	pop	di
  2025 00005401 5E                  <1> 	pop	si
  2026 00005402 81C60020            <1> 	add	si,2000h		; point SI and DI to the second plane
  2027 00005406 81C70020            <1> 	add	di,2000h
  2028 0000540A 88D1                <1> 	mov	cl,dl			; CX = bytes in row to copy
  2029 0000540C 56                  <1> 	push	si
  2030 0000540D 57                  <1> 	push	di
  2031 0000540E F3A4                <1> 	repz	movsb			; copy one row in the second plane
  2032 00005410 5F                  <1> 	pop	di
  2033 00005411 5E                  <1> 	pop	si
  2034 00005412 29DE                <1> 	sub	si,bx			; SI = next row to copy source address
  2035 00005414 29DF                <1> 	sub	di,bx			; DI = next row to copy destination
  2036 00005416 FECE                <1> 	dec	dh			; decrement row counter
  2037 00005418 75DE                <1> 	jnz	.graphics_scroll_loop	; jump if there is more rows to copy
  2038                              <1> 
  2039 0000541A 58                  <1> 	pop	ax
  2040 0000541B 88C6                <1> 	mov	dh,al			; DH = number of rows to fill
  2041                              <1> 
  2042                              <1> .graphics_fill:
  2043 0000541D 8A4603              <1> 	mov	al,byte [bp+int_10_bh]	; AL = fill color
  2044 00005420 B500                <1> 	mov	ch,0
  2045                              <1> 
  2046                              <1> .graphics_fill_loop:
  2047 00005422 88D1                <1> 	mov	cl,dl			; CX = bytes in row to fill
  2048 00005424 57                  <1> 	push	di
  2049 00005425 F3AA                <1> 	repz	stosb			; fill one row in the first plane
  2050 00005427 5F                  <1> 	pop	di
  2051 00005428 81C70020            <1> 	add	di,2000h		; point DI to the second plane
  2052 0000542C 88D1                <1> 	mov	cl,dl			; CX = bytes in row to fill
  2053 0000542E 57                  <1> 	push	di
  2054 0000542F F3AA                <1> 	repz	stosb			; fill one row in the second plane
  2055 00005431 5F                  <1> 	pop	di
  2056 00005432 29DF                <1> 	sub	di,bx
  2057 00005434 FECE                <1> 	dec	dh			; decrement row counter
  2058 00005436 75EA                <1> 	jnz	.graphics_fill_loop	; jumpif there is more rows to fill
  2059 00005438 C3                  <1> 	ret
  2060                              <1> 
  2061                              <1> ;=========================================================================
  2062                              <1> ; int_10_fn08 - Read character and attribute
  2063                              <1> ; Input:
  2064                              <1> ;	AH = 08h
  2065                              <1> ; Output:
  2066                              <1> ;	AL - character read
  2067                              <1> ;	BH - video attribute (text modes only)
  2068                              <1> ; int_10_fn09 - Write character and attribute
  2069                              <1> ; Input:
  2070                              <1> ;	AH = 09h
  2071                              <1> ;	AL - character to write
  2072                              <1> ;	BH - page number
  2073                              <1> ;	BL - attribute (text modes) or color (graphics modes)
  2074                              <1> ;	CX - number of times to write character
  2075                              <1> ; Output:
  2076                              <1> ;	none
  2077                              <1> ; int_10_fn0A - Write character only
  2078                              <1> ; Input:
  2079                              <1> ;	AH = 0Ah
  2080                              <1> ;	AL - character to write
  2081                              <1> ;	BH - page number
  2082                              <1> ;	CX - repeat count
  2083                              <1> ; Output:
  2084                              <1> ;	none
  2085                              <1> ;-------------------------------------------------------------------------
  2086                              <1> int_10_fn08:
  2087                              <1> int_10_fn09:
  2088                              <1> int_10_fn0A:
  2089 00005439 E8E002              <1> 	call	vid_check_mode
  2090 0000543C 7277                <1> 	jc	.graphics		; jump if graphics mode
  2091 0000543E 8A5E03              <1> 	mov	bl,byte [bp+int_10_bh]	; BL = page number
  2092 00005441 B700                <1> 	mov	bh,0
  2093 00005443 53                  <1> 	push	bx
  2094 00005444 E82803              <1> 	call	vid_current_offset
  2095 00005447 89C7                <1> 	mov	di,ax			; DI = character offset in the page
  2096 00005449 58                  <1> 	pop	ax			; AX = page number
  2097 0000544A F7264C00            <1> 	mul	word [video_page_size] 	; AX = page number * page size
  2098 0000544E 01C7                <1> 	add	di,ax			; DI = character offset
  2099 00005450 89FE                <1> 	mov	si,di			; SI = character offset
  2100 00005452 8B166300            <1> 	mov	dx,word [video_port]	; DX = CRTC port
  2101 00005456 83C206              <1> 	add	dx,6			; DX = CGA status register
  2102 00005459 1E                  <1> 	push	ds
  2103 0000545A 8CC3                <1> 	mov	bx,es
  2104 0000545C 8EDB                <1> 	mov	ds,bx			; load video segment to DS
  2105 0000545E 8A4601              <1> 	mov	al,byte [bp+int_10_ah]	; AL = function
  2106 00005461 3C08                <1> 	cmp	al,08h			; check for read character function
  2107 00005463 7512                <1> 	jnz	.text_write		; jump if not read char (write char)
  2108                              <1> 
  2109                              <1> .read_retrace_wait:
  2110 00005465 EC                  <1> 	in	al,dx
  2111 00005466 A801                <1> 	test	al,01h			; bit 0 set if horizontal retrace
  2112 00005468 75FB                <1> 	jnz	.read_retrace_wait	; jump if retrace
  2113 0000546A FA                  <1> 	cli
  2114                              <1> 
  2115                              <1> .read_no_retrace_wait:
  2116 0000546B EC                  <1> 	in	al,dx
  2117 0000546C A801                <1> 	test	al,01h			; bit 0 set if horizontal retrace
  2118 0000546E 74FB                <1> 	jz	.read_no_retrace_wait	; jump if no retrace
  2119                              <1> 
  2120 00005470 AD                  <1> 	lodsw				; read character and attribute
  2121 00005471 FB                  <1> 	sti
  2122 00005472 1F                  <1> 	pop	ds
  2123 00005473 894600              <1> 	mov	word [bp+int_10_ax],ax	; return character and attribute in AX
  2124 00005476 C3                  <1> 	ret
  2125                              <1> 
  2126                              <1> .text_write:
  2127 00005477 8A5E00              <1> 	mov	bl,byte [bp+int_10_al]	; BL = character to write
  2128 0000547A 8A7E02              <1> 	mov	bh,byte [bp+int_10_bl]	; BH = attribute to write
  2129 0000547D 8B4E04              <1> 	mov	cx,word [bp+int_10_cx]  ; CX = number of times to write char
  2130 00005480 3C0A                <1> 	cmp	al,0Ah			; check for write char only function
  2131 00005482 7418                <1> 	jz	.text_write_char_only	; jump if write char only
  2132                              <1> 
  2133                              <1> .write_char_retrace:
  2134 00005484 EC                  <1> 	in	al,dx
  2135 00005485 A808                <1> 	test	al,08h			; bit 3 set if vertical retrace
  2136 00005487 750B                <1> 	jnz	.do_write_char_attr	; retrace is in progress - write char
  2137                              <1> 
  2138                              <1> .write_retrace_wait1:
  2139 00005489 EC                  <1> 	in	al,dx
  2140 0000548A A801                <1> 	test	al,01h			; bit 0 set if horizontal retrace
  2141 0000548C 75FB                <1> 	jnz	.write_retrace_wait1	; jump if retrace
  2142 0000548E FA                  <1> 	cli
  2143                              <1> 
  2144                              <1> .write_no_retrace_wait1:
  2145 0000548F EC                  <1> 	in	al,dx
  2146 00005490 A801                <1> 	test	al,01h			; bit 0 set if horizontal retrace
  2147 00005492 74FB                <1> 	jz	.write_no_retrace_wait1	; jump if no retrace
  2148                              <1> 
  2149                              <1> .do_write_char_attr:
  2150 00005494 89D8                <1> 	mov	ax,bx			; AX = character / attribute
  2151 00005496 AB                  <1> 	stosw				; write it to video memory
  2152 00005497 FB                  <1> 	sti
  2153 00005498 E2EA                <1> 	loop	.write_char_retrace	; repeat CX times
  2154 0000549A 1F                  <1> 	pop	ds
  2155 0000549B C3                  <1> 	ret
  2156                              <1> 
  2157                              <1> .text_write_char_only:
  2158 0000549C EC                  <1> 	in	al,dx
  2159 0000549D A808                <1> 	test	al,08h			; bit 3 set if vertical retrace
  2160 0000549F 750B                <1> 	jnz	.do_write_char_only	; retrace is in progress - write char
  2161                              <1> 
  2162                              <1> .write_retrace_wait2:
  2163 000054A1 EC                  <1> 	in	al,dx
  2164 000054A2 A801                <1> 	test	al,01h			; bit 0 set if horizontal retrace
  2165 000054A4 75FB                <1> 	jnz	.write_retrace_wait2	; jump if retrace
  2166 000054A6 FA                  <1> 	cli
  2167                              <1> 
  2168                              <1> .write_no_retrace_wait2:
  2169 000054A7 EC                  <1> 	in	al,dx
  2170 000054A8 A801                <1> 	test	al,01h			; bit 0 set if horizontal retrace
  2171 000054AA 74FB                <1> 	jz	.write_no_retrace_wait2	; jump if no retrace
  2172                              <1> 
  2173                              <1> .do_write_char_only:
  2174 000054AC 88D8                <1> 	mov	al,bl			; AL = character to write
  2175 000054AE AA                  <1> 	stosb				; write it to video memory
  2176 000054AF FB                  <1> 	sti
  2177 000054B0 47                  <1> 	inc	di			; skip attribute
  2178 000054B1 E2E9                <1> 	loop	.text_write_char_only	; repeat CX times
  2179 000054B3 1F                  <1> 	pop	ds
  2180 000054B4 C3                  <1> 	ret
  2181                              <1> 
  2182                              <1> .graphics:
  2183 000054B5 807E0108            <1> 	cmp	byte [bp+int_10_ah],08h	; check for read character function
  2184 000054B9 7503E9B300          <1> 	jz	.graphics_read
  2185                              <1> 
  2186 000054BE A15000              <1> 	mov	ax,word [video_cur_pos]	; Get cursor position
  2187 000054C1 E8C302              <1> 	call	vid_gfx_pos_to_offset	;  ...convert (row,col) -> col
  2188 000054C4 89C7                <1> 	mov	di,ax			; Save in displacement register
  2189 000054C6 1E                  <1> 	push	ds
  2190 000054C7 8A4600              <1> 	mov	al,byte [bp+int_10_al]	; Get character to write
  2191 000054CA B400                <1> 	mov	ah,0
  2192 000054CC 08C0                <1> 	or	al,al			; Is it user character set?
  2193 000054CE 7807                <1> 	js	.CG9_02			;  ...skip if so
  2194 000054D0 8CCA                <1> 	mov	dx,cs			; Else use ROM character set
  2195 000054D2 BE[6E5A]            <1> 	mov	si,gfx_font		; load graphics font offset
  2196 000054D5 EB0C                <1> 	jmp	.CG9_03
  2197                              <1> 
  2198                              <1> .CG9_02:
  2199 000054D7 247F                <1> 	and	al,7Fh			; Origin to zero
  2200 000054D9 31DB                <1> 	xor	bx,bx			;  ...then go load
  2201 000054DB 8EDB                <1> 	mov	ds,bx			;  ...user graphics
  2202 000054DD C5367C00            <1> 	lds	si,[7Ch]		;  ...vector, offset in si
  2203 000054E1 8CDA                <1> 	mov	dx,ds			;  ...segment into dx
  2204                              <1> 
  2205                              <1> .CG9_03:
  2206 000054E3 1F                  <1> 	pop	ds			; Restore data segment
  2207 000054E4 B103                <1> 	mov	cl,3			;  ...char 8 pixels wide
  2208 000054E6 D3E0                <1> 	shl	ax,cl
  2209 000054E8 01C6                <1> 	add	si,ax			; Add regen. buffer base addr.
  2210 000054EA 8B4E04              <1> 	mov	cx,word [bp+int_10_cx]	;  ...load char. count
  2211 000054ED 803E490006          <1> 	cmp	byte [video_mode],6	; Is the mode 640 x 200 b/w?
  2212 000054F2 1E                  <1> 	push	ds
  2213 000054F3 8EDA                <1> 	mov	ds,dx
  2214 000054F5 7451                <1> 	jz	.CG8_02			;  ...skip if so
  2215 000054F7 D1E7                <1> 	shl	di,1
  2216 000054F9 8A4602              <1> 	mov	al,byte [bp+int_10_bl]	; Get character attribute
  2217 000054FC 83E003              <1> 	and	ax,3
  2218 000054FF BB5555              <1> 	mov	bx,5555h
  2219 00005502 F7E3                <1> 	mul	bx
  2220 00005504 89C2                <1> 	mov	dx,ax
  2221 00005506 8A5E02              <1> 	mov	bl,byte [bp+int_10_bl]	; Restore BL (character attribute)
  2222                              <1> 
  2223                              <1> .CG9_04:
  2224 00005509 B708                <1> 	mov	bh,8			; Char 8 pixels wide
  2225 0000550B 57                  <1> 	push	di
  2226 0000550C 56                  <1> 	push	si
  2227                              <1> 
  2228                              <1> .CG9_05:
  2229 0000550D AC                  <1> 	lodsb				; Read the screen
  2230 0000550E 51                  <1> 	push	cx
  2231 0000550F 53                  <1> 	push	bx
  2232 00005510 31DB                <1> 	xor	bx,bx
  2233 00005512 B90800              <1> 	mov	cx,8
  2234                              <1> 
  2235                              <1> .CG9_06:
  2236 00005515 D0E8                <1> 	shr	al,1			; Shift bits thru byte
  2237 00005517 D1DB                <1> 	rcr	bx,1
  2238 00005519 D1FB                <1> 	sar	bx,1
  2239 0000551B E2F8                <1> 	loop	.CG9_06
  2240                              <1> 
  2241 0000551D 89D8                <1> 	mov	ax,bx			; Result into ax
  2242 0000551F 5B                  <1> 	pop	bx
  2243 00005520 59                  <1> 	pop	cx
  2244 00005521 21D0                <1> 	and	ax,dx
  2245 00005523 86E0                <1> 	xchg	ah,al
  2246 00005525 08DB                <1> 	or	bl,bl
  2247 00005527 7903                <1> 	jns	.CG9_07
  2248 00005529 263305              <1>     es	xor	ax,word [di]
  2249                              <1> 
  2250                              <1> .CG9_07:
  2251 0000552C 268905              <1>     es	mov	word [di],ax		; Write new word
  2252 0000552F 81F70020            <1> 	xor	di,2000h
  2253 00005533 F7C70020            <1> 	test	di,2000h		; Is this other plane?
  2254 00005537 7503                <1> 	jnz	.CG9_08			;  ...nope
  2255 00005539 83C750              <1> 	add	di,50h			; Else advance character
  2256                              <1> 
  2257                              <1> .CG9_08:
  2258 0000553C FECF                <1> 	dec	bh			; Show another char written
  2259 0000553E 75CD                <1> 	jnz	.CG9_05			;  ...more to go
  2260 00005540 5E                  <1> 	pop	si
  2261 00005541 5F                  <1> 	pop	di
  2262 00005542 47                  <1> 	inc	di
  2263 00005543 47                  <1> 	inc	di
  2264 00005544 E2C3                <1> 	loop	.CG9_04
  2265 00005546 1F                  <1> 	pop	ds
  2266 00005547 C3                  <1> 	ret
  2267                              <1> 
  2268                              <1> .CG8_02:
  2269 00005548 8A5E02              <1> 	mov	bl,byte [bp+int_10_bl]	; Get display page
  2270 0000554B BA0020              <1> 	mov	dx,2000h		;  ...size of graphics plane
  2271                              <1> 
  2272                              <1> .CG8_03:
  2273 0000554E B708                <1> 	mov	bh,8			; Pixel count to write
  2274 00005550 57                  <1> 	push	di
  2275 00005551 56                  <1> 	push	si
  2276                              <1> 
  2277                              <1> .CG8_04:
  2278 00005552 AC                  <1> 	lodsb				; Read from one plane
  2279 00005553 08DB                <1> 	or	bl,bl			;  ...done both planes?
  2280 00005555 7903                <1> 	jns	.CG8_05			;  ...skip if not
  2281 00005557 263205              <1>     es	xor	al,byte [di]		; Else load attribute
  2282                              <1> 
  2283                              <1> .CG8_05:
  2284 0000555A 268805              <1>     es	mov	byte [di],al		; Write out attribute
  2285 0000555D 31D7                <1> 	xor	di,dx			;  ...get other plane
  2286 0000555F 85D7                <1> 	test	di,dx			; Done both planes?
  2287 00005561 7503                <1> 	jnz	.CG8_06			;  ...skip if not
  2288 00005563 83C750              <1> 	add	di,50h			; Else position for now char
  2289                              <1> 
  2290                              <1> .CG8_06:
  2291 00005566 FECF                <1> 	dec	bh			; Show row of pixels read
  2292 00005568 75E8                <1> 	jnz	.CG8_04			;  ...not done all of them
  2293 0000556A 5E                  <1> 	pop	si
  2294 0000556B 5F                  <1> 	pop	di
  2295 0000556C 47                  <1> 	inc	di
  2296 0000556D E2DF                <1> 	loop	.CG8_03
  2297 0000556F 1F                  <1> 	pop	ds
  2298 00005570 C3                  <1> 	ret
  2299                              <1> 
  2300                              <1> .graphics_read:
  2301 00005571 FC                  <1> 	cld				; Increment upwards
  2302 00005572 A15000              <1> 	mov	ax,word [video_cur_pos]	;  ...get cursor position
  2303 00005575 E80F02              <1> 	call	vid_gfx_pos_to_offset	; Convert (row,col) -> columns
  2304 00005578 89C6                <1> 	mov	si,ax			;  ...save in si
  2305 0000557A 83EC08              <1> 	sub	sp,8			; Grab 8 bytes temp storage
  2306 0000557D 89E7                <1> 	mov	di,sp			;  ...save base in di
  2307 0000557F 803E490006          <1> 	cmp	byte [video_mode],6	; Mode 640 x 200 b/w?
  2308 00005584 8CC0                <1> 	mov	ax,es
  2309 00005586 1E                  <1> 	push	ds
  2310 00005587 57                  <1> 	push	di
  2311 00005588 8ED8                <1> 	mov	ds,ax			; load video segment to DS
  2312 0000558A 7431                <1> 	jz	CGR_06			; Mode is 640 x 200 b/w - skip
  2313 0000558C B608                <1> 	mov	dh,8			; Eight pixels high/char
  2314 0000558E D1E6                <1> 	shl	si,1
  2315 00005590 BB0020              <1> 	mov	bx,2000h		; Bytes per video plane
  2316                              <1> 
  2317                              <1> CGR_02:
  2318 00005593 8B04                <1> 	mov	ax,word [si] 		; Read existing word
  2319 00005595 86E0                <1> 	xchg	ah,al
  2320 00005597 B900C0              <1> 	mov	cx,0C000h		; Attributes to scan for
  2321 0000559A B200                <1> 	mov	dl,0
  2322                              <1> 
  2323                              <1> CGR_03:
  2324 0000559C 85C8                <1> 	test	ax,cx			; Look for attributes
  2325 0000559E F8                  <1> 	clc
  2326 0000559F 7401                <1> 	jz	CGR_04			;  ...set, skip
  2327 000055A1 F9                  <1> 	stc				; Else show not set
  2328                              <1> 
  2329                              <1> CGR_04:
  2330 000055A2 D0D2                <1> 	rcl	dl,1
  2331 000055A4 D1E9                <1> 	shr	cx,1
  2332 000055A6 D1E9                <1> 	shr	cx,1
  2333 000055A8 73F2                <1> 	jnb	CGR_03			;  ...more shifts to go
  2334 000055AA 368815              <1>     ss	mov	byte [di],dl
  2335 000055AD 47                  <1> 	inc	di
  2336 000055AE 31DE                <1> 	xor	si,bx			; Do other video plane
  2337 000055B0 85DE                <1> 	test	si,bx			;  ...done both planes?
  2338 000055B2 7503                <1> 	jnz	CGR_05			;  ...no, skip
  2339 000055B4 83C650              <1> 	add	si,50h			; Else advance pointer
  2340                              <1> 
  2341                              <1> CGR_05:
  2342 000055B7 FECE                <1> 	dec	dh			; Show another pixel row done
  2343 000055B9 75D8                <1> 	jnz	CGR_02			;  ...more rows to do
  2344 000055BB EB17                <1> 	jmp	short	CGR_08
  2345                              <1> 
  2346                              <1> CGR_06:
  2347 000055BD B604                <1> 	mov	dh,4			; Mode 640 x 200 b/w - special
  2348                              <1> 
  2349                              <1> CGR_07:
  2350 000055BF 8A24                <1> 	mov	ah,byte [si] 		; Read pixels from one plane
  2351 000055C1 368825              <1>     ss	mov	byte [di],ah		;  ...save on stack
  2352 000055C4 47                  <1> 	inc	di			;  ...advance
  2353 000055C5 8AA40020            <1> 	mov	ah,byte [si+2000h]	; Read pixels from other plane
  2354 000055C9 368825              <1>     ss	mov	byte [di],ah		; Save pixels on stack
  2355 000055CC 47                  <1> 	inc	di			;  ...advance
  2356 000055CD 83C650              <1> 	add	si,50h			; Total pixels in char
  2357 000055D0 FECE                <1> 	dec	dh			;  ...another row processed
  2358 000055D2 75EB                <1> 	jnz	CGR_07			;  ...more to do
  2359                              <1> 
  2360                              <1> CGR_08:
  2361 000055D4 8CCA                <1> 	mov	dx,cs			; Load segment of graphics font 
  2362 000055D6 BF[6E5A]            <1> 	mov	di,gfx_font		;  ...and offset
  2363 000055D9 8EC2                <1> 	mov	es,dx			;  ...save offset in es
  2364 000055DB 8CD2                <1> 	mov	dx,ss
  2365 000055DD 8EDA                <1> 	mov	ds,dx
  2366 000055DF 5E                  <1> 	pop	si
  2367 000055E0 B000                <1> 	mov	al,0
  2368                              <1> 
  2369                              <1> CGR_09:
  2370 000055E2 BA8000              <1> 	mov	dx,80h			; Number of char. in graphics set
  2371                              <1> 
  2372                              <1> CGR_10:
  2373 000055E5 56                  <1> 	push	si
  2374 000055E6 57                  <1> 	push	di
  2375 000055E7 B90800              <1> 	mov	cx,8			; Bytes to compare for char
  2376 000055EA F3A6                <1> 	repz	cmpsb			;  ...do compare
  2377 000055EC 5F                  <1> 	pop	di
  2378 000055ED 5E                  <1> 	pop	si
  2379 000055EE 741C                <1> 	jz	CGR_11			; Found graphics character
  2380 000055F0 FEC0                <1> 	inc	al			;  ...else show another char
  2381 000055F2 83C708              <1> 	add	di,8			;  ...advance one row
  2382 000055F5 4A                  <1> 	dec	dx			;  ...one less char  to scan
  2383 000055F6 75ED                <1> 	jnz	CGR_10			; Loop if more char left
  2384                              <1> 
  2385 000055F8 08C0                <1> 	or	al,al			; User graphics character set?
  2386 000055FA 7410                <1> 	jz	CGR_11			;  ...no, not found
  2387 000055FC 31DB                <1> 	xor	bx,bx			; 
  2388 000055FE 8EDB                <1> 	mov	ds,bx			; Load interrupt table segment to ES
  2389 00005600 C43E7C00            <1> 	les	di,[1Fh*4]		; Load user font for graphics 
  2390                              <1> 					; (INT 1Fh vector) to ES:SI
  2391 00005604 8CC3                <1> 	mov	bx,es
  2392 00005606 09FB                <1> 	or	bx,di
  2393 00005608 7402                <1> 	jz	CGR_11			;  ...not found
  2394 0000560A EBD6                <1> 	jmp	short	CGR_09		; Try using user graphics char
  2395                              <1> 
  2396                              <1> CGR_11:
  2397 0000560C 884600              <1> 	mov	byte [bp+int_10_al],al	; Return char in user al
  2398 0000560F 1F                  <1> 	pop	ds
  2399 00005610 83C408              <1> 	add	sp,8			;  ...return temp storage
  2400 00005613 C3                  <1> 	ret
  2401                              <1> 
  2402                              <1> ;=========================================================================
  2403                              <1> ; int_10_fn0B - Set background color or palette
  2404                              <1> ; Input:
  2405                              <1> ; 	AH - 0Bh
  2406                              <1> ;	BH = 00h - set background / border color
  2407                              <1> ;		BL - background (graphics modes) or border (text modes)
  2408                              <1> ;	BH = 01h - set palette (320x200 graphics mode)
  2409                              <1> ;		BL - palette ID:
  2410                              <1> ;			00h - background, green, red, and yellow (brown)
  2411                              <1> ;			01h - background, cyan, magenta, and white
  2412                              <1> ; Output:
  2413                              <1> ;	none
  2414                              <1> ;-------------------------------------------------------------------------
  2415                              <1> int_10_fn0B:
  2416 00005614 A06600              <1> 	mov	al,byte [video_palet_reg] ; AL = current palette register
  2417 00005617 8A6602              <1> 	mov	ah,byte [bp+int_10_bl]	; AH = color / palette ID
  2418 0000561A 807E0300            <1> 	cmp	byte [bp+int_10_bh],00h	; check function
  2419 0000561E 7509                <1> 	jnz	.set_palette		; jump to set palette if BH != 0
  2420                              <1> 
  2421 00005620 24E0                <1> 	and	al,0E0h			; clear color bits - bits 0-5
  2422 00005622 80E41F              <1> 	and	ah,1Fh			; clear non-color bits in input
  2423 00005625 08E0                <1> 	or	al,ah			; apply new color
  2424 00005627 EB09                <1> 	jmp	.write_palet_reg
  2425                              <1> 
  2426                              <1> .set_palette:
  2427 00005629 24DF                <1> 	and	al,0DFh			; clear palette bit - bit 6
  2428 0000562B F6C401              <1> 	test	ah,01h
  2429 0000562E 7402                <1> 	jz	.write_palet_reg
  2430 00005630 0C20                <1> 	or	al,20h			; set palette bit for BL = 01h
  2431                              <1> 
  2432                              <1> .write_palet_reg:
  2433 00005632 A26600              <1> 	mov	byte [video_palet_reg],al ; save new palette reg in BIOS data
  2434 00005635 8B166300            <1> 	mov	dx,word [video_port]
  2435 00005639 83C205              <1> 	add	dx,5			; CRTC color select register
  2436 0000563C EE                  <1> 	out	dx,al			; send it to CRTC
  2437 0000563D C3                  <1> 	ret
  2438                              <1> 
  2439                              <1> ;=========================================================================
  2440                              <1> ; int_10_fn0C - Write graphics pixel
  2441                              <1> ; Input:
  2442                              <1> ;	AH = 0Ch
  2443                              <1> ;	AL = pixel color, if bit 7 set, pixel is XOR'ed onto screen
  2444                              <1> ;	CX = column
  2445                              <1> ;	DX = row
  2446                              <1> ; Output:
  2447                              <1> ;	none
  2448                              <1> ;-------------------------------------------------------------------------
  2449                              <1> int_10_fn0C:
  2450 0000563E E80501              <1> 	call	vid_pixel_address	; calculate pixel address	
  2451 00005641 750D                <1> 	jnz	.mode_320x200		; jump if 320x200 mode
  2452 00005643 8A4600              <1> 	mov	al,byte [bp+int_10_al]	; AL - color
  2453 00005646 88C3                <1> 	mov	bl,al			; copy color to BL
  2454 00005648 2401                <1> 	and	al,1			; one bit per pixel
  2455 0000564A D0C8                <1> 	ror	al,1			; make color MSB instead of LSB
  2456 0000564C B47F                <1> 	mov	ah,7Fh			; AH = pixel mask
  2457 0000564E EB0F                <1> 	jmp	.prepare_mask
  2458                              <1> 
  2459                              <1> .mode_320x200:
  2460 00005650 D0E1                <1> 	shl	cl,1
  2461 00005652 8A4600              <1> 	mov	al,byte [bp+int_10_al]	; AL - color
  2462 00005655 88C3                <1> 	mov	bl,al			; copy color to BL
  2463 00005657 2403                <1> 	and	al,3			; two bit per pixel
  2464 00005659 D0C8                <1> 	ror	al,1			; make color MSB instead of LSB
  2465 0000565B D0C8                <1> 	ror	al,1
  2466 0000565D B43F                <1> 	mov	ah,3Fh			; AH = pixel mask
  2467                              <1> 
  2468                              <1> .prepare_mask:
  2469 0000565F D2CC                <1> 	ror	ah,cl			; position pixel mask correctly
  2470 00005661 D2E8                <1> 	shr	al,cl			; position color bits correctly
  2471 00005663 268A0C              <1>     es	mov	cl,byte [si]		; read the byte containing the pixel
  2472 00005666 08DB                <1> 	or	bl,bl			; check if bit 7 set
  2473 00005668 7904                <1> 	jns	.set_color		; bit 7 not set - new color
  2474 0000566A 30C1                <1> 	xor	cl,al			; else XOR with existing color
  2475 0000566C EB04                <1> 	jmp	.write_pixel
  2476                              <1> 
  2477                              <1> .set_color:
  2478 0000566E 20E1                <1> 	and	cl,ah			; clear existing color bits
  2479 00005670 08C1                <1> 	or	cl,al			; set new color bits
  2480                              <1> 
  2481                              <1> .write_pixel:
  2482 00005672 26880C              <1>     es	mov	[si],cl			; write the byte with the new pixel
  2483 00005675 C3                  <1> 	ret
  2484                              <1> 
  2485                              <1> ;=========================================================================
  2486                              <1> ; int_10_fn0D - Read graphics pixel
  2487                              <1> ; Input:
  2488                              <1> ;	AH = 0Dh
  2489                              <1> ;	CX = column
  2490                              <1> ;	DX = row
  2491                              <1> ; Output:
  2492                              <1> ;	AL = pixel color 
  2493                              <1> ;-------------------------------------------------------------------------
  2494                              <1> int_10_fn0D:
  2495 00005676 E8CD00              <1> 	call	vid_pixel_address	; calculate pixel address
  2496 00005679 268A04              <1>     es	mov	al,byte [si]		; read byte containing the pixel
  2497 0000567C 7508                <1> 	jnz	.mode_320x200		; jump if 320x200 mode
  2498 0000567E D2E0                <1> 	shl	al,cl			; shift pixel to bit 7
  2499 00005680 D0C0                <1> 	rol	al,1			; shift pixel from bit 7 to bit 0
  2500 00005682 2401                <1> 	and	al,1			; one bit per pixel
  2501 00005684 EB0A                <1> 	jmp	.exit
  2502                              <1> 
  2503                              <1> .mode_320x200:
  2504 00005686 D0E1                <1> 	shl	cl,1			; update position for two bits per pixel
  2505 00005688 D2E0                <1> 	shl	al,cl			; shift pixel to bits 7-6
  2506 0000568A D0C0                <1> 	rol	al,1			; shift pixel to bits 1-0
  2507 0000568C D0C0                <1> 	rol	al,1
  2508 0000568E 2403                <1> 	and	al,3			; two bits per pixel
  2509                              <1> 
  2510                              <1> .exit:
  2511 00005690 884600              <1> 	mov	byte [bp+int_10_al],al	; return pixel color in AL
  2512 00005693 C3                  <1> 	ret
  2513                              <1> 
  2514                              <1> ;=========================================================================
  2515                              <1> ; int_10_fn0E - Teletype output
  2516                              <1> ; Input:
  2517                              <1> ;	AH = 0Eh
  2518                              <1> ;	AL = character to write
  2519                              <1> ;	BL = foreground color (graphics modes only)
  2520                              <1> ; Output:
  2521                              <1> ;	none
  2522                              <1> ; Notes:
  2523                              <1> ;	- writes character to the active video page
  2524                              <1> ;	- support following control characters: BEL, BS, LF, CR
  2525                              <1> ;-------------------------------------------------------------------------
  2526                              <1> int_10_fn0E:
  2527 00005694 8A1E6200            <1> 	mov	bl,byte [video_page]	; BL = active video page
  2528 00005698 B700                <1> 	mov	bh,0
  2529 0000569A D0E3                <1> 	shl	bl,1			; word index
  2530 0000569C 8B5750              <1> 	mov	dx,word [bx+video_cur_pos] ; DX = cursor position
  2531                              <1> 
  2532 0000569F 8A4600              <1> 	mov	al,byte [bp+int_10_al]	; AL = character to write
  2533 000056A2 3C08                <1> 	cmp	al,bs
  2534 000056A4 7429                <1> 	jz	.bs			; jump if backspace (BS)
  2535 000056A6 3C0A                <1> 	cmp	al,lf
  2536 000056A8 741C                <1> 	jz	.lf			; jump if line feed (LF)
  2537 000056AA 3C07                <1> 	cmp	al,bel
  2538 000056AC 7433                <1> 	jz	.bel			; jump if beep (BEL)
  2539 000056AE 3C0D                <1> 	cmp	al,cr
  2540 000056B0 7426                <1> 	jz	.cr			; jump if carriage return (CR)
  2541 000056B2 8A5E02              <1> 	mov	bl,byte [bp+int_10_bl]	; BL = attribute for graphics mode
  2542 000056B5 B40A                <1> 	mov	ah,0Ah			; INT 10h, function 0Ah - write char
  2543 000056B7 B90100              <1> 	mov	cx,1			; one character
  2544 000056BA CD10                <1> 	int	10h			; write character
  2545 000056BC FEC2                <1> 	inc	dl			; move cursor to the next column
  2546 000056BE 3A164A00            <1> 	cmp	dl,byte [video_columns]	; compare position to number of columns
  2547 000056C2 7516                <1> 	jnz	.set_cursor_pos		; jump if not past the last column
  2548 000056C4 B200                <1> 	mov	dl,0			; move to the first position
  2549                              <1> 
  2550                              <1> .lf:
  2551 000056C6 80FE18              <1> 	cmp	dh,24			; on the last row?
  2552 000056C9 741C                <1> 	jz	.scroll			; jump if on the last row - scroll
  2553 000056CB FEC6                <1> 	inc	dh			; move cursor to the next row
  2554 000056CD 750B                <1> 	jnz	.set_cursor_pos		; set new cursor position
  2555                              <1> 
  2556                              <1> .bs:
  2557 000056CF 80FA00              <1> 	cmp	dl,0			; on the first column?
  2558 000056D2 7406                <1> 	jz	.set_cursor_pos		; jump if yes - nothing to do
  2559 000056D4 FECA                <1> 	dec	dl			; move cursor to the previous position
  2560 000056D6 EB02                <1> 	jmp	.set_cursor_pos		; set new cursor position
  2561                              <1> 
  2562                              <1> .cr:
  2563 000056D8 B200                <1> 	mov	dl,0			; set cursor to the first column
  2564                              <1> 
  2565                              <1> .set_cursor_pos:
  2566 000056DA 8A1E6200            <1> 	mov	bl,byte [video_page]	; BL = active video page
  2567 000056DE E9E6FA              <1> 	jmp	set_cur_pos		; set new cursor position
  2568                              <1> 
  2569                              <1> .bel:
  2570 000056E1 B302                <1> 	mov	bl,2			; 0.2 second beep
  2571 000056E3 E85DCF              <1> 	call	beep
  2572 000056E6 C3                  <1> 	ret
  2573                              <1> 
  2574                              <1> .scroll:
  2575 000056E7 B402                <1> 	mov	ah,02h
  2576 000056E9 CD10                <1> 	int	10h			; set new cursor position
  2577 000056EB E82E00              <1> 	call	vid_check_mode
  2578 000056EE B700                <1> 	mov	bh,0
  2579 000056F0 7206                <1> 	jc	.do_scroll		; jump if text mode - do scroll
  2580 000056F2 B408                <1> 	mov	ah,08h			; INT 10h, function 08h - read char
  2581 000056F4 CD10                <1> 	int	10h			; read attirbute at current position
  2582 000056F6 88E7                <1> 	mov	bh,ah
  2583                              <1> 
  2584                              <1> .do_scroll:
  2585 000056F8 B406                <1> 	mov	ah,06h			; INT 10h, function 06h - Scroll up
  2586 000056FA B001                <1> 	mov	al,1			; scroll one line
  2587 000056FC 31C9                <1> 	xor	cx,cx			; top right corner is 0,0
  2588 000056FE B618                <1> 	mov	dh,24			; bottom row is 24
  2589 00005700 8A164A00            <1> 	mov	dl,byte [video_columns] ; right column is the last column
  2590 00005704 FECA                <1> 	dec	dl
  2591 00005706 CD10                <1> 	int	10h			; scroll page up
  2592 00005708 C3                  <1> 	ret
  2593                              <1> 
  2594                              <1> ;=========================================================================
  2595                              <1> ; int_10_fn0F - Get current video mode
  2596                              <1> ; Input:
  2597                              <1> ;	AH = 0Fh
  2598                              <1> ; Output:
  2599                              <1> ;	AL = video mode
  2600                              <1> ;	AH = characters per column
  2601                              <1> ;	BH = active video page
  2602                              <1> ;-------------------------------------------------------------------------
  2603                              <1> int_10_fn0F:
  2604 00005709 A04A00              <1> 	mov	al,byte [video_columns]
  2605 0000570C 884601              <1> 	mov	byte [bp+int_10_ah],al
  2606 0000570F A04900              <1> 	mov	al,byte [video_mode]
  2607 00005712 884600              <1> 	mov	byte [bp+int_10_al],al
  2608 00005715 A06200              <1> 	mov	al,byte [video_page]
  2609 00005718 884603              <1> 	mov	byte [bp+int_10_bh],al
  2610 0000571B C3                  <1> 	ret
  2611                              <1> 
  2612                              <1> ;=========================================================================
  2613                              <1> ; vid_check_mode - Check current video mode
  2614                              <1> ; Input:
  2615                              <1> ;	none
  2616                              <1> ; Output:
  2617                              <1> ;	ZF set if monochrome mode (mode 07h)
  2618                              <1> ;	CF set if graphics modes (modes 04h - 06h)
  2619                              <1> ;-------------------------------------------------------------------------
  2620                              <1> vid_check_mode:
  2621 0000571C 50                  <1> 	push	ax
  2622 0000571D A04900              <1> 	mov	al,byte [video_mode]
  2623 00005720 3C07                <1> 	cmp	al,07h			; set ZF if monochrome mode
  2624 00005722 7408                <1> 	jz	.exit			; jump if monochrome
  2625 00005724 3C04                <1> 	cmp	al,04h			; clears CF if graphics mode
  2626 00005726 F5                  <1> 	cmc				; invert CF flag (CF = 1 - graphics)
  2627 00005727 7303                <1> 	jnc	.exit			; jump if not graphics (CF = 0, ZF = 0)
  2628 00005729 18C0                <1> 	sbb	al,al			; AL=AL-(AL+CF) set CF and clear ZF?
  2629 0000572B F9                  <1> 	stc				; set CF back
  2630                              <1> 
  2631                              <1> .exit:
  2632 0000572C 58                  <1> 	pop	ax
  2633 0000572D C3                  <1> 	ret
  2634                              <1> 
  2635                              <1> ;=========================================================================
  2636                              <1> ; vid_crtc_writew - Write a word to two consecutive CRTC registers
  2637                              <1> ; Input:
  2638                              <1> ;	AH = register number
  2639                              <1> ;	CX = word to write
  2640                              <1> ; Output:
  2641                              <1> ;	AX trashed
  2642                              <1> ; Note:
  2643                              <1> ;	Writes CH to register number AH, and CL to register number AH+1
  2644                              <1> ;-------------------------------------------------------------------------
  2645                              <1> vid_crtc_writew:
  2646 0000572E 88E8                <1> 	mov	al,ch
  2647 00005730 E80400              <1> 	call	vid_crtc_writeb		; write CH to CRTC register AH
  2648 00005733 FEC4                <1> 	inc	ah			; point AH to the next register
  2649 00005735 88C8                <1> 	mov	al,cl			; prepare AL for vid_crtc_writeb
  2650                              <1> 
  2651                              <1> ; fall through to vid_crtc_writeb (writting to AH+1)
  2652                              <1> 
  2653                              <1> ;=========================================================================
  2654                              <1> ; vid_crtc_writew - Write a word to two consecutive CRTC registers
  2655                              <1> ; Input:
  2656                              <1> ;	AH = register number
  2657                              <1> ;	AL = byte to write
  2658                              <1> ; Output:
  2659                              <1> ;	none
  2660                              <1> ;-------------------------------------------------------------------------
  2661                              <1> vid_crtc_writeb:
  2662 00005737 52                  <1> 	push	dx
  2663 00005738 8B166300            <1> 	mov	dx,word [video_port]	; DX = CRTC index port
  2664 0000573C 86C4                <1> 	xchg	al,ah			; AH = byte, AL = register number
  2665 0000573E EE                  <1> 	out	dx,al			; write register number
  2666 0000573F 86C4                <1> 	xchg	al,ah			; AH = register numbet, AL = byte
  2667 00005741 FEC2                <1> 	inc	dl			; DX = CRTC data port
  2668 00005743 EE                  <1> 	out	dx,al			; write byte
  2669 00005744 5A                  <1> 	pop	dx
  2670 00005745 C3                  <1> 	ret
  2671                              <1> 
  2672                              <1> ;=========================================================================
  2673                              <1> ; vid_pixel_address - calculate pixel address and mask
  2674                              <1> ; Input:
  2675                              <1> ;	CX - column
  2676                              <1> ;	DX - row
  2677                              <1> ; Output:
  2678                              <1> ;	SI - pixel address
  2679                              <1> ;	CH - pixel mask
  2680                              <1> ;	CL - pixel position in the byte
  2681                              <1> ;	ZF - mode
  2682                              <1> ;		0 = 320x200
  2683                              <1> ;		1 = 640x200
  2684                              <1> ;-------------------------------------------------------------------------
  2685                              <1> vid_pixel_address:
  2686 00005746 31F6                <1> 	xor	si,si			; SI = 0
  2687 00005748 D0EA                <1> 	shr	dl,1			; divide row by two
  2688 0000574A 7303                <1> 	jnb	.even			; jump if on even row 
  2689 0000574C BE0020              <1> 	mov	si,2000h		; odd row - second video plane
  2690                              <1> 
  2691                              <1> .even:
  2692 0000574F B050                <1> 	mov	al,50h			; bytes in each row
  2693 00005751 F6E2                <1> 	mul	dl			; AX - address of the row
  2694                              <1> 
  2695 00005753 01C6                <1> 	add	si,ax			; add row address to SI
  2696 00005755 89CA                <1> 	mov	dx,cx			; DX - column
  2697 00005757 B90203              <1> 	mov	cx,0302h 		; CH - pixel pos mask, CL - shift
  2698 0000575A 803E490006          <1> 	cmp	byte [video_mode],6	; 640x200 mode?
  2699 0000575F 9C                  <1> 	pushf				; save ZF (and other flags
  2700 00005760 7503                <1> 	jnz	.1			; skip if not 640x200
  2701 00005762 B90307              <1> 	mov	cx,0703h 		; pixel pos mask and shift for 640x200
  2702                              <1> 
  2703                              <1> .1:
  2704 00005765 20D5                <1> 	and	ch,dl			; CH = pixel position in the byte
  2705 00005767 D3EA                <1> 	shr	dx,cl			; DX = address of the column
  2706 00005769 01D6                <1> 	add	si,dx			; add column address to SI
  2707 0000576B 86CD                <1> 	xchg	cl,ch			; CH = pixel mask, CL = pixel position
  2708 0000576D 9D                  <1> 	popf
  2709 0000576E C3                  <1> 	ret
  2710                              <1> 
  2711                              <1> ;=========================================================================
  2712                              <1> ; vid_current_offset - convert current cursor position to offset
  2713                              <1> ;		       relative to page starting address
  2714                              <1> ; Input:
  2715                              <1> ;	BL = page
  2716                              <1> ; Output:
  2717                              <1> ;	AX = offset
  2718                              <1> ;-------------------------------------------------------------------------
  2719                              <1> vid_current_offset:
  2720 0000576F B700                <1> 	mov	bh,0
  2721 00005771 D1E3                <1> 	shl	bx,1				; word index
  2722 00005773 8B4750              <1> 	mov	ax,word [bx+video_cur_pos]	; AX = current cursor position
  2723                              <1> 
  2724                              <1> ; fall through to vid_position_to_offset
  2725                              <1> 
  2726                              <1> ;=========================================================================
  2727                              <1> ; vid_position_to_offset - convert position (row and column) to offset
  2728                              <1> ;			   relative to page starting address
  2729                              <1> ; Input:
  2730                              <1> ;	AH = row
  2731                              <1> ;	AL = column
  2732                              <1> ; Output:
  2733                              <1> ;	AX = offset
  2734                              <1> ;-------------------------------------------------------------------------
  2735                              <1> vid_position_to_offset:
  2736 00005776 53                  <1> 	push	bx
  2737 00005777 88C3                <1> 	mov	bl,al			; BL = column
  2738 00005779 88E0                <1> 	mov	al,ah			; AL = row
  2739 0000577B F6264A00            <1> 	mul	byte [video_columns] 	; AX = row * video_columns
  2740 0000577F B700                <1> 	mov	bh,0			;
  2741 00005781 01D8                <1> 	add	ax,bx			; AX = row * video_columns + column
  2742 00005783 D1E0                <1> 	shl	ax,1			; multiply by two (char + attribute)
  2743 00005785 5B                  <1> 	pop	bx
  2744 00005786 C3                  <1> 	ret
  2745                              <1> 
  2746                              <1> ;=========================================================================
  2747                              <1> ; vid_gfx_pos_to_offset - convert position (row and column) to offset
  2748                              <1> ; Input:
  2749                              <1> ;	AH = row
  2750                              <1> ;	AL = column
  2751                              <1> ; Output:
  2752                              <1> ;	AX = offset
  2753                              <1> ;-------------------------------------------------------------------------
  2754                              <1> vid_gfx_pos_to_offset:
  2755 00005787 53                  <1> 	push	bx
  2756 00005788 88C3                <1> 	mov	bl,al			; BL = column
  2757 0000578A 88E0                <1> 	mov	al,ah			; AL = row
  2758 0000578C F6264A00            <1> 	mul	byte [video_columns] 	; AX = row * video_columns
  2759 00005790 D1E0                <1> 	shl	ax,1			; multiply by four: one character takes
  2760 00005792 D1E0                <1> 	shl	ax,1			;   four bytes in each plane
  2761 00005794 B700                <1> 	mov	bh,0
  2762 00005796 01D8                <1> 	add	ax,bx			; AX = row * video_columns * 4 + column
  2763 00005798 5B                  <1> 	pop	bx
  2764 00005799 C3                  <1> 	ret
  1299                                  
  1300                                  ;=========================================================================
  1301                                  ; detect_rom_ext - Look for BIOS extensions, initialize if found
  1302                                  ;-------------------------------------------------------------------------
  1303                                  
  1304                                  detect_rom_ext:
  1305 0000579A B040                    	mov	al,e_ext_start		; ROM extension scan start
  1306 0000579C E680                    	out	post_reg,al
  1307 0000579E E421                    	in	al,pic1_reg1		; get IMR (option ROMs may trash it)
  1308 000057A0 50                      	push	ax			; save it
  1309 000057A1 BA00C8                  	mov	dx,0C800h
  1310 000057A4 BB00F8                  	mov	bx,0F800h
  1311                                  %ifdef BIOS_SETUP
  1312 000057A7 E804B8                  	call	get_config_a
  1313 000057AA A804                    	test	al,nvram_ext_scan
  1314 000057AC 7403                    	jz	.ext_scan_loop		; ext_scan clear - scan till F8000
  1315 000057AE BB00F0                  	mov	bx,0F000h		; ext_scan set - scan till F0000
  1316                                  %endif ; BIOS_SETUP
  1317                                  
  1318                                  .ext_scan_loop:
  1319 000057B1 E8E200                  	call	extension_scan
  1320 000057B4 833E670000              	cmp	word [67h],0
  1321 000057B9 7429                    	jz	.ext_scan_done		; No ROM extension found
  1322 000057BB B041                    	mov	al,e_ext_detect		; ROM extension found
  1323 000057BD E680                    	out	post_reg,al
  1324 000057BF BE[0204]                	mov	si,msg_rom_found
  1325 000057C2 E851D0                  	call	print
  1326 000057C5 A16900                  	mov	ax,word [69h]		; ROM extension's segment
  1327 000057C8 E866D0                  	call	print_hex
  1328 000057CB BE[1F04]                	mov	si,msg_rom_init
  1329 000057CE E845D0                  	call	print
  1330 000057D1 53                      	push	bx
  1331 000057D2 52                      	push	dx
  1332 000057D3 FF1E6700                	call	far [67h]
  1333 000057D7 B84000                  	mov	ax,biosdseg		; DS = BIOS data area
  1334 000057DA 8ED8                    	mov	ds,ax
  1335 000057DC B042                    	mov	al,e_ext_init_ok	; ROM extension initialized
  1336 000057DE E680                    	out	post_reg,al
  1337 000057E0 5A                      	pop	dx
  1338 000057E1 5B                      	pop	bx
  1339 000057E2 EBCD                    	jmp	.ext_scan_loop
  1340                                  
  1341                                  .ext_scan_done:
  1342 000057E4 58                      	pop	ax			; get previous IMR
  1343 000057E5 E621                    	out	pic1_reg1,al		; restore it
  1344 000057E7 B043                    	mov	al,e_ext_complete	; ROM extension scan complete
  1345 000057E9 E680                    	out	post_reg,al
  1346                                  
  1347 000057EB C3                      	ret
  1348                                  
  1349                                  ;=========================================================================
  1350                                  ; detect_ram - Determine the size of installed RAM and test it
  1351                                  ; Input:
  1352                                  ;	none
  1353                                  ; Output:
  1354                                  ;	AX = RAM size
  1355                                  ;	CX, SI - trashed
  1356                                  ;-------------------------------------------------------------------------
  1357                                  detect_ram:
  1358 000057EC B030                    	mov	al,e_ram_start		; RAM scan start
  1359 000057EE E680                    	out	post_reg,al
  1360                                  
  1361 000057F0 1E                      	push	ds
  1362 000057F1 B106                    	mov	cl,6			; for SHL - converting KiB to segment
  1363 000057F3 B82000                  	mov	ax,MIN_RAM_SIZE
  1364                                  
  1365                                  .fill_loop:
  1366 000057F6 50                      	push	ax
  1367 000057F7 D3E0                    	shl	ax,cl			; convert KiB to segment (mult. by 64)
  1368 000057F9 8ED8                    	mov	ds,ax
  1369 000057FB A3FE3F                  	mov	word [RAM_TEST_BLOCK-2],ax
  1370 000057FE 58                      	pop	ax
  1371 000057FF 83C010                  	add	ax,RAM_TEST_BLOCK/1024
  1372 00005802 3D8002                  	cmp	ax,MAX_RAM_SIZE
  1373 00005805 75EF                    	jne	.fill_loop
  1374 00005807 B82000                  	mov	ax,MIN_RAM_SIZE
  1375                                  
  1376                                  .size_loop:
  1377 0000580A 50                      	push	ax
  1378 0000580B D3E0                    	shl	ax,cl			; convert KiB to segment (mult. by 64)
  1379 0000580D 8ED8                    	mov	ds,ax
  1380 0000580F 3906FE3F                	cmp	word [RAM_TEST_BLOCK-2],ax
  1381 00005813 750B                    	jne	.size_done
  1382 00005815 58                      	pop	ax
  1383 00005816 83C010                  	add	ax,RAM_TEST_BLOCK/1024
  1384 00005819 3D8002                  	cmp	ax,MAX_RAM_SIZE
  1385 0000581C 7303                    	jnb	.size_exit
  1386 0000581E EBEA                    	jmp	.size_loop
  1387                                  
  1388                                  .size_done:
  1389 00005820 58                      	pop	ax
  1390                                  
  1391                                  .size_exit:
  1392 00005821 1F                      	pop	ds
  1393 00005822 A31300                  	mov	word [memory_size],ax	; store it for now... might change later
  1394 00005825 C3                      	ret
  1395                                  
  1396                                  ;=========================================================================
  1397                                  ; int_12 - Get memory size
  1398                                  ; Input:
  1399                                  ;	none
  1400                                  ; Output:
  1401                                  ;	AX = memory size
  1402                                  ;-------------------------------------------------------------------------
  1403 00005826 FF<rep 1Bh>             	setloc	0F841h			; INT 12 Entry Point
  1403          ******************       warning: Inserting 27 bytes [-w+user]
  1404                                  int_12:
  1405 00005841 FB                      	sti
  1406 00005842 1E                      	push	ds
  1407 00005843 B84000                  	mov	ax,biosdseg
  1408 00005846 8ED8                    	mov	ds,ax
  1409 00005848 A11300                  	mov	ax,word [memory_size]
  1410 0000584B 1F                      	pop	ds
  1411 0000584C CF                      	iret
  1412                                  
  1413                                  ;=========================================================================
  1414                                  ; int_11 - Get equipment list
  1415                                  ; Input:
  1416                                  ;	none
  1417                                  ; Output:
  1418                                  ;	AX = equipment list
  1419                                  ;-------------------------------------------------------------------------
  1420                                  	setloc	0F84Dh			; INT 11 Entry Point
  1421                                  int_11:
  1422 0000584D FB                      	sti
  1423 0000584E 1E                      	push	ds
  1424 0000584F B84000                  	mov	ax,biosdseg
  1425 00005852 8ED8                    	mov	ds,ax
  1426 00005854 A11000                  	mov	ax,word [equipment_list]
  1427 00005857 1F                      	pop	ds
  1428 00005858 CF                      	iret
  1429                                  
  1430                                  ;=========================================================================
  1431                                  ; Includes with fixed entry points (for IBM compatibility)
  1432                                  ;-------------------------------------------------------------------------
  1433                                  
  1434                                  %include	"misc.inc"
  1435                              <1> ;=========================================================================
  1436                              <1> ; misc.inc - Miscellaneous BIOS Services
  1437                              <1> ;       INT 15h, functions:
  1438                              <1> ;       	4Fh	- OS hook keyboard intercept
  1439                              <1> ;		90h	- Device busy loop
  1440                              <1> ;		91h	- Interrupt completed
  1441                              <1> ;		0C0h	- Get system configruation
  1442                              <1> ;		0C2h	- PS/2 mouse services (see ps2aux.inc)
  1443                              <1> ;		
  1444                              <1> ;-------------------------------------------------------------------------
  1445                              <1> ;
  1446                              <1> ; Compiles with NASM 2.13.02, might work with other versions
  1447                              <1> ;
  1448                              <1> ; Copyright (C) 2010 - 2023 Sergey Kiselev.
  1449                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
  1450                              <1> ;
  1451                              <1> ; This program is free software: you can redistribute it and/or modify
  1452                              <1> ; it under the terms of the GNU General Public License as published by
  1453                              <1> ; the Free Software Foundation, either version 3 of the License, or
  1454                              <1> ; (at your option) any later version.
  1455                              <1> ;
  1456                              <1> ; This program is distributed in the hope that it will be useful,
  1457                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  1458                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  1459                              <1> ; GNU General Public License for more details.
  1460                              <1> ;
  1461                              <1> ; You should have received a copy of the GNU General Public License
  1462                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  1463                              <1> ;
  1464                              <1> ;=========================================================================
  1465                              <1> 
  1466                              <1> ;-------------------------------------------------------------------------
  1467                              <1> ; offsets for registers on stack
  1468                              <1> int_15_bp	equ	0
  1469                              <1> int_15_ip	equ	int_15_bp+2
  1470                              <1> int_15_cs	equ	int_15_ip+2
  1471                              <1> int_15_flags	equ	int_15_cs+2
  1472                              <1> 
  1473                              <1> ;=========================================================================
  1474                              <1> ; int_15 - Miscellaneous BIOS services
  1475                              <1> ; Input:
  1476                              <1> ;	AH = 4Fh - OS hook keyboard intercept
  1477                              <1> ;		- Does nothing
  1478                              <1> ;	AH = 0C2h - PS/2 mouse services
  1479                              <1> ;		- Implemented in ps2aux.inc
  1480                              <1> ;-------------------------------------------------------------------------
  1481                              <1> 	setloc	0F859h			; INT 15 Entry Point
  1482                              <1> int_15:
  1483 00005859 FB                  <1> 	sti
  1484 0000585A 80FC4F              <1> 	cmp	ah,4Fh
  1485 0000585D 742A                <1> 	je	int_15_exit		; continue with int 09h ISR
  1486 0000585F 80FCC0              <1> 	cmp	ah,0C0h
  1487 00005862 7426                <1> 	je	int_15_fnC0
  1488 00005864 3D0190              <1> 	cmp	ax,9001h
  1489 00005867 741E                <1> 	je	int_15_os_hook		; diskette - device busy hook
  1490 00005869 3DFD90              <1> 	cmp	ax,90FDh
  1491 0000586C 7419                <1> 	je	int_15_os_hook		; diskette - motor start hook
  1492 0000586E 3D0191              <1> 	cmp	ax,9101h
  1493 00005871 7414                <1> 	je	int_15_os_hook		; diskette - interrupt completed
  1494                              <1> 
  1495                              <1> %ifdef PS2_MOUSE
  1496                              <1> 	cmp	ah,0C2h
  1497                              <1> 	jne	.1
  1498                              <1> 	jmp	int_15_fnC2		; jump to PS/2 mouse handler
  1499                              <1> .1:
  1500                              <1> %endif
  1501                              <1> 
  1502 00005873 B486                <1> 	mov	ah,86h			; no cassete present
  1503                              <1> 
  1504                              <1> int_15_err:
  1505 00005875 55                  <1> 	push	bp
  1506 00005876 89E5                <1> 	mov	bp,sp
  1507 00005878 804E0601            <1> 	or	byte [bp+int_15_flags],1 ; set CF flag
  1508 0000587C 5D                  <1> 	pop	bp
  1509 0000587D CF                  <1> 	iret
  1510                              <1> 
  1511                              <1> int_15_ok:
  1512 0000587E 55                  <1> 	push	bp
  1513 0000587F 89E5                <1> 	mov	bp,sp
  1514 00005881 806606FE            <1> 	and	byte [bp+int_15_flags],~1 ; clear CF flag
  1515 00005885 5D                  <1> 	pop	bp
  1516 00005886 CF                  <1> 	iret
  1517                              <1> 
  1518                              <1> int_15_os_hook:
  1519 00005887 B400                <1> 	mov	ah,00h
  1520                              <1> 
  1521                              <1> int_15_exit:
  1522 00005889 CF                  <1> 	iret
  1523                              <1> 
  1524                              <1> ;=========================================================================
  1525                              <1> ; int_15_fnC0 - Get configuration
  1526                              <1> ; Input:
  1527                              <1> ;	AH = 0C0h - get configuration
  1528                              <1> ; Output:
  1529                              <1> ;	AH = 00h - function supported
  1530                              <1> ;	ES:BX = configuration table (0F000h:0E6F5h)
  1531                              <1> ;	CF = 0 (success)
  1532                              <1> ;-------------------------------------------------------------------------
  1533                              <1> int_15_fnC0:
  1534 0000588A B400                <1> 	mov	ah,00h
  1535 0000588C BB00F0              <1> 	mov	bx,bioscseg
  1536 0000588F 8EC3                <1> 	mov	es,bx
  1537 00005891 BB[F546]            <1> 	mov	bx,config_table
  1538 00005894 EBE8                <1> 	jmp	int_15_ok
  1435                                  
  1436                                  ;=========================================================================
  1437                                  ; extension_scan - scan for BIOS extensions
  1438                                  ; Input:
  1439                                  ;	DX - start segment
  1440                                  ;	BX - end segment
  1441                                  ; Returns:
  1442                                  ;	DX - address for the continuation of the scan
  1443                                  ;	biosdseg:67h - address of the extension, 0000:0000 if not found
  1444                                  ;-------------------------------------------------------------------------
  1445                                  extension_scan:
  1446 00005896 C70667000000            	mov	word [67h],0
  1447 0000589C C70669000000            	mov	word [69h],0
  1448                                  .scan:
  1449 000058A2 8EC2                    	mov	es,dx
  1450 000058A4 26813E000055AA              es	cmp	word [0],0AA55h		; check for signature
  1451 000058AB 7532                    	jnz	.next			; no signature, check next 2 KiB
  1452 000058AD 26A00200                    es	mov	al,byte [2]		; AL = rom size in 512 byte blocks
  1453 000058B1 B400                    	mov	ah,0
  1454 000058B3 B105                    	mov	cl,5
  1455 000058B5 D3E0                    	shl	ax,cl			; convert size to paragraphs
  1456 000058B7 01C2                    	add	dx,ax
  1457 000058B9 83C27F                  	add	dx,007Fh		; round DX to the nearest 2 KiB
  1458 000058BC 83E280                  	and	dx,0FF80h		; (2 KiB = 128 x 16 bytes)
  1459 000058BF B104                    	mov	cl,4
  1460 000058C1 D3E0                    	shl	ax,cl			; convert size to bytes
  1461 000058C3 89C1                    	mov	cx,ax
  1462 000058C5 B000                    	mov	al,0
  1463 000058C7 31F6                    	xor	si,si
  1464                                  .checksum:
  1465 000058C9 260204                      es	add	al,byte [si]
  1466 000058CC 46                      	inc	si
  1467 000058CD E2FA                    	loop	.checksum
  1468 000058CF 08C0                    	or	al,al			; AL == 0?
  1469 000058D1 750C                    	jnz	.next			; AL not zero - bad checksum
  1470 000058D3 C70667000300            	mov	word [67h],3		; extension initialization offset
  1471 000058D9 8C066900                	mov	word [69h],es		; extension segment
  1472 000058DD EB08                    	jmp	.exit
  1473                                  .next:
  1474 000058DF 81C28000                	add	dx,80h			; add 2 KiB
  1475 000058E3 39DA                    	cmp	dx,bx
  1476 000058E5 72BB                    	jb	.scan
  1477                                  .exit:
  1478 000058E7 C3                      	ret
  1479                                  
  1480                                  ;=========================================================================
  1481                                  ; ipl - Initial Program Load - try to read and execute boot sector
  1482                                  ;-------------------------------------------------------------------------
  1483                                  ipl:
  1484 000058E8 FB                      	sti
  1485 000058E9 31C0                    	xor	ax,ax
  1486 000058EB 8ED8                    	mov	ds,ax
  1487 000058ED C7067800[C74F]          	mov	word [78h],int_1E	; set Floppy Parameters Table location
  1488 000058F3 8C0E7A00                	mov	word [7Ah],cs
  1489                                  
  1490                                  .boot_retry:
  1491 000058F7 B90400                  	mov	cx,4			; retry booting from floppy 4 times
  1492                                  
  1493                                  .fd_read_retry:
  1494 000058FA 51                      	push	cx
  1495 000058FB B400                    	mov	ah,00h			; reset disk system
  1496 000058FD B200                    	mov	dl,00h			; drive 0
  1497 000058FF CD13                    	int	13h
  1498 00005901 7220                    	jb	.fd_failed
  1499 00005903 B408                    	mov	ah,08h			; get drive parameters
  1500 00005905 B200                    	mov	dl,00h			; drive 0
  1501 00005907 CD13                    	int	13h
  1502 00005909 7218                    	jc	.fd_failed
  1503 0000590B 80FA00                  	cmp	dl,00h
  1504 0000590E 7416                    	jz	.try_hdd		; jump if zero drives
  1505 00005910 B80102                  	mov	ax,0201h		; read one sector
  1506 00005913 31D2                    	xor	dx,dx			; head 0, drive 0
  1507 00005915 8EC2                    	mov	es,dx			; to 0000:7C00
  1508 00005917 BB007C                  	mov	bx,7C00h
  1509 0000591A B90100                  	mov	cx,0001h		; track 0, sector 1
  1510 0000591D CD13                    	int	13h
  1511 0000591F 7202                    	jc	.fd_failed
  1512 00005921 EB1D                    	jmp	.check_signature	; read successful, check for boot sector
  1513                                  
  1514                                  .fd_failed:
  1515 00005923 59                      	pop	cx
  1516 00005924 E2D4                    	loop	.fd_read_retry
  1517                                  
  1518                                  ; try booting from HDD
  1519                                  .try_hdd:
  1520 00005926 B40D                    	mov	ah,0Dh			; reset hard disks
  1521 00005928 B280                    	mov	dl,80h			; drive 80h
  1522 0000592A CD13                    	int	13h
  1523 0000592C 7220                    	jc	.boot_failed
  1524 0000592E B80102                  	mov	ax,0201h		; read one sector
  1525 00005931 BA8000                  	mov	dx,0080h		; head 0, drive 80h
  1526 00005934 31C9                    	xor	cx,cx
  1527 00005936 8EC1                    	mov	es,cx
  1528 00005938 BB007C                  	mov	bx,7C00h		; to 0000:7C00
  1529 0000593B 41                      	inc	cx			; CX == 0001h; track 0, sector 1
  1530 0000593C CD13                    	int	13h
  1531 0000593E 720E                    	jc	.boot_failed
  1532                                  
  1533                                  .check_signature:
  1534 00005940 26813EFE7D55AA              es	cmp	word [7DFEh],0AA55h
  1535 00005947 7505                    	jnz	.boot_failed		; boot sector signature not found
  1536 00005949 EA007C0000              	jmp	0000h:7C00h		; jump to the boot sector
  1537                                  
  1538                                  .boot_failed:
  1539 0000594E BE[C603]                	mov	si,msg_boot_failed
  1540 00005951 E8C2CE                  	call	print
  1541 00005954 B400                    	mov	ah,00h
  1542 00005956 CD16                    	int	16h
  1543 00005958 EB9D                    	jmp	.boot_retry
  1544                                  
  1545                                  ;=========================================================================
  1546                                  ; test_ram - Test installed RAM
  1547                                  ; Input:
  1548                                  ;	AX = detected RAM size
  1549                                  ; Output:
  1550                                  ;	AX = tested RAM size
  1551                                  ;	CX, SI - trashed
  1552                                  ;-------------------------------------------------------------------------
  1553                                  test_ram:
  1554 0000595A 813E72003412            	cmp	word [warm_boot],1234h	; warm boot - don't test RAM
  1555 00005960 747D                    	je	.test_done
  1556                                  
  1557                                  %ifdef BIOS_SETUP
  1558 00005962 50                      	push	ax
  1559 00005963 E848B6                  	call	get_config_a
  1560 00005966 A808                    	test	al,nvram_mem_test
  1561 00005968 58                      	pop	ax
  1562 00005969 7574                    	jnz	.test_done		; mem_test set - skip memory test
  1563                                  %endif ; BIOS_SETUP
  1564                                  
  1565 0000596B BE[6003]                	mov	si,msg_ram_testing
  1566 0000596E E8A5CE                  	call	print
  1567 00005971 B82000                  	mov	ax,MIN_RAM_SIZE		; start from 32 KiB
  1568                                  
  1569                                  .test_loop:
  1570 00005974 50                      	push	ax
  1571 00005975 B403                    	mov	ah,03h			; INT 10h, AH=03h - get cursor position
  1572 00005977 B700                    	mov	bh,00h			; page 0
  1573 00005979 CD10                    	int	10h			; position returned in DX
  1574 0000597B 58                      	pop	ax
  1575 0000597C E8D4CE                  	call	print_dec
  1576 0000597F 50                      	push	ax
  1577 00005980 B402                    	mov	ah,02h			; INT 10h, AH=02h - set cursor position
  1578 00005982 B700                    	mov	bh,00h			; page 0
  1579 00005984 CD10                    	int	10h
  1580 00005986 B401                    	mov	ah,01h
  1581 00005988 CD16                    	int	16h
  1582 0000598A 7412                    	jz	.test_no_key
  1583 0000598C B400                    	mov	ah,00h
  1584 0000598E CD16                    	int	16h			; read the keystroke
  1585 00005990 3C1B                    	cmp	al,1Bh			; ESC?
  1586 00005992 7421                    	je	.test_esc
  1587 00005994 3D003B                  	cmp	ax,3B00h		; F1?
  1588 00005997 7505                    	jne	.test_no_key
  1589 00005999 800E120001              	or	byte [post_flags],post_setup
  1590                                  
  1591                                  .test_no_key:
  1592 0000599E 58                      	pop	ax
  1593 0000599F E83E00                  	call	ram_test_block
  1594 000059A2 721D                    	jc	.test_error		; error in last test
  1595 000059A4 83C010                  	add	ax,RAM_TEST_BLOCK/1024	; test the next block
  1596 000059A7 3B061300                	cmp	ax,word [memory_size]
  1597 000059AB 72C7                    	jb	.test_loop
  1598                                  
  1599 000059AD 50                      	push	ax
  1600 000059AE B031                    	mov	al,e_ram_complete	; RAM scan complete
  1601 000059B0 E680                    	out	post_reg,al
  1602 000059B2 58                      	pop	ax
  1603                                  
  1604 000059B3 EB2A                    	jmp	.test_done
  1605                                  
  1606                                  .test_esc:
  1607 000059B5 58                      	pop	ax
  1608 000059B6 A11300                  	mov	ax,word [memory_size]
  1609                                  
  1610 000059B9 50                      	push	ax
  1611 000059BA B032                    	mov	al,e_ram_esc		; RAM scan canceled
  1612 000059BC E680                    	out	post_reg,al
  1613 000059BE 58                      	pop	ax
  1614                                  
  1615 000059BF EB1E                    	jmp	.test_done
  1616                                  
  1617                                  .test_error:
  1618 000059C1 A31300                  	mov	word [memory_size],ax	; store size of good memory
  1619 000059C4 BE[7D03]                	mov	si,msg_ram_error
  1620 000059C7 E84CCE                  	call	print
  1621 000059CA E886CE                  	call	print_dec
  1622 000059CD BE[BF03]                	mov	si,msg_kib
  1623 000059D0 E843CE                  	call	print
  1624 000059D3 BE[8B00]                	mov	si,msg_crlf
  1625 000059D6 E83DCE                  	call	print
  1626                                  
  1627 000059D9 50                      	push	ax
  1628 000059DA B055                    	mov	al,e_ram_fail		; RAM scan failed
  1629 000059DC E680                    	out	post_reg,al
  1630 000059DE 58                      	pop	ax
  1631                                  
  1632                                  .test_done:
  1633 000059DF C3                      	ret
  1634                                  
  1635                                  ;=========================================================================
  1636                                  ; ram_test_block - Test a 16 KiB (RAM_TEST_BLOCK) of RAM
  1637                                  ; Input:
  1638                                  ;	AX = address of the memory to test (in KiB)
  1639                                  ; Output:
  1640                                  ;	CF = status
  1641                                  ;		0 = passed
  1642                                  ;		1 = failed
  1643                                  ;-------------------------------------------------------------------------
  1644                                  ram_test_block:
  1645 000059E0 50                      	push	ax
  1646 000059E1 53                      	push	bx
  1647 000059E2 51                      	push	cx
  1648 000059E3 56                      	push	si
  1649 000059E4 57                      	push	di
  1650 000059E5 1E                      	push	ds
  1651 000059E6 06                      	push	es
  1652 000059E7 B106                    	mov	cl,6			; convert KiB to segment address
  1653 000059E9 D3E0                    	shl	ax,cl			; (multiply by 64)
  1654 000059EB 8ED8                    	mov	ds,ax
  1655 000059ED 8EC0                    	mov	es,ax
  1656 000059EF 31F6                    	xor	si,si
  1657 000059F1 31FF                    	xor	di,di
  1658 000059F3 BB0020                  	mov	bx,RAM_TEST_BLOCK/2	; RAM test block size in words
  1659 000059F6 B8AA55                  	mov	ax,55AAh		; first test pattern
  1660 000059F9 89D9                    	mov	cx,bx
  1661 000059FB F3AB                        rep	stosw				; store test pattern
  1662 000059FD 89D9                    	mov	cx,bx			; RAM test block size
  1663                                  .1:
  1664 000059FF AD                      	lodsw
  1665 00005A00 3DAA55                  	cmp	ax,55AAh		; compare to the test pattern
  1666 00005A03 7522                    	jne	.fail
  1667 00005A05 E2F8                    	loop	.1
  1668 00005A07 31F6                    	xor	si,si
  1669 00005A09 31FF                    	xor	di,di
  1670 00005A0B B855AA                  	mov	ax,0AA55h		; second test pattern
  1671 00005A0E 89D9                    	mov	cx,bx			; RAM test block size
  1672 00005A10 F3AB                        rep stosw				; store test pattern
  1673 00005A12 89D9                    	mov	cx,bx			; RAM test block size
  1674                                  .2:
  1675 00005A14 AD                      	lodsw
  1676 00005A15 3D55AA                  	cmp	ax,0AA55h		; compare to the test pattern
  1677 00005A18 750D                    	jne	.fail
  1678 00005A1A E2F8                    	loop	.2
  1679 00005A1C 31FF                    	xor	di,di
  1680 00005A1E 31C0                    	xor	ax,ax			; zero
  1681 00005A20 89D9                    	mov	cx,bx			; RAM test block size
  1682 00005A22 F3AB                        rep stosw				; zero the memory
  1683 00005A24 F8                      	clc				; test passed, clear CF
  1684 00005A25 EB01                    	jmp	.exit
  1685                                  
  1686                                  .fail:
  1687 00005A27 F9                      	stc				; test failed, set CF
  1688                                  	
  1689                                  .exit:
  1690 00005A28 07                      	pop	es
  1691 00005A29 1F                      	pop	ds
  1692 00005A2A 5F                      	pop	di
  1693 00005A2B 5E                      	pop	si
  1694 00005A2C 59                      	pop	cx
  1695 00005A2D 5B                      	pop	bx
  1696 00005A2E 58                      	pop	ax
  1697 00005A2F C3                      	ret
  1698                                  
  1699                                  ;=========================================================================
  1700                                  ; Includes with fixed entry points (for IBM compatibility)
  1701                                  ;-------------------------------------------------------------------------
  1702                                  %include	"fnt00-7F.inc"
  1703                              <1> ;=========================================================================
  1704                              <1> ; fnt00-7F.inc - Font for graphics modes
  1705                              <1> ;       Characters from 00h to 7Fh
  1706                              <1> ;-------------------------------------------------------------------------
  1707                              <1> ;
  1708                              <1> ; Compiles with NASM 2.13.02, might work with other versions
  1709                              <1> ;
  1710                              <1> ; This font is borrowed from kbd package (alt-8x8)
  1711                              <1> ;
  1712                              <1> ; This program is free software: you can redistribute it and/or modify
  1713                              <1> ; it under the terms of the GNU General Public License as published by
  1714                              <1> ; the Free Software Foundation, either version 3 of the License, or
  1715                              <1> ; (at your option) any later version.
  1716                              <1> ;
  1717                              <1> ; This program is distributed in the hope that it will be useful,
  1718                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  1719                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  1720                              <1> ; GNU General Public License for more details.
  1721                              <1> ;
  1722                              <1> ; You should have received a copy of the GNU General Public License
  1723                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  1724                              <1> ;
  1725                              <1> ;=========================================================================
  1726 00005A30 FF<rep 3Eh>         <1> 	setloc	0FA6Eh			; IBM graphics char set entry
  1726          ******************  <1>  warning: Inserting 62 bytes [-w+user]
  1727                              <1> gfx_font:
  1728 00005A6E 0000000000000000    <1> 	db	 00h, 00h,   00h,  00h,  00h,  00h,  00h,  00h
  1729 00005A76 7E81A581BD99817E    <1> 	db	 7Eh, 81h,  0A5h,  81h, 0BDh,  99h,  81h,  7Eh
  1730 00005A7E 7EFFDBFFC3E7FF7E    <1> 	db	 7Eh, 0FFh, 0DBh, 0FFh, 0C3h, 0E7h, 0FFh,  7Eh
  1731 00005A86 6CFEFEFE7C381000    <1> 	db	 6Ch, 0FEh, 0FEh, 0FEh,  7Ch,  38h,  10h,  00h
  1732 00005A8E 10387CFE7C381000    <1> 	db	 10h,  38h,  7Ch, 0FEh,  7Ch,  38h,  10h,  00h
  1733 00005A96 387C38FEFE7C387C    <1> 	db	 38h,  7Ch,  38h, 0FEh, 0FEh,  7Ch,  38h,  7Ch
  1734 00005A9E 1010387CFE7C387C    <1> 	db	 10h,  10h,  38h,  7Ch, 0FEh,  7Ch,  38h,  7Ch
  1735 00005AA6 0000183C3C180000    <1> 	db	 00h,  00h,  18h,  3Ch,  3Ch,  18h,  00h,  00h
  1736 00005AAE FFFFE7C3C3E7FFFF    <1> 	db	0FFh, 0FFh, 0E7h, 0C3h, 0C3h, 0E7h, 0FFh, 0FFh
  1737 00005AB6 003C664242663C00    <1> 	db	 00h,  3Ch,  66h,  42h,  42h,  66h,  3Ch,  00h
  1738 00005ABE FFC399BDBD99C3FF    <1> 	db	0FFh, 0C3h,  99h, 0BDh, 0BDh,  99h, 0C3h, 0FFh
  1739 00005AC6 0F070F7DCCCCCC78    <1> 	db	 0Fh,  07h,  0Fh,  7Dh, 0CCh, 0CCh, 0CCh,  78h
  1740 00005ACE 3C6666663C187E18    <1> 	db	 3Ch,  66h,  66h,  66h,  3Ch,  18h,  7Eh,  18h
  1741 00005AD6 3F333F303070F0E0    <1> 	db	 3Fh,  33h,  3Fh,  30h,  30h,  70h, 0F0h, 0E0h
  1742 00005ADE 7F637F636367E6C0    <1> 	db	 7Fh,  63h,  7Fh,  63h,  63h,  67h, 0E6h, 0C0h
  1743 00005AE6 995A3CE7E73C5A99    <1> 	db	 99h,  5Ah,  3Ch, 0E7h, 0E7h,  3Ch,  5Ah,  99h
  1744 00005AEE 80E0F8FEF8E08000    <1> 	db	 80h, 0E0h, 0F8h, 0FEh, 0F8h, 0E0h,  80h,  00h
  1745 00005AF6 020E3EFE3E0E0200    <1> 	db	 02h,  0Eh,  3Eh, 0FEh,  3Eh,  0Eh,  02h,  00h
  1746 00005AFE 183C7E18187E3C18    <1> 	db	 18h,  3Ch,  7Eh,  18h,  18h,  7Eh,  3Ch,  18h
  1747 00005B06 6666666666006600    <1> 	db	 66h,  66h,  66h,  66h,  66h,  00h,  66h,  00h
  1748 00005B0E 7FDBDB7B1B1B1B00    <1> 	db	 7Fh, 0DBh, 0DBh,  7Bh,  1Bh,  1Bh,  1Bh,  00h
  1749 00005B16 3E63386C6C38CC78    <1> 	db	 3Eh,  63h,  38h,  6Ch,  6Ch,  38h, 0CCh,  78h
  1750 00005B1E 000000007E7E7E00    <1> 	db	 00h,  00h,  00h,  00h,  7Eh,  7Eh,  7Eh,  00h
  1751 00005B26 183C7E187E3C18FF    <1> 	db	 18h,  3Ch,  7Eh,  18h,  7Eh,  3Ch,  18h, 0FFh
  1752 00005B2E 183C7E1818181800    <1> 	db	 18h,  3Ch,  7Eh,  18h,  18h,  18h,  18h,  00h
  1753 00005B36 181818187E3C1800    <1> 	db	 18h,  18h,  18h,  18h,  7Eh,  3Ch,  18h,  00h
  1754 00005B3E 00180CFE0C180000    <1> 	db	 00h,  18h,  0Ch, 0FEh,  0Ch,  18h,  00h,  00h
  1755 00005B46 003060FE60300000    <1> 	db	 00h,  30h,  60h, 0FEh,  60h,  30h,  00h,  00h
  1756 00005B4E 0000C0C0C0FE0000    <1> 	db	 00h,  00h, 0C0h, 0C0h, 0C0h, 0FEh,  00h,  00h
  1757 00005B56 002466FF66240000    <1> 	db	 00h,  24h,  66h, 0FFh,  66h,  24h,  00h,  00h
  1758 00005B5E 00183C7EFFFF0000    <1> 	db	 00h,  18h,  3Ch,  7Eh,  0FFh, 0FFh, 00h,  00h
  1759 00005B66 00FFFF7E3C180000    <1> 	db	 00h, 0FFh, 0FFh,  7Eh,  3Ch,  18h,  00h,  00h
  1760 00005B6E 0000000000000000    <1> 	db	 00h,  00h,  00h,  00h,  00h,  00h,  00h,  00h
  1761 00005B76 3078783030003000    <1> 	db	 30h,  78h,  78h,  30h,  30h,  00h,  30h,  00h
  1762 00005B7E 6C6C6C0000000000    <1> 	db	 6Ch,  6Ch,  6Ch,  00h,  00h,  00h,  00h,  00h
  1763 00005B86 6C6CFE6CFE6C6C00    <1> 	db	 6Ch,  6Ch, 0FEh,  6Ch, 0FEh,  6Ch,  6Ch,  00h
  1764 00005B8E 307CC0780CF83000    <1> 	db	 30h,  7Ch, 0C0h,  78h,  0Ch, 0F8h,  30h,  00h
  1765 00005B96 00C6CC183066C600    <1> 	db	 00h, 0C6h, 0CCh,  18h,  30h,  66h, 0C6h,  00h
  1766 00005B9E 386C3876DCCC7600    <1> 	db	 38h,  6Ch,  38h,  76h, 0DCh, 0CCh,  76h,  00h
  1767 00005BA6 6060C00000000000    <1> 	db	 60h,  60h, 0C0h,  00h,  00h,  00h,  00h,  00h
  1768 00005BAE 1830606060301800    <1> 	db	 18h,  30h,  60h,  60h,  60h,  30h,  18h,  00h
  1769 00005BB6 6030181818306000    <1> 	db	 60h,  30h,  18h,  18h,  18h,  30h,  60h,  00h
  1770 00005BBE 00663CFF3C660000    <1> 	db	 00h,  66h,  3Ch, 0FFh,  3Ch,  66h,  00h,  00h
  1771 00005BC6 003030FC30300000    <1> 	db	 00h,  30h,  30h, 0FCh,  30h,  30h,  00h,  00h
  1772 00005BCE 0000000000303060    <1> 	db	 00h,  00h,  00h,  00h,  00h,  30h,  30h,  60h
  1773 00005BD6 000000FC00000000    <1> 	db	 00h,  00h,  00h, 0FCh,  00h,  00h,  00h,  00h
  1774 00005BDE 0000000000303000    <1> 	db	 00h,  00h,  00h,  00h,  00h,  30h,  30h,  00h
  1775 00005BE6 060C183060C08000    <1> 	db	 06h,  0Ch,  18h,  30h,  60h, 0C0h,  80h,  00h
  1776 00005BEE 7CC6CEDEF6E67C00    <1> 	db	 7Ch, 0C6h, 0CEh, 0DEh, 0F6h, 0E6h,  7Ch,  00h
  1777 00005BF6 307030303030FC00    <1> 	db	 30h,  70h,  30h,  30h,  30h,  30h, 0FCh,  00h
  1778 00005BFE 78CC0C3860CCFC00    <1> 	db	 78h, 0CCh,  0Ch,  38h,  60h, 0CCh, 0FCh,  00h
  1779 00005C06 78CC0C380CCC7800    <1> 	db	 78h, 0CCh,  0Ch,  38h,  0Ch, 0CCh,  78h,  00h
  1780 00005C0E 1C3C6CCCFE0C1E00    <1> 	db	 1Ch,  3Ch,  6Ch, 0CCh, 0FEh,  0Ch,  1Eh,  00h
  1781 00005C16 FCC0F80C0CCC7800    <1> 	db	0FCh, 0C0h, 0F8h,  0Ch,  0Ch, 0CCh,  78h,  00h
  1782 00005C1E 3860C0F8CCCC7800    <1> 	db	 38h,  60h, 0C0h, 0F8h, 0CCh, 0CCh,  78h,  00h
  1783 00005C26 FCCC0C1830303000    <1> 	db	0FCh, 0CCh,  0Ch,  18h,  30h,  30h,  30h,  00h
  1784 00005C2E 78CCCC78CCCC7800    <1> 	db	 78h, 0CCh, 0CCh,  78h, 0CCh, 0CCh,  78h,  00h
  1785 00005C36 78CCCC7C0C187000    <1> 	db	 78h, 0CCh, 0CCh,  7Ch,  0Ch,  18h,  70h,  00h
  1786 00005C3E 0030300000303000    <1> 	db	 00h,  30h,  30h,  00h,  00h,  30h,  30h,  00h
  1787 00005C46 0030300000303060    <1> 	db	 00h,  30h,  30h,  00h,  00h,  30h,  30h,  60h
  1788 00005C4E 183060C060301800    <1> 	db	 18h,  30h,  60h, 0C0h,  60h,  30h,  18h,  00h
  1789 00005C56 0000FC0000FC0000    <1> 	db	 00h,  00h, 0FCh,  00h,  00h, 0FCh,  00h,  00h
  1790 00005C5E 6030180C18306000    <1> 	db	 60h,  30h,  18h,  0Ch,  18h,  30h,  60h,  00h
  1791 00005C66 78CC0C1830003000    <1> 	db	 78h, 0CCh,  0Ch,  18h,  30h,  00h,  30h,  00h
  1792 00005C6E 7CC6DEDEDEC07800    <1> 	db	 7Ch, 0C6h, 0DEh, 0DEh, 0DEh, 0C0h,  78h,  00h
  1793 00005C76 3078CCCCFCCCCC00    <1> 	db	 30h,  78h, 0CCh, 0CCh, 0FCh, 0CCh, 0CCh,  00h
  1794 00005C7E FC66667C6666FC00    <1> 	db	0FCh,  66h,  66h,  7Ch,  66h,  66h, 0FCh,  00h
  1795 00005C86 3C66C0C0C0663C00    <1> 	db	 3Ch,  66h, 0C0h, 0C0h, 0C0h,  66h,  3Ch,  00h
  1796 00005C8E F86C6666666CF800    <1> 	db	0F8h,  6Ch,  66h,  66h,  66h,  6Ch, 0F8h,  00h
  1797 00005C96 FE6268786862FE00    <1> 	db	0FEh,  62h,  68h,  78h,  68h,  62h, 0FEh,  00h
  1798 00005C9E FE6268786860F000    <1> 	db	0FEh,  62h,  68h,  78h,  68h,  60h, 0F0h,  00h
  1799 00005CA6 3C66C0C0CE663E00    <1> 	db	 3Ch,  66h, 0C0h, 0C0h, 0CEh,  66h,  3Eh,  00h
  1800 00005CAE CCCCCCFCCCCCCC00    <1> 	db	0CCh, 0CCh, 0CCh, 0FCh, 0CCh, 0CCh, 0CCh,  00h
  1801 00005CB6 7830303030307800    <1> 	db	 78h,  30h,  30h,  30h,  30h,  30h,  78h,  00h
  1802 00005CBE 1E0C0C0CCCCC7800    <1> 	db	 1Eh,  0Ch,  0Ch,  0Ch, 0CCh, 0CCh,  78h,  00h
  1803 00005CC6 E6666C786C66E600    <1> 	db	0E6h,  66h,  6Ch,  78h,  6Ch,  66h, 0E6h,  00h
  1804 00005CCE F06060606266FE00    <1> 	db	0F0h,  60h,  60h,  60h,  62h,  66h, 0FEh,  00h
  1805 00005CD6 C6EEFEFED6C6C600    <1> 	db	0C6h, 0EEh, 0FEh, 0FEh, 0D6h, 0C6h, 0C6h,  00h
  1806 00005CDE C6E6F6DECEC6C600    <1> 	db	0C6h, 0E6h, 0F6h, 0DEh, 0CEh, 0C6h, 0C6h,  00h
  1807 00005CE6 386CC6C6C66C3800    <1> 	db	 38h,  6Ch, 0C6h, 0C6h, 0C6h,  6Ch,  38h,  00h
  1808 00005CEE FC66667C6060F000    <1> 	db	0FCh,  66h,  66h,  7Ch,  60h,  60h, 0F0h,  00h
  1809 00005CF6 78CCCCCCDC781C00    <1> 	db	 78h, 0CCh, 0CCh, 0CCh, 0DCh,  78h,  1Ch,  00h
  1810 00005CFE FC66667C6C66E600    <1> 	db	0FCh,  66h,  66h,  7Ch,  6Ch,  66h, 0E6h,  00h
  1811 00005D06 78CCE0701CCC7800    <1> 	db	 78h, 0CCh, 0E0h,  70h,  1Ch, 0CCh,  78h,  00h
  1812 00005D0E FCB4303030307800    <1> 	db	0FCh, 0B4h,  30h,  30h,  30h,  30h,  78h,  00h
  1813 00005D16 CCCCCCCCCCCCFC00    <1> 	db	0CCh, 0CCh, 0CCh, 0CCh, 0CCh, 0CCh, 0FCh,  00h
  1814 00005D1E CCCCCCCCCC783000    <1> 	db	0CCh, 0CCh, 0CCh, 0CCh, 0CCh,  78h,  30h,  00h
  1815 00005D26 C6C6C6D6FEEEC600    <1> 	db	0C6h, 0C6h, 0C6h, 0D6h, 0FEh, 0EEh, 0C6h,  00h
  1816 00005D2E C6446C38386CC600    <1> 	db	0C6h,  44h,  6Ch,  38h,  38h,  6Ch, 0C6h,  00h
  1817 00005D36 CCCCCC7830307800    <1> 	db	0CCh, 0CCh, 0CCh,  78h,  30h,  30h,  78h,  00h
  1818 00005D3E FEC68C183266FE00    <1> 	db	0FEh, 0C6h,  8Ch,  18h,  32h,  66h, 0FEh,  00h
  1819 00005D46 7860606060607800    <1> 	db	 78h,  60h,  60h,  60h,  60h,  60h,  78h,  00h
  1820 00005D4E C06030180C060200    <1> 	db	0C0h,  60h,  30h,  18h,  0Ch,  06h,  02h,  00h
  1821 00005D56 7818181818187800    <1> 	db	 78h,  18h,  18h,  18h,  18h,  18h,  78h,  00h
  1822 00005D5E 10386CC600000000    <1> 	db	 10h,  38h,  6Ch, 0C6h,  00h,  00h,  00h,  00h
  1823 00005D66 00000000000000FF    <1> 	db	 00h,  00h,  00h,  00h,  00h,  00h,  00h, 0FFh
  1824 00005D6E 3030180000000000    <1> 	db	 30h,  30h,  18h,  00h,  00h,  00h,  00h,  00h
  1825 00005D76 0000780C7CCC7C00    <1> 	db	 00h,  00h,  78h,  0Ch,  7Ch, 0CCh,  7Ch,  00h
  1826 00005D7E 6060607C66667C00    <1> 	db	 60h,  60h,  60h,  7Ch,  66h,  66h,  7Ch,  00h
  1827 00005D86 000078CCC0CC7800    <1> 	db	 00h,  00h,  78h, 0CCh, 0C0h, 0CCh,  78h,  00h
  1828 00005D8E 0C0C0C7CCCCC7C00    <1> 	db	 0Ch,  0Ch,  0Ch,  7Ch, 0CCh, 0CCh,  7Ch,  00h
  1829 00005D96 000078CCFCC07800    <1> 	db	 00h,  00h,  78h, 0CCh, 0FCh, 0C0h,  78h,  00h
  1830 00005D9E 386C60F06060F000    <1> 	db	 38h,  6Ch,  60h, 0F0h,  60h,  60h, 0F0h,  00h
  1831 00005DA6 00007CCCCC7C0CF8    <1> 	db	 00h,  00h,  7Ch, 0CCh, 0CCh,  7Ch,  0Ch, 0F8h
  1832 00005DAE 60607C6666666600    <1> 	db	 60h,  60h,  7Ch,  66h,  66h,  66h,  66h,  00h
  1833 00005DB6 3000703030307800    <1> 	db	 30h,  00h,  70h,  30h,  30h,  30h,  78h,  00h
  1834 00005DBE 0C000C0C0C0C6C38    <1> 	db	 0Ch,  00h,  0Ch,  0Ch,  0Ch,  0Ch,  6Ch,  38h
  1835 00005DC6 6060666C786C6600    <1> 	db	 60h,  60h,  66h,  6Ch,  78h,  6Ch,  66h,  00h
  1836 00005DCE 7030303030307800    <1> 	db	 70h,  30h,  30h,  30h,  30h,  30h,  78h,  00h
  1837 00005DD6 0000CCFEFED6C600    <1> 	db	 00h,  00h, 0CCh, 0FEh, 0FEh, 0D6h, 0C6h,  00h
  1838 00005DDE 0000F8CCCCCCCC00    <1> 	db	 00h,  00h, 0F8h, 0CCh, 0CCh, 0CCh, 0CCh,  00h
  1839 00005DE6 000078CCCCCC7800    <1> 	db	 00h,  00h,  78h, 0CCh, 0CCh, 0CCh,  78h,  00h
  1840 00005DEE 00007C66667C6060    <1> 	db	 00h,  00h,  7Ch,  66h,  66h,  7Ch,  60h,  60h
  1841 00005DF6 00007CCCCC7C0C0C    <1> 	db	 00h,  00h,  7Ch, 0CCh, 0CCh,  7Ch,  0Ch,  0Ch
  1842 00005DFE 0000DC766660F000    <1> 	db	 00h,  00h, 0DCh,  76h,  66h,  60h, 0F0h,  00h
  1843 00005E06 00007CC0780CF800    <1> 	db	 00h,  00h,  7Ch, 0C0h,  78h,  0Ch, 0F8h,  00h
  1844 00005E0E 10307C3030341800    <1> 	db	 10h,  30h,  7Ch,  30h,  30h,  34h,  18h,  00h
  1845 00005E16 0000CCCCCCCC7C00    <1> 	db	 00h,  00h, 0CCh, 0CCh, 0CCh, 0CCh,  7Ch,  00h
  1846 00005E1E 0000CCCCCC783000    <1> 	db	 00h,  00h, 0CCh, 0CCh, 0CCh,  78h,  30h,  00h
  1847 00005E26 0000C6D6FEFE6C00    <1> 	db	 00h,  00h, 0C6h, 0D6h, 0FEh, 0FEh,  6Ch,  00h
  1848 00005E2E 0000C66C386CC600    <1> 	db	 00h,  00h, 0C6h,  6Ch,  38h,  6Ch, 0C6h,  00h
  1849 00005E36 0000CCCCCC7C0CF8    <1> 	db	 00h,  00h, 0CCh, 0CCh, 0CCh,  7Ch,  0Ch, 0F8h
  1850 00005E3E 0000FC983064FC00    <1> 	db	 00h,  00h, 0FCh,  98h,  30h,  64h, 0FCh,  00h
  1851 00005E46 1C3030E030301C00    <1> 	db	 1Ch,  30h,  30h, 0E0h,  30h,  30h,  1Ch,  00h
  1852 00005E4E 1818180018181800    <1> 	db	 18h,  18h,  18h,  00h,  18h,  18h,  18h,  00h
  1853 00005E56 E030301C3030E000    <1> 	db	0E0h,  30h,  30h,  1Ch,  30h,  30h, 0E0h,  00h
  1854 00005E5E 76DC000000000000    <1> 	db	 76h, 0DCh,  00h,  00h,  00h,  00h,  00h,  00h
  1855 00005E66 0010386CC6C6FE00    <1> 	db	 00h,  10h,  38h,  6Ch, 0C6h, 0C6h, 0FEh,  00h
  1703                                  %include	"time2.inc"
  1704                              <1> ;=========================================================================
  1705                              <1> ; time2.int - BIOS Time Services
  1706                              <1> ;       INT 1Ah - BIOS Time Serivces
  1707                              <1> ;		dispatcher
  1708                              <1> ;       INT 08h - IRQ0 interrupt handler (timer interrupt)
  1709                              <1> ;-------------------------------------------------------------------------
  1710                              <1> ;
  1711                              <1> ; Compiles with NASM 2.13.02, might work with other versions
  1712                              <1> ;
  1713                              <1> ; Copyright (C) 2010 - 2023 Sergey Kiselev.
  1714                              <1> ; Provided for hobbyist use on the Xi 8088 and Micro 8088 boards.
  1715                              <1> ;
  1716                              <1> ; This program is free software: you can redistribute it and/or modify
  1717                              <1> ; it under the terms of the GNU General Public License as published by
  1718                              <1> ; the Free Software Foundation, either version 3 of the License, or
  1719                              <1> ; (at your option) any later version.
  1720                              <1> ;
  1721                              <1> ; This program is distributed in the hope that it will be useful,
  1722                              <1> ; but WITHOUT ANY WARRANTY; without even the implied warranty of
  1723                              <1> ; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  1724                              <1> ; GNU General Public License for more details.
  1725                              <1> ;
  1726                              <1> ; You should have received a copy of the GNU General Public License
  1727                              <1> ; along with this program.  If not, see <http://www.gnu.org/licenses/>.
  1728                              <1> ;
  1729                              <1> ;=========================================================================
  1730                              <1> 
  1731                              <1> ;=========================================================================
  1732                              <1> ; int_1A - BIOS Time Services
  1733                              <1> ; Note: see time1.inc for functions implementation
  1734                              <1> ;-------------------------------------------------------------------------
  1735                              <1> 	setloc	0FE6Eh			; INT 1A Entry Point
  1736                              <1> int_1A:
  1737 00005E6E 53                  <1> 	push	bx
  1738 00005E6F 1E                  <1> 	push	ds
  1739 00005E70 BB4000              <1> 	mov	bx,biosdseg
  1740 00005E73 8EDB                <1> 	mov	ds,bx
  1741 00005E75 80FC08              <1> 	cmp	ah,.max/2
  1742 00005E78 731B                <1> 	jae	int_1A_exit
  1743 00005E7A B700                <1> 	mov	bh,0
  1744 00005E7C 88E3                <1> 	mov	bl,ah
  1745 00005E7E D1E3                <1> 	shl	bx,1
  1746 00005E80 2EFFA7[855E]        <1>     cs	jmp	near [.dispatch+bx]
  1747                              <1> .dispatch:
  1748 00005E85 [7D16]              <1> 	dw	int_1A_fn00
  1749 00005E87 [8F16]              <1> 	dw	int_1A_fn01
  1750                              <1> %ifdef AT_RTC
  1751 00005E89 [9F16]              <1> 	dw	int_1A_fn02
  1752 00005E8B [D916]              <1> 	dw	int_1A_fn03
  1753 00005E8D [2617]              <1> 	dw	int_1A_fn04
  1754 00005E8F [5E17]              <1> 	dw	int_1A_fn05
  1755 00005E91 [A517]              <1> 	dw	int_1A_fn06
  1756 00005E93 [FE17]              <1> 	dw	int_1A_fn07
  1757                              <1> %endif ; AT_RTC
  1758                              <1> .max	equ	$-.dispatch
  1759                              <1> int_1A_exit:
  1760 00005E95 1F                  <1> 	pop	ds
  1761 00005E96 5B                  <1> 	pop	bx
  1762 00005E97 CF                  <1> 	iret
  1763                              <1> int_1A_exitf:
  1764 00005E98 1F                  <1> 	pop	ds
  1765 00005E99 5B                  <1> 	pop	bx
  1766 00005E9A CA0200              <1> 	retf	2
  1767                              <1> 
  1768                              <1> ;=========================================================================
  1769                              <1> ; int_08 - IRQ0 ISR, called approximately every 55ms
  1770                              <1> ;-------------------------------------------------------------------------
  1771 00005E9D FF<rep 8h>          <1> 	setloc	0FEA5h			; INT 08 Entry Point
  1771          ******************  <1>  warning: Inserting 8 bytes [-w+user]
  1772                              <1> int_08:
  1773 00005EA5 50                  <1> 	push	ax
  1774 00005EA6 1E                  <1> 	push	ds
  1775 00005EA7 B84000              <1> 	mov	ax,biosdseg
  1776 00005EAA 8ED8                <1> 	mov	ds,ax
  1777 00005EAC 803E400000          <1> 	cmp	byte [fdc_motor_tout],0
  1778 00005EB1 7413                <1> 	jz	.1
  1779 00005EB3 FE0E4000            <1> 	dec	byte [fdc_motor_tout]
  1780 00005EB7 750D                <1> 	jnz	.1
  1781 00005EB9 80263F00F0          <1> 	and	byte [fdc_motor_state],0F0h ; update fdc_motor_state byte
  1782 00005EBE B00C                <1> 	mov	al,0Ch			; turn off motors, enable DMA + IRQ
  1783 00005EC0 52                  <1> 	push	dx
  1784 00005EC1 BAF203              <1> 	mov	dx,fdc_dor_reg		; write it to Digital Output register
  1785 00005EC4 EE                  <1> 	out	dx,al
  1786 00005EC5 5A                  <1> 	pop	dx
  1787                              <1> .1:
  1788 00005EC6 FF066C00            <1> 	inc	word [ticks_lo]
  1789 00005ECA 7504                <1> 	jnz	.2
  1790 00005ECC FF066E00            <1> 	inc	word [ticks_hi]
  1791                              <1> .2:
  1792 00005ED0 833E6E0018          <1> 	cmp	word [ticks_hi],18h	; 1573042 ticks in one day
  1793 00005ED5 7519                <1> 	jnz	.3			; which is 65536 * 24 + 178 or
  1794 00005ED7 813E6C00B200        <1> 	cmp	word [ticks_lo],0B2h	; 10000h * 18h + 0B2h
  1795 00005EDD 7511                <1> 	jnz	.3
  1796 00005EDF C7066E000000        <1> 	mov	word [ticks_hi],0
  1797 00005EE5 C7066C000000        <1> 	mov	word [ticks_lo],0
  1798 00005EEB C606700001          <1> 	mov	byte [new_day],1
  1799                              <1> .3:
  1800 00005EF0 CD1C                <1> 	int	1Ch			; User timer interrupt
  1801 00005EF2 B020                <1> 	mov	al,20h
  1802 00005EF4 E620                <1> 	out	pic1_reg0,al
  1803 00005EF6 1F                  <1> 	pop	ds
  1804 00005EF7 58                  <1> 	pop	ax
  1805 00005EF8 CF                  <1> 	iret
  1704                                  
  1705                                  ;=========================================================================
  1706                                  ; int_ignore - signal end of interrupt to PIC if hardware interrupt, return
  1707                                  ;-------------------------------------------------------------------------
  1708 00005EF9 FF<rep 2Ah>             	setloc	0FF23h			; Spurious IRQ Handler Entry Point
  1708          ******************       warning: Inserting 42 bytes [-w+user]
  1709                                  int_ignore:
  1710 00005F23 50                      	push	ax
  1711 00005F24 1E                      	push	ds
  1712 00005F25 B84000                  	mov	ax,biosdseg
  1713 00005F28 8ED8                    	mov	ds,ax
  1714 00005F2A B00B                    	mov	al,0Bh			; PIC OCW3 - read in-service register
  1715 00005F2C E620                    	out	pic1_reg0,al
  1716 00005F2E 90                      	nop
  1717 00005F2F E420                    	in	al,pic1_reg0		; get IRQ number
  1718 00005F31 88C4                    	mov	ah,al
  1719 00005F33 08C0                    	or	al,al
  1720 00005F35 7504                    	jnz	.1
  1721 00005F37 B4FF                    	mov	ah,0FFh
  1722 00005F39 EB0A                    	jmp	.2
  1723                                  .1:
  1724 00005F3B E421                    	in	al,pic1_reg1		; clear the interrupt
  1725 00005F3D 08E0                    	or	al,ah
  1726 00005F3F E621                    	out	pic1_reg1,al
  1727 00005F41 B020                    	mov	al,20h			; end of interrupt
  1728 00005F43 E620                    	out	pic1_reg0,al		; signal end of interrupt
  1729                                  .2:
  1730 00005F45 88266B00                	mov	byte [last_irq],ah
  1731 00005F49 1F                      	pop	ds
  1732 00005F4A 58                      	pop	ax
  1733 00005F4B CF                      	iret
  1734                                  
  1735                                  ;=========================================================================
  1736                                  ; int_dummy - Dummy interrupt handler. Do nothing, return.
  1737                                  ;-------------------------------------------------------------------------
  1738 00005F4C FF<rep 7h>              	setloc	0FF53h			; Dummy Interrupt Handler
  1738          ******************       warning: Inserting 7 bytes [-w+user]
  1739                                  int_dummy:
  1740 00005F53 CF                      	iret
  1741                                  
  1742                                  ;=========================================================================
  1743                                  ; int_05 - BIOS Print Screen
  1744                                  ;-------------------------------------------------------------------------
  1745                                  	setloc	0FF54h			; INT 05 (Print Screen) Entry Point
  1746                                  int_05:
  1747 00005F54 FB                      	sti
  1748 00005F55 50                      	push	ax
  1749 00005F56 53                      	push	bx
  1750 00005F57 51                      	push	cx
  1751 00005F58 52                      	push	dx
  1752 00005F59 1E                      	push	ds
  1753 00005F5A B84000                  	mov	ax,biosdseg
  1754 00005F5D 8ED8                    	mov	ds,ax			; DS = BIOS data segment
  1755 00005F5F 803E000101              	cmp	byte [prt_scrn_flags],prt_scrn_run
  1756 00005F64 746A                    	je	.exit			; print screen is already in progress
  1757 00005F66 C606000101              	mov	byte [prt_scrn_flags],prt_scrn_run
  1758                                  					; signal that print screen is running
  1759                                  
  1760 00005F6B B40F                    	mov	ah,0Fh			; get video mode parameters
  1761 00005F6D CD10                    	int	10h			; returns number of columns in AH
  1762                                  					; and active display page in BH
  1763 00005F6F 88E1                    	mov	cl,ah			; store number columns
  1764                                  
  1765 00005F71 8A2E8400                	mov	ch,byte [video_rows]	; try getting number of rows
  1766 00005F75 08ED                    	or	ch,ch
  1767 00005F77 7407                    	jz	.wrong_num_rows		; CH == 0, apparently not initialized
  1768                                  
  1769 00005F79 FEC5                    	inc	ch			; CH = number of rows (on EGA/VGA)
  1770 00005F7B 80FD3C                  	cmp	ch,60			; 60 rows maximum (as far as I know)
  1771 00005F7E 7602                    	jbe	.get_cursor_pos
  1772                                  
  1773                                  .wrong_num_rows:
  1774 00005F80 B519                    	mov	ch,25			; assume 25 rows
  1775                                  
  1776                                  .get_cursor_pos:
  1777 00005F82 B403                    	mov	ah,03h			; get cursor position and size
  1778 00005F84 CD10                    	int	10h			; returns cursor position in DX
  1779 00005F86 52                      	push	dx			; save original position / DX in stack
  1780                                  
  1781                                  	
  1782 00005F87 B40D                    	mov	ah,0Dh			; move to the next line
  1783 00005F89 E85100                  	call	.print_char
  1784 00005F8C 7548                    	jnz	.error
  1785 00005F8E B40A                    	mov	ah,0Ah
  1786 00005F90 E84A00                  	call	.print_char
  1787 00005F93 7541                    	jnz	.error
  1788                                  
  1789 00005F95 B600                    	mov 	dh,0			; start from the first row (0)
  1790                                  
  1791                                  .row_loop:
  1792 00005F97 B200                    	mov 	dl,0			; start from the first column (0)
  1793                                  
  1794                                  .column_loop:
  1795 00005F99 B402                    	mov	ah,02h
  1796 00005F9B CD10                    	int	10h			; set cursor position (position in DX)
  1797                                  
  1798 00005F9D B408                    	mov	ah,08h
  1799 00005F9F CD10                    	int	10h			; read character at cursor position
  1800                                  
  1801 00005FA1 3C20                    	cmp	al,20h			; control character?
  1802 00005FA3 7302                    	jae	.continue		; no, print it
  1803 00005FA5 B020                    	mov	al,20h			; print space instead
  1804                                  
  1805                                  .continue:
  1806 00005FA7 E83300                  	call	.print_char
  1807 00005FAA 752A                    	jnz	.error
  1808 00005FAC FEC2                    	inc	dl
  1809 00005FAE 38CA                    	cmp	dl,cl			; on the last column?
  1810 00005FB0 72E7                    	jb	.column_loop		; print next column
  1811                                  
  1812 00005FB2 B40D                    	mov	ah,0Dh			; move to the next line
  1813 00005FB4 E82600                  	call	.print_char
  1814 00005FB7 751D                    	jnz	.error
  1815 00005FB9 B40A                    	mov	ah,0Ah
  1816 00005FBB E81F00                  	call	.print_char
  1817 00005FBE 7516                    	jnz	.error
  1818                                  
  1819 00005FC0 FEC6                    	inc	dh
  1820 00005FC2 38EE                    	cmp	dh,ch			; on the last row?
  1821 00005FC4 72D1                    	jb	.row_loop		; print next row
  1822                                  
  1823 00005FC6 C606000100              	mov	byte [prt_scrn_flags],prt_scrn_ready
  1824                                  					; ready for the next call
  1825                                  
  1826                                  .restore_cursor:
  1827 00005FCB 5A                      	pop	dx			; DX = original cursor position
  1828 00005FCC B402                    	mov	ah,02h
  1829 00005FCE CD10                    	int	10h			; set cursor position (position in DX)
  1830                                  
  1831                                  .exit:
  1832 00005FD0 1F                      	pop	ds
  1833 00005FD1 5A                      	pop	dx
  1834 00005FD2 59                      	pop	cx
  1835 00005FD3 5B                      	pop	bx
  1836 00005FD4 58                      	pop	ax
  1837 00005FD5 CF                      	iret
  1838                                  
  1839                                  .error:
  1840 00005FD6 C6060001FF              	mov	byte [prt_scrn_flags],prt_scrn_fail
  1841                                  					; signal failure
  1842 00005FDB EBEE                    	jmp	.restore_cursor
  1843                                  	
  1844                                  
  1845                                  .print_char:
  1846 00005FDD 52                      	push	dx
  1847 00005FDE 31D2                    	xor	dx,dx			; DX = 0 - first printer port
  1848 00005FE0 B400                    	mov	ah,00h			; INT 17h, AH=10h - print character
  1849 00005FE2 CD17                    	int	17h
  1850 00005FE4 5A                      	pop	dx
  1851 00005FE5 F6C425                  	test	ah,25h			; ZF = 0 - no error
  1852 00005FE8 C3                      	ret
  1853                                  
  1854                                  ;=========================================================================
  1855                                  ; start - at power up or reset execution starts here (F000:FFF0)
  1856                                  ;-------------------------------------------------------------------------
  1857 00005FE9 FF<rep 7h>                      setloc	0FFF0h			; Power-On Entry Point
  1857          ******************       warning: Inserting 7 bytes [-w+user]
  1858                                  start:
  1859 00005FF0 EA[5B40]00F0                    jmp     bioscseg:cold_start
  1860                                  
  1861                                  	setloc	0FFF5h			; ROM Date in ASCII
  1862 00005FF5 30362F32362F3233        	db	DATE			; BIOS release date MM/DD/YY
  1863 00005FFD 20                      	db	20h
  1864                                  
  1865                                  	setloc	0FFFEh			; System Model byte
  1866 00005FFE FE                      	db	MODEL_BYTE
  1867 00005FFF FF                      	db	0ffh
